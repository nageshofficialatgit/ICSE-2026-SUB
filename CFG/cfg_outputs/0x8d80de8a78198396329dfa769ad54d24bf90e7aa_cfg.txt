Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(a == 0 || c / a == b)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 2
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: max64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a >= b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: max256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a >= b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4


Contract: tokenRecipient
==================================================


Contract: NamiCrowdSale
==================================================

Function: NamiCrowdSale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_namiMultiSigWallet != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: escrow = _escrow

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: namiMultiSigWallet = _namiMultiSigWallet

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: namiPresale = _namiPresale

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balanceOf[_from] >= _value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balanceOf[_to] + _value > balanceOf[_to])

  ID: 4
  Type: NodeType.VARIABLE
  Expression: previousBalances = balanceOf[_from] + balanceOf[_to]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_from] -= _value

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_to] += _value

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: transferForTeam
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transfer(msg.sender,_to,_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 2
  2 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transfer(msg.sender,_to,_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyTranferable()

Edges:
  0 -> 2
  2 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= allowance[_from][msg.sender])

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowance[_from][msg.sender] -= _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(_from,_to,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyTranferable()

  ID: 6
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowance[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.RETURN
  Expression: true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyTranferable()

  ID: 4
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: approveAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = tokenRecipient(_spender)

  ID: 2
  Type: NodeType.IF
  Expression: approve(_spender,_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: spender.receiveApproval(msg.sender,_value,this,_extraData)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyTranferable()

  ID: 7
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  5 -> 7
  6 -> 1

Function: changeTransferable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: TRANSFERABLE = ! TRANSFERABLE

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 2
  2 -> 1

Function: changeEscrow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_escrow != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: escrow = _escrow

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyNamiMultisig()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeBinary
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: binary = _binary

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 2
  2 -> 1

Function: changeBinaryAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_binaryAddress != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: binaryAddress = _binaryAddress

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: getPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: now < 1517443200

  ID: 2
  Type: NodeType.RETURN
  Expression: 3450

  ID: 3
  Type: NodeType.IF
  Expression: 1517443200 < now && now <= 1518048000

  ID: 4
  Type: NodeType.RETURN
  Expression: 2400

  ID: 5
  Type: NodeType.IF
  Expression: 1518048000 < now && now <= 1518652800

  ID: 6
  Type: NodeType.RETURN
  Expression: 2300

  ID: 7
  Type: NodeType.IF
  Expression: 1518652800 < now && now <= 1519257600

  ID: 8
  Type: NodeType.RETURN
  Expression: 2200

  ID: 9
  Type: NodeType.IF
  Expression: 1519257600 < now && now <= 1519862400

  ID: 10
  Type: NodeType.RETURN
  Expression: 2100

  ID: 11
  Type: NodeType.IF
  Expression: 1519862400 < now && now <= 1520467200

  ID: 12
  Type: NodeType.RETURN
  Expression: 2000

  ID: 13
  Type: NodeType.IF
  Expression: 1520467200 < now && now <= 1521072000

  ID: 14
  Type: NodeType.RETURN
  Expression: 1900

  ID: 15
  Type: NodeType.IF
  Expression: 1521072000 < now && now <= 1521676800

  ID: 16
  Type: NodeType.RETURN
  Expression: 1800

  ID: 17
  Type: NodeType.IF
  Expression: 1521676800 < now && now <= 1522281600

  ID: 18
  Type: NodeType.RETURN
  Expression: 1700

  ID: 19
  Type: NodeType.RETURN
  Expression: binary

  ID: 29
  Type: NodeType.RETURN
  Expression: price

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  15 -> 17
  17 -> 18
  17 -> 19

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: buy(msg.sender)

Edges:
  0 -> 1

Function: buy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(currentPhase == Phase.Running)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(now <= 1522281600 || msg.sender == binaryAddress)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value != 0)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: newTokens = msg.value * getPrice()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(totalSupply + newTokens < TOKEN_SUPPLY_LIMIT)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_buyer] = balanceOf[_buyer].add(newTokens)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.add(newTokens)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: LogBuy(_buyer,newTokens)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Transfer(this,_buyer,newTokens)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: burnTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(currentPhase == Phase.Migrating)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokens = balanceOf[_owner]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(tokens != 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_owner] = 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: totalSupply -= tokens

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: LogBurn(_owner,tokens)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_owner,crowdsaleManager,tokens)

  ID: 8
  Type: NodeType.IF
  Expression: totalSupply == 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: currentPhase = Phase.Migrated

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: LogPhaseSwitch(Phase.Migrated)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyCrowdsaleManager()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 11
  9 -> 10
  10 -> 11
  12 -> 1

Function: setPresalePhase
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: canSwitchPhase = (currentPhase == Phase.Created && _nextPhase == Phase.Running) || (currentPhase == Phase.Running && _nextPhase == Phase.Paused) || ((currentPhase == Phase.Running || currentPhase == Phase.Paused) && _nextPhase == Phase.Migrating && crowdsaleManager != 0x0) || (currentPhase == Phase.Paused && _nextPhase == Phase.Running) || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated && totalSupply == 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(canSwitchPhase)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: currentPhase = _nextPhase

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: LogPhaseSwitch(_nextPhase)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: withdrawEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(namiMultiSigWallet != 0x0)

  ID: 2
  Type: NodeType.IF
  Expression: this.balance > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: namiMultiSigWallet.transfer(_amount)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: safeWithdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: namiWallet = NamiMultiSigWallet(namiMultiSigWallet)

  ID: 2
  Type: NodeType.IF
  Expression: namiWallet.isOwner(_withdraw)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _withdraw.transfer(_amount)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: setCrowdsaleManager
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(currentPhase != Phase.Migrating)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: crowdsaleManager = _mgr

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _migrateToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: presale = PresaleToken(namiPresale)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: newToken = presale.balanceOf(_from)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newToken > 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: presale.burnTokens(_from)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_to] = balanceOf[_to].add(newToken)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.add(newToken)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: LogMigrate(_from,_to,newToken)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Transfer(this,_to,newToken)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: migrateToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _migrateToken(_from,_to)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 2
  2 -> 1

Function: migrateForInvestor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _migrateToken(msg.sender,msg.sender)

Edges:
  0 -> 1

Function: transferToExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_to] = balanceOf[_to].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 7
  Type: NodeType.IF
  Expression: codeLength > 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: receiver = ERC223ReceivingContract(_to)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: receiver.tokenFallbackExchange(msg.sender,_value,_price)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferToExchange(msg.sender,_to,_value,_price)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 11

Function: transferToBuyer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balanceOf[_to] = balanceOf[_to].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 7
  Type: NodeType.IF
  Expression: codeLength > 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: receiver = ERC223ReceivingContract(_to)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: receiver.tokenFallbackBuyer(msg.sender,_value,_buyer)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferToBuyer(msg.sender,_to,_value,_buyer)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 11

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Nami ICO

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = NAC

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: TRANSFERABLE = false

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: binary = 0

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: currentPhase = Phase.Created

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalSupply = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: TOKEN_SUPPLY_LIMIT = 1000000000 * (1000000000000000000 / 1)

Edges:


Contract: BinaryOption
==================================================

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Deposit(msg.sender,msg.value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: BinaryOption
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_namiCrowdSale != 0x0 && _escrow != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: namiCrowdSaleAddr = _namiCrowdSale

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: escrow = _escrow

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: namiMultiSigWallet = _namiMultiSigWallet

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: changeEscrow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_escrow != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: escrow = _escrow

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyNamiMultisig()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeTimeInvest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! session.isOpen && _timeInvest < timeOneSession)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: timeInvestInMinute = _timeInvest

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(100 < _rate && _rate < 200 && ! session.isOpen)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: rate = _rate

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeTimeOneSession
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! session.isOpen && _timeOneSession > timeInvestInMinute)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: timeOneSession = _timeOneSession

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: withdrawEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(namiMultiSigWallet != 0x0)

  ID: 2
  Type: NodeType.IF
  Expression: this.balance > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: namiMultiSigWallet.transfer(_amount)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: safeWithdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: namiWallet = NamiMultiSigWallet(namiMultiSigWallet)

  ID: 2
  Type: NodeType.IF
  Expression: namiWallet.isOwner(_withdraw)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _withdraw.transfer(_amount)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: getInvestors
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < MAX_INVESTOR

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: listInvestor[i] = session.investor[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: listInvestor

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: getChooses
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < MAX_INVESTOR

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: listChooses[i] = session.win[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: listChooses

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: getAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < MAX_INVESTOR

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: listAmount[i] = session.amountInvest[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: listAmount

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: resetSession
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! session.isReset && ! session.isOpen)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: session.priceOpen = 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: session.priceClose = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: session.isReset = true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: session.isOpen = false

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: session.investOpen = false

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: session.investorCount = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < MAX_INVESTOR

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: session.investor[i] = 0x0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: session.win[i] = false

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: session.amountInvest[i] = 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 16
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 11
  16 -> 1

Function: openSession
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(session.isReset && ! session.isOpen)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: session.isReset = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: session.investOpen = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: session.timeOpen = now

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: session.isOpen = true

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: SessionOpen(now,sessionId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 1

Function: invest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value >= 100000000000000000 && session.investOpen)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(now < (session.timeOpen + timeInvestInMinute * 60))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(session.investorCount < MAX_INVESTOR && session.investedSession[msg.sender] != sessionId)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: session.investor[session.investorCount] = msg.sender

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: session.win[session.investorCount] = _choose

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: session.amountInvest[session.investorCount] = msg.value

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: session.investorCount += 1

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: session.investedSession[msg.sender] = sessionId

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Invest(msg.sender,_choose,msg.value,now,sessionId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: closeInvest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_priceOpen != 0 && session.investOpen)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(now > (session.timeOpen + timeInvestInMinute * 60))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: session.investOpen = false

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: session.priceOpen = _priceOpen

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: InvestClose(now,_priceOpen,sessionId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: getEtherToBuy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status

  ID: 2
  Type: NodeType.RETURN
  Expression: _ether * _rate / 100

  ID: 3
  Type: NodeType.RETURN
  Expression: _ether * (200 - _rate) / 100

Edges:
  0 -> 1
  1 -> 2
  1 -> 3

Function: closeSession
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_priceClose != 0 && now > (session.timeOpen + timeOneSession * 60))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! session.investOpen && session.isOpen)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: session.priceClose = _priceClose

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: namiContract = NamiCrowdSale(namiCrowdSaleAddr)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: price = namiContract.getPrice()

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < session.investorCount

  ID: 12
  Type: NodeType.IF
  Expression: session.win[i] == result

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: etherToBuy = getEtherToBuy(session.amountInvest[i],rate,true)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: etherToBuy = getEtherToBuy(session.amountInvest[i],rate,false)

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: namiContract.buy.value(etherToBuy)(session.investor[i])

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: session.investor[i] = 0x0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: session.win[i] = false

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: session.amountInvest[i] = 0

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: session.isOpen = false

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: SessionClose(now,sessionId,_priceClose,price,rate)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: sessionId += 1

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: session.priceOpen = 0

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: session.priceClose = 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: session.isReset = true

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: session.investOpen = false

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: session.investorCount = 0

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: onlyEscrow()

  ID: 30
  Type: NodeType.IF
  Expression: (_priceClose > session.priceOpen)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: result = true

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: result = false

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 29
  1 -> 2
  2 -> 3
  3 -> 30
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 21
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 11
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  29 -> 1
  30 -> 31
  30 -> 32
  31 -> 33
  32 -> 33
  33 -> 5

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: timeInvestInMinute = 30

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: timeOneSession = 180

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: sessionId = 1

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: rate = 190

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_INVESTOR = 20

Edges:


Contract: PresaleToken
==================================================


Contract: ERC223ReceivingContract
==================================================


Contract: NamiExchange
==================================================

Function: NamiExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: NamiAddr = _namiAddress

Edges:
  0 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value > 0)

  ID: 2
  Type: NodeType.IF
  Expression: bid[msg.sender].price > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: bid[msg.sender].eth = (bid[msg.sender].eth).add(msg.value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: etherBalance = etherBalance.add(msg.value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: UpdateBid(msg.sender,bid[msg.sender].price,bid[msg.sender].eth)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(msg.value)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  4 -> 5
  5 -> 7
  6 -> 7

Function: tokenFallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value > 0 && _data.length == 0)

  ID: 2
  Type: NodeType.IF
  Expression: ask[_from].price > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ask[_from].volume = (ask[_from].volume).add(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nacBalance = nacBalance.add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: UpdateAsk(_from,ask[_from].price,ask[_from].volume)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.VARIABLE
  Expression: asset = ERC23(NamiAddr)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: asset.transfer(_from,_value)

  ID: 9
  Type: NodeType.RETURN
  Expression: false

  ID: 11
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 9

Function: placeBuyOrder
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_price > 0)

  ID: 2
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: etherBalance += msg.value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: bid[msg.sender].eth = (bid[msg.sender].eth).add(msg.value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: UpdateBid(msg.sender,_price,bid[msg.sender].eth)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: bid[msg.sender].price = _price

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: tokenFallbackBuyer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: asset = ERC23(NamiAddr)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentEth = bid[_buyer].eth

  ID: 3
  Type: NodeType.IF
  Expression: (_value.div(bid[_buyer].price)) > currentEth

  ID: 4
  Type: NodeType.IF
  Expression: _from.send(currentEth) && asset.transfer(_buyer,currentEth.mul(bid[_buyer].price)) && asset.transfer(_from,_value - (currentEth.mul(bid[_buyer].price)))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: bid[_buyer].eth = 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: etherBalance = etherBalance.sub(currentEth)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

  ID: 8
  Type: NodeType.RETURN
  Expression: true

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: asset.transfer(_from,_value)

  ID: 10
  Type: NodeType.RETURN
  Expression: false

  ID: 12
  Type: NodeType.VARIABLE
  Expression: eth = _value.div(bid[_buyer].price)

  ID: 13
  Type: NodeType.IF
  Expression: _from.send(eth) && asset.transfer(_buyer,_value)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: bid[_buyer].eth = (bid[_buyer].eth).sub(eth)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: etherBalance = etherBalance.sub(eth)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

  ID: 17
  Type: NodeType.RETURN
  Expression: true

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: asset.transfer(_from,_value)

  ID: 19
  Type: NodeType.RETURN
  Expression: false

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: onlyNami()

  ID: 23
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 22
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 12
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  12 -> 13
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  16 -> 17
  18 -> 19
  22 -> 1

Function: closeBidOrder
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(bid[msg.sender].eth > 0 && bid[msg.sender].price > 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(bid[msg.sender].eth)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: etherBalance = etherBalance.sub(bid[msg.sender].eth)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: bid[msg.sender].eth = 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: UpdateBid(msg.sender,bid[msg.sender].price,bid[msg.sender].eth)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: tokenFallbackExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_price > 0)

  ID: 2
  Type: NodeType.IF
  Expression: _value > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: nacBalance = nacBalance.add(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ask[_from].volume = (ask[_from].volume).add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ask[_from].price = _price

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: UpdateAsk(_from,_price,ask[_from].volume)

  ID: 7
  Type: NodeType.RETURN
  Expression: true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ask[_from].price = _price

  ID: 9
  Type: NodeType.RETURN
  Expression: false

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyNami()

  ID: 12
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 9
  11 -> 1

Function: closeAskOrder
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(ask[msg.sender].volume > 0 && ask[msg.sender].price > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: asset = ERC23(NamiAddr)

  ID: 3
  Type: NodeType.IF
  Expression: asset.transfer(msg.sender,ask[msg.sender].volume)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nacBalance = nacBalance.sub(ask[msg.sender].volume)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ask[msg.sender].volume = 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: UpdateAsk(msg.sender,ask[msg.sender].price,0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 7

Function: buyNac
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: asset = ERC23(NamiAddr)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: maxEth = (ask[_seller].volume).div(ask[_seller].price)

  ID: 4
  Type: NodeType.IF
  Expression: msg.value > maxEth

  ID: 5
  Type: NodeType.IF
  Expression: _seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth)) && asset.transfer(msg.sender,ask[_seller].volume)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: nacBalance = nacBalance.sub(ask[_seller].volume)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ask[_seller].volume = 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: UpdateAsk(_seller,ask[_seller].price,0)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.RETURN
  Expression: false

  ID: 12
  Type: NodeType.IF
  Expression: _seller.send(msg.value) && asset.transfer(msg.sender,(msg.value).mul(ask[_seller].price))

  ID: 13
  Type: NodeType.VARIABLE
  Expression: nac = (msg.value).mul(ask[_seller].price)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: nacBalance = nacBalance.sub(nac)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ask[_seller].volume = (ask[_seller].volume).sub(nac)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UpdateAsk(_seller,ask[_seller].price,ask[_seller].volume)

  ID: 17
  Type: NodeType.RETURN
  Expression: true

  ID: 18
  Type: NodeType.RETURN
  Expression: false

  ID: 21
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 12
  5 -> 6
  5 -> 10
  6 -> 7
  7 -> 8
  8 -> 9
  12 -> 13
  12 -> 18
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = NacExchange

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: price = 1

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: etherBalance = 0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: nacBalance = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: ERC23
==================================================


Contract: NamiMultiSigWallet
==================================================

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Deposit(msg.sender,msg.value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: NamiMultiSigWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < _owners.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! (isOwner[_owners[i]] || _owners[i] == 0))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isOwner[_owners[i]] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: owners = _owners

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: required = _required

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: validRequirement(_owners.length,_required)

Edges:
  0 -> 10
  1 -> 4
  2 -> 8
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 7
  7 -> 4
  8 -> 9
  10 -> 3

Function: addOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: isOwner[owner] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owners.push(owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnerAddition(owner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyWallet()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ownerDoesNotExist(owner)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: notNull(owner)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: validRequirement(owners.length + 1,required)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 1

Function: removeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: isOwner[owner] = false

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < owners.length - 1

  ID: 6
  Type: NodeType.IF
  Expression: owners[i] == owner

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: owners[i] = owners[owners.length - 1]

  ID: 8
  Type: NodeType.BREAK
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: owners.length -= 1

  ID: 12
  Type: NodeType.IF
  Expression: required > owners.length

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: changeRequirement(owners.length)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: OwnerRemoval(owner)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: onlyWallet()

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ownerExists(owner)

Edges:
  0 -> 16
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 9
  7 -> 8
  8 -> 3
  9 -> 10
  10 -> 5
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  16 -> 17
  17 -> 1

Function: replaceOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 5
  Type: NodeType.IF
  Expression: owners[i] == owner

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: owners[i] = newOwner

  ID: 7
  Type: NodeType.BREAK
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: isOwner[owner] = false

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: isOwner[newOwner] = true

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OwnerRemoval(owner)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: OwnerAddition(newOwner)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onlyWallet()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ownerExists(owner)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ownerDoesNotExist(newOwner)

Edges:
  0 -> 14
  1 -> 4
  2 -> 10
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 2
  8 -> 9
  9 -> 4
  10 -> 11
  11 -> 12
  12 -> 13
  14 -> 15
  15 -> 16
  16 -> 3

Function: changeRequirement
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: required = _required

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RequirementChange(_required)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyWallet()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: validRequirement(owners.length,_required)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: submitTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transactionId = addTransaction(destination,value,data)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: confirmTransaction(transactionId)

  ID: 3
  Type: NodeType.RETURN
  Expression: transactionId

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: confirmTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: confirmations[transactionId][msg.sender] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Confirmation(msg.sender,transactionId)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: executeTransaction(transactionId)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownerExists(msg.sender)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: transactionExists(transactionId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: notConfirmed(transactionId,msg.sender)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 1

Function: revokeConfirmation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: confirmations[transactionId][msg.sender] = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Revocation(msg.sender,transactionId)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownerExists(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: confirmed(transactionId,msg.sender)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: notExecuted(transactionId)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 5
  5 -> 1

Function: executeTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: isConfirmed(transactionId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: transactions[transactionId].executed = true

  ID: 3
  Type: NodeType.IF
  Expression: transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Execution(transactionId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ExecutionFailure(transactionId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: transactions[transactionId].executed = false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: notExecuted(transactionId)

Edges:
  0 -> 9
  1 -> 2
  1 -> 8
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: isConfirmed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 6
  Type: NodeType.IF
  Expression: confirmations[transactionId][owners[i]]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: count == required

  ID: 10
  Type: NodeType.RETURN
  Expression: true

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  12 -> 5

Function: addTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transactionId = transactionCount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: transactions[transactionId] = Transaction({destination:destination,value:value,data:data,executed:false})

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: transactionCount += 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Submission(transactionId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: notNull(destination)

  ID: 6
  Type: NodeType.RETURN
  Expression: transactionId

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  5 -> 1

Function: getConfirmationCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 5
  Type: NodeType.IF
  Expression: confirmations[transactionId][owners[i]]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 4

Function: getTransactionCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < transactionCount

  ID: 5
  Type: NodeType.IF
  Expression: pending && ! transactions[i].executed || executed && transactions[i].executed

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 4

Function: getOwners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: owners

Edges:
  0 -> 1

Function: getConfirmations
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: confirmationsTemp = new address[](owners.length)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 8
  Type: NodeType.IF
  Expression: confirmations[transactionId][owners[i]]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: confirmationsTemp[count] = owners[i]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _confirmations = new address[](count)

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 17
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _confirmations[i] = confirmationsTemp[i]

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.RETURN
  Expression: _confirmations

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 13
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 11
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 7
  13 -> 16
  14 -> 17
  15 -> 20
  16 -> 14
  17 -> 18
  17 -> 15
  18 -> 19
  19 -> 17

Function: getTransactionIds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: transactionIdsTemp = new uint256[](transactionCount)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < transactionCount

  ID: 8
  Type: NodeType.IF
  Expression: pending && ! transactions[i].executed || executed && transactions[i].executed

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: transactionIdsTemp[count] = i

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _transactionIds = new uint256[](to - from)

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i = from

  ID: 17
  Type: NodeType.IFLOOP
  Expression: i < to

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _transactionIds[i - from] = transactionIdsTemp[i]

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.RETURN
  Expression: _transactionIds

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 13
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 11
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 7
  13 -> 16
  14 -> 17
  15 -> 20
  16 -> 14
  17 -> 18
  17 -> 15
  18 -> 19
  19 -> 17

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_OWNER_COUNT = 50

Edges:


