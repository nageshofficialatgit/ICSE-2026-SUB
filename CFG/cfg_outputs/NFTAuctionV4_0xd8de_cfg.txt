Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: IERC165
==================================================


Contract: IERC2981
==================================================


Contract: ERC165
==================================================

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC165).interfaceId

Edges:
  0 -> 1


Contract: ERC2981
==================================================

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC2981).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _royaltyInfo = _tokenRoyaltyInfo[tokenId]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: royaltyReceiver = _royaltyInfo.receiver

  ID: 3
  Type: NodeType.VARIABLE
  Expression: royaltyFraction = _royaltyInfo.royaltyFraction

  ID: 4
  Type: NodeType.IF
  Expression: royaltyReceiver == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: royaltyReceiver = _defaultRoyaltyInfo.receiver

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: royaltyFraction = _defaultRoyaltyInfo.royaltyFraction

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: royaltyAmount = (salePrice * royaltyFraction) / _feeDenominator()

  ID: 9
  Type: NodeType.RETURN
  Expression: (royaltyReceiver,royaltyAmount)

  ID: 10
  Type: NodeType.RETURN
  Expression: (receiver,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: denominator = _feeDenominator()

  ID: 2
  Type: NodeType.IF
  Expression: feeNumerator > denominator

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert ERC2981InvalidDefaultRoyalty(uint256,uint256)(feeNumerator,denominator)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert ERC2981InvalidDefaultRoyaltyReceiver(address)(address(0))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyaltyInfo = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyaltyInfo

Edges:
  0 -> 1

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: denominator = _feeDenominator()

  ID: 2
  Type: NodeType.IF
  Expression: feeNumerator > denominator

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert ERC2981InvalidTokenRoyalty(uint256,uint256,uint256)(tokenId,feeNumerator,denominator)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert ERC2981InvalidTokenRoyaltyReceiver(uint256,address)(tokenId,address(0))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _tokenRoyaltyInfo[tokenId]

Edges:
  0 -> 1


Contract: SafeCast
==================================================

Function: toUint248
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint248).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(248,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint248(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint240
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint240).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(240,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint240(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint232
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint232).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(232,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint232(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint224
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint224).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(224,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint224(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint216
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint216).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(216,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint216(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint208
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint208).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(208,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint208(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint200
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint200).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(200,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint200(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint192
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint192).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(192,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint192(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint184
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint184).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(184,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint184(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint176
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint176).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(176,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint176(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint168
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint168).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(168,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint168(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint160
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint160).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(160,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint160(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint152
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint152).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(152,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint152(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint144
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint144).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(144,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint144(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint136
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint136).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(136,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint136(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint128
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint128).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(128,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint128(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint120
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint120).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(120,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint120(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint112
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint112).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(112,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint112(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint104
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint104).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(104,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint104(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint96
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint96).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(96,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint96(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint88
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint88).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(88,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint88(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint80
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint80).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(80,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint80(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint72
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint72).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(72,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint72(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint64).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(64,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint64(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint56
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint56).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(56,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint56(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint48
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint48).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(48,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint48(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint40
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint40).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(40,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint40(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint32).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(32,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint32(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint24
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint24).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(24,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint24(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint16
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint16).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(16,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint16(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint8
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > type()(uint8).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintDowncast(uint8,uint256)(8,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint8(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value < 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntToUint(int256)(value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint256(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toInt248
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int248(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(248,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt240
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int240(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(240,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt232
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int232(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(232,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt224
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int224(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(224,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt216
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int216(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(216,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt208
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int208(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(208,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt200
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int200(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(200,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt192
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int192(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(192,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt184
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int184(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(184,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt176
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int176(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(176,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt168
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int168(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(168,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt160
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int160(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(160,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt152
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int152(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(152,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt144
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int144(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(144,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt136
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int136(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(136,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt128
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int128(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(128,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt120
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int120(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(120,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt112
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int112(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(112,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt104
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int104(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(104,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt96
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int96(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(96,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt88
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int88(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(88,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt80
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int80(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(80,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt72
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int72(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(72,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int64(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(64,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt56
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int56(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(56,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt48
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int48(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(48,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt40
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int40(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(40,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int32(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(32,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt24
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int24(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(24,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt16
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int16(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(16,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt8
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: downcasted = int8(value)

  ID: 2
  Type: NodeType.IF
  Expression: downcasted != value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedIntDowncast(uint8,int256)(8,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: downcasted

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: toInt256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: value > uint256(type()(int256).max)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert SafeCastOverflowedUintToInt(uint256)(value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: int256(value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: toUint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: u = ! ! b

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: u

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: Panic
==================================================

Function: panic
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0x4e487b71)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,code)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x24)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: GENERIC = 0x00

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ASSERT = 0x01

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: UNDER_OVERFLOW = 0x11

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DIVISION_BY_ZERO = 0x12

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENUM_CONVERSION_ERROR = 0x21

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: STORAGE_ENCODING_ERROR = 0x22

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EMPTY_ARRAY_POP = 0x31

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ARRAY_OUT_OF_BOUNDS = 0x32

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RESOURCE_ERROR = 0x41

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: INVALID_INTERNAL_FUNCTION = 0x51

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9


Contract: Math
==================================================

Function: tryAdd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.IF
  Expression: c < a

  ID: 3
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (true,c)

  ID: 6
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: trySub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: b > a

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (true,a - b)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: tryMul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (true,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.IF
  Expression: c / a != b

  ID: 6
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (true,c)

  ID: 9
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: tryDiv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: b == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (true,a / b)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: tryMod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: b == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (true,a % b)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: ternary
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: b ^ ((a ^ b) * SafeCast.toUint(condition))

Edges:
  0 -> 1

Function: max
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ternary(a > b,a,b)

Edges:
  0 -> 1

Function: min
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ternary(a < b,a,b)

Edges:
  0 -> 1

Function: average
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (a & b) + (a ^ b) / 2

Edges:
  0 -> 1

Function: ceilDiv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: b == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Panic.panic(Panic.DIVISION_BY_ZERO)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: SafeCast.toUint(a > 0) * ((a - 1) / b + 1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: mulDiv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: mulDiv(x,y,denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0)

Edges:
  0 -> 1

Function: invMod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: n == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: remainder = a % n

  ID: 5
  Type: NodeType.VARIABLE
  Expression: gcd = n

  ID: 6
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: y = 1

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: remainder != 0

  ID: 10
  Type: NodeType.VARIABLE
  Expression: quotient = gcd / remainder

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (gcd,remainder) = (remainder,gcd - remainder * quotient)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: (x,y) = (y,x - y * int256(quotient))

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: gcd != 1

  ID: 15
  Type: NodeType.RETURN
  Expression: 0

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.RETURN
  Expression: ternary(x < 0,n - uint256(- x),uint256(x))

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  11 -> 12
  12 -> 9
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: invModPrime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: Math.modExp(a,p - 2,p)

Edges:
  0 -> 1

Function: modExp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,result) = tryModExp(b,e,m)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Panic.panic(Panic.DIVISION_BY_ZERO)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: tryModExp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _zeroBytes(m)

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,new bytes(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: mLen = m.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: result = abi.encodePacked(b.length,e.length,mLen,b,e,m)

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: dataPtr_tryModExp_asm_0 = result + 0x20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: success = staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),0x05,dataPtr_tryModExp_asm_0,mload(uint256)(result),dataPtr_tryModExp_asm_0,mLen)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(result,mLen)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,dataPtr_tryModExp_asm_0 + mLen)

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: (success,result)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13

Function: _zeroBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < byteArray.length

  ID: 5
  Type: NodeType.IF
  Expression: byteArray[i] != 0

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 9
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: sqrt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = sqrt(a)

  ID: 2
  Type: NodeType.RETURN
  Expression: result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a)

Edges:
  0 -> 1
  1 -> 2

Function: log2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log2(value)

  ID: 2
  Type: NodeType.RETURN
  Expression: result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value)

Edges:
  0 -> 1
  1 -> 2

Function: log10
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log10(value)

  ID: 2
  Type: NodeType.RETURN
  Expression: result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value)

Edges:
  0 -> 1
  1 -> 2

Function: log256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log256(value)

  ID: 2
  Type: NodeType.RETURN
  Expression: result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value)

Edges:
  0 -> 1
  1 -> 2

Function: unsignedRoundsUp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint8(rounding) % 2 == 1

Edges:
  0 -> 1


Contract: SignedMath
==================================================

Function: ternary
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: b ^ ((a ^ b) * int256(SafeCast.toUint(condition)))

Edges:
  0 -> 1

Function: max
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ternary(a > b,a,b)

Edges:
  0 -> 1

Function: min
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ternary(a < b,a,b)

Edges:
  0 -> 1

Function: average
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: x = (a & b) + ((a ^ b) >> 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: x + (int256(uint256(x) >> 255) & (a ^ b))

Edges:
  0 -> 1
  1 -> 2

Function: abs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: mask = n >> 255

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256((n + mask) ^ mask)

Edges:
  0 -> 1
  1 -> 2


Contract: Strings
==================================================

Function: toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: length = Math.log10(value) + 1

  ID: 2
  Type: NodeType.VARIABLE
  Expression: buffer = new string(length)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ptr = buffer + 32 + length

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: true

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ptr --

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(ptr,byte(uint256,uint256)(value % 10,HEX_DIGITS))

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: value /= 10

  ID: 14
  Type: NodeType.IF
  Expression: value == 0

  ID: 15
  Type: NodeType.BREAK
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: buffer

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 17
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 17
  16 -> 8
  17 -> 18

Function: toStringSigned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: value < 0

  ID: 3
  Type: NodeType.RETURN
  Expression: string.concat(-,toString(SignedMath.abs(value)))

  ID: 4
  Type: NodeType.RETURN
  Expression: string.concat(,toString(SignedMath.abs(value)))

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: toHexString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: toHexString(uint256(uint160(addr)),ADDRESS_LENGTH)

Edges:
  0 -> 1

Function: toChecksumHexString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: buffer = bytes(toHexString(addr))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: hashValue = keccak256(uint256,uint256)(buffer + 0x22,40) >> 96

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 41

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i > 1

  ID: 10
  Type: NodeType.IF
  Expression: hashValue & 0xf > 7 && uint8(buffer[i]) > 96

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: buffer[i] ^= 0x20

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: hashValue >>= 4

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: -- i

  ID: 15
  Type: NodeType.RETURN
  Expression: string(buffer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 15
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 9

Function: equal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: bytes(a).length == bytes(b).length && keccak256(bytes)(bytes(a)) == keccak256(bytes)(bytes(b))

Edges:
  0 -> 1

Function: parseUint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,value) = tryParseUint(input,begin,end)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert StringsInvalidChar()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: tryParseUint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: end > bytes(input).length || begin > end

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tryParseUintUncheckedBounds(input,begin,end)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _tryParseUintUncheckedBounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: buffer = bytes(input)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: result = 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = begin

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < end

  ID: 7
  Type: NodeType.VARIABLE
  Expression: chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer,i)))

  ID: 8
  Type: NodeType.IF
  Expression: chr > 9

  ID: 9
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result *= 10

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: result += chr

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 14
  Type: NodeType.RETURN
  Expression: (true,result)

  ID: 15
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 14
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 6

Function: parseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,value) = tryParseInt(input,begin,end)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert StringsInvalidChar()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: tryParseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: end > bytes(input).length || begin > end

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tryParseIntUncheckedBounds(input,begin,end)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _tryParseIntUncheckedBounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: buffer = bytes(input)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: positiveSign = sign == bytes1(+)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: negativeSign = sign == bytes1(-)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: offset = (positiveSign || negativeSign).toUint()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (absSuccess,absValue) = tryParseUint(input,begin + offset,end)

  ID: 9
  Type: NodeType.IF
  Expression: absSuccess && absValue < ABS_MIN_INT256

  ID: 11
  Type: NodeType.IF
  Expression: absSuccess && negativeSign && absValue == ABS_MIN_INT256

  ID: 12
  Type: NodeType.RETURN
  Expression: (true,type()(int256).min)

  ID: 13
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 16
  Type: NodeType.IF
  Expression: begin == end

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sign = bytes1(0)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sign = bytes1(_unsafeReadBytesOffset(buffer,begin))

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.IF
  Expression: negativeSign

  ID: 21
  Type: NodeType.RETURN
  Expression: (true,- int256(absValue))

  ID: 22
  Type: NodeType.RETURN
  Expression: (true,int256(absValue))

  ID: 24
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 16
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 20
  9 -> 11
  11 -> 12
  11 -> 13
  16 -> 17
  16 -> 18
  17 -> 19
  18 -> 19
  19 -> 3
  20 -> 21
  20 -> 22

Function: parseHexUint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,value) = tryParseHexUint(input,begin,end)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert StringsInvalidChar()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: tryParseHexUint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: end > bytes(input).length || begin > end

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tryParseHexUintUncheckedBounds(input,begin,end)

  ID: 5
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _tryParseHexUintUncheckedBounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: buffer = bytes(input)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer,begin)) == bytes2(0x)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: offset = hasPrefix.toUint() * 2

  ID: 4
  Type: NodeType.VARIABLE
  Expression: result = 0

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = begin + offset

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < end

  ID: 9
  Type: NodeType.VARIABLE
  Expression: chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer,i)))

  ID: 10
  Type: NodeType.IF
  Expression: chr > 15

  ID: 11
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: result *= 16

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: result += chr

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 16
  Type: NodeType.RETURN
  Expression: (true,result)

  ID: 17
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 16
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 8

Function: parseAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,value) = tryParseAddress(input,begin,end)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert StringsInvalidAddressFormat()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: tryParseAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: end > bytes(input).length || begin > end

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input),begin)) == bytes2(0x)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: expectedLength = 40 + hasPrefix.toUint() * 2

  ID: 6
  Type: NodeType.IF
  Expression: end - begin == expectedLength

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (s,v) = _tryParseHexUintUncheckedBounds(input,begin,end)

  ID: 10
  Type: NodeType.RETURN
  Expression: (s,address(uint160(v)))

  ID: 11
  Type: NodeType.RETURN
  Expression: (false,address(0))

  ID: 13
  Type: NodeType.RETURN
  Expression: (success,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 11
  7 -> 8
  8 -> 9
  9 -> 10

Function: _tryParseChr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: value = uint8(chr)

  ID: 2
  Type: NodeType.IF
  Expression: value > 47 && value < 58

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: value -= 48

  ID: 4
  Type: NodeType.IF
  Expression: value > 96 && value < 103

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: value -= 87

  ID: 6
  Type: NodeType.IF
  Expression: value > 64 && value < 71

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: value -= 55

  ID: 8
  Type: NodeType.RETURN
  Expression: type()(uint8).max

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 11
  4 -> 5
  4 -> 6
  5 -> 10
  6 -> 7
  6 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: _unsafeReadBytesOffset
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: value = mload(uint256)(buffer + 0x20 + offset)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: HEX_DIGITS = 0123456789abcdef

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ADDRESS_LENGTH = 20

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ABS_MIN_INT256 = 2 ** 255

Edges:
  0 -> 1
  1 -> 2


Contract: IERC721A
==================================================


Contract: ERC721A__IERC721Receiver
==================================================


Contract: ERC721A
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = _startTokenId()

  ID: 4
  Type: NodeType.IF
  Expression: _sequentialUpTo() < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialUpToTooSmall().selector)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 1

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert URIQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == uint256(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == uint256(0)

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == uint256(0)

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == uint256(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == uint256(0)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = msgSenderMasked == ownerMasked | msgSenderMasked == approvedAddressValue

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _getApprovedSlotAndValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddressValue = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddressValue)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(from)

  ID: 3
  Type: NodeType.IF
  Expression: uint160(prevOwnershipPacked) != fromMasked

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddressValue,fromMasked,uint160(_msgSenderERC721A()))

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == uint256(0)

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == uint256(0)

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,fromMasked,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _batchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: byMasked = uint160(by)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(from)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 4
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: mayTransfer = _orERC721A(byMasked == uint256(0),byMasked == fromMasked) || isApprovedForAll(from,by)

  ID: 8
  Type: NodeType.IF
  Expression: tokenIds.length == uint256(0)

  ID: 9
  Type: NodeType.RETURN
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: end = _currentIndex

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 19
  Type: NodeType.VARIABLE
  Expression: tokenId = _mloadERC721A(ptr)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: miniBatchStart = tokenId

  ID: 21
  Type: NodeType.IF
  Expression: _orERC721A(tokenId < _startTokenId(),end <= tokenId)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: prevOwnershipPacked != 0

  ID: 25
  Type: NodeType.IF
  Expression: tokenId <= prevTokenId

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenIdsNotStrictlyAscending().selector)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 30
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: j = tokenId

  ID: 32
  Type: NodeType.IFLOOP
  Expression: (prevOwnershipPacked = _packedOwnerships[j]) == uint256(0)

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: -- j

  ID: 34
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_BURNED != 0

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: uint160(prevOwnershipPacked) != fromMasked

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 41
  Type: NodeType.IFLOOP
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 42
  Type: NodeType.VARIABLE
  Expression: 

  ID: 43
  Type: NodeType.VARIABLE
  Expression: 

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(uint160(fromMasked)),address(uint160(toMasked)),tokenId,1)

  ID: 46
  Type: NodeType.IF
  Expression: ! mayTransfer

  ID: 47
  Type: NodeType.IF
  Expression: byMasked != approvedAddressValue

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

  ID: 51
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 52
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 53
  Type: NodeType.ENDIF
  Expression: 

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,fromMasked,toMasked,tokenId)

  ID: 56
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 57
  Type: NodeType.IF
  Expression: _mloadERC721A(ptr += 0x20) != ++ tokenId

  ID: 58
  Type: NodeType.BREAK
  Expression: 

  ID: 59
  Type: NodeType.ENDIF
  Expression: 

  ID: 60
  Type: NodeType.IF
  Expression: ptr == ptrEnd

  ID: 61
  Type: NodeType.BREAK
  Expression: 

  ID: 62
  Type: NodeType.ENDIF
  Expression: 

  ID: 63
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[miniBatchStart] = _packOwnershipData(address(uint160(toMasked)),_nextExtraData(address(uint160(fromMasked)),address(uint160(toMasked)),prevOwnershipPacked))

  ID: 65
  Type: NodeType.VARIABLE
  Expression: miniBatchLength = tokenId - miniBatchStart

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[address(uint160(fromMasked))] -= miniBatchLength

  ID: 67
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[address(uint160(toMasked))] += miniBatchLength

  ID: 68
  Type: NodeType.IF
  Expression: tokenId != end

  ID: 69
  Type: NodeType.IF
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 70
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = prevOwnershipPacked

  ID: 71
  Type: NodeType.ENDIF
  Expression: 

  ID: 72
  Type: NodeType.ENDIF
  Expression: 

  ID: 73
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(uint160(fromMasked)),address(uint160(toMasked)),miniBatchStart,miniBatchLength)

  ID: 74
  Type: NodeType.EXPRESSION
  Expression: prevTokenId = tokenId - 1

  ID: 75
  Type: NodeType.ENDLOOP
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 75
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 31
  29 -> 32
  30 -> 34
  31 -> 29
  32 -> 33
  32 -> 30
  33 -> 32
  34 -> 35
  34 -> 36
  35 -> 36
  36 -> 37
  37 -> 38
  37 -> 39
  38 -> 39
  39 -> 40
  40 -> 42
  41 -> 42
  41 -> 63
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  46 -> 50
  47 -> 48
  47 -> 49
  48 -> 49
  49 -> 50
  50 -> 51
  51 -> 52
  52 -> 54
  52 -> 53
  53 -> 55
  54 -> 53
  55 -> 56
  56 -> 57
  57 -> 58
  57 -> 59
  58 -> 63
  59 -> 60
  60 -> 61
  60 -> 62
  61 -> 63
  62 -> 41
  63 -> 64
  64 -> 65
  65 -> 66
  66 -> 67
  67 -> 68
  68 -> 69
  68 -> 72
  69 -> 70
  69 -> 71
  70 -> 71
  71 -> 72
  72 -> 73
  73 -> 74
  74 -> 18

Function: _safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _batchTransferFrom(by,from,to,tokenIds)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 8
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 9
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,_mloadERC721A(ptr),_data)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ptr += 0x20

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  2 -> 13
  3 -> 8
  4 -> 13
  5 -> 6
  6 -> 7
  7 -> 3
  8 -> 9
  8 -> 4
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 8

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == uint256(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == uint256(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == uint256(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(prevOwnershipPacked)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(fromMasked))

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 7
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 8
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddressValue,fromMasked,uint160(_msgSenderERC721A()))

  ID: 9
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 22
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == uint256(0)

  ID: 23
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 24
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == uint256(0)

  ID: 25
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 13
  8 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  22 -> 29
  23 -> 24
  24 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32

Function: _batchBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenIds.length == uint256(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: end = _currentIndex

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 14
  Type: NodeType.VARIABLE
  Expression: tokenId = _mloadERC721A(ptr)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: miniBatchStart = tokenId

  ID: 16
  Type: NodeType.IF
  Expression: _orERC721A(tokenId < _startTokenId(),end <= tokenId)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: prevOwnershipPacked != 0

  ID: 20
  Type: NodeType.IF
  Expression: tokenId <= prevTokenId

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenIdsNotStrictlyAscending().selector)

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 25
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: j = tokenId

  ID: 27
  Type: NodeType.IFLOOP
  Expression: (prevOwnershipPacked = _packedOwnerships[j]) == uint256(0)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: -- j

  ID: 29
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_BURNED != 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.VARIABLE
  Expression: tokenOwner = address(uint160(prevOwnershipPacked))

  ID: 33
  Type: NodeType.IF
  Expression: tokenOwner != prevTokenOwner

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: prevTokenOwner = tokenOwner

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: mayBurn = _orERC721A(by == address(0),tokenOwner == by) || isApprovedForAll(tokenOwner,by)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 38
  Type: NodeType.IFLOOP
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 39
  Type: NodeType.VARIABLE
  Expression: 

  ID: 40
  Type: NodeType.VARIABLE
  Expression: 

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(tokenOwner,address(0),tokenId,1)

  ID: 43
  Type: NodeType.IF
  Expression: ! mayBurn

  ID: 44
  Type: NodeType.IF
  Expression: uint160(by) != approvedAddressValue

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 49
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 52
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,_BITMASK_ADDRESS & tokenOwner,0,tokenId)

  ID: 53
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 54
  Type: NodeType.IF
  Expression: _mloadERC721A(ptr += 0x20) != ++ tokenId

  ID: 55
  Type: NodeType.BREAK
  Expression: 

  ID: 56
  Type: NodeType.ENDIF
  Expression: 

  ID: 57
  Type: NodeType.IF
  Expression: ptr == ptrEnd

  ID: 58
  Type: NodeType.BREAK
  Expression: 

  ID: 59
  Type: NodeType.ENDIF
  Expression: 

  ID: 60
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[miniBatchStart] = _packOwnershipData(tokenOwner,_BITMASK_BURNED | _nextExtraData(tokenOwner,address(0),prevOwnershipPacked))

  ID: 62
  Type: NodeType.VARIABLE
  Expression: miniBatchLength = tokenId - miniBatchStart

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[tokenOwner] += (miniBatchLength << _BITPOS_NUMBER_BURNED) - miniBatchLength

  ID: 64
  Type: NodeType.IF
  Expression: tokenId != end

  ID: 65
  Type: NodeType.IF
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = prevOwnershipPacked

  ID: 67
  Type: NodeType.ENDIF
  Expression: 

  ID: 68
  Type: NodeType.ENDIF
  Expression: 

  ID: 69
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(tokenOwner,address(0),miniBatchStart,miniBatchLength)

  ID: 70
  Type: NodeType.EXPRESSION
  Expression: prevTokenId = tokenId - 1

  ID: 71
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 72
  Type: NodeType.EXPRESSION
  Expression: _burnCounter += tokenIds.length

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 14
  13 -> 14
  13 -> 71
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 23
  20 -> 21
  20 -> 22
  21 -> 22
  22 -> 23
  23 -> 26
  24 -> 27
  25 -> 29
  26 -> 24
  27 -> 28
  27 -> 25
  28 -> 27
  29 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  33 -> 36
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 39
  38 -> 39
  38 -> 60
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  43 -> 47
  44 -> 45
  44 -> 46
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 51
  49 -> 50
  50 -> 52
  51 -> 50
  52 -> 53
  53 -> 54
  54 -> 55
  54 -> 56
  55 -> 60
  56 -> 57
  57 -> 58
  57 -> 59
  58 -> 60
  59 -> 38
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64
  64 -> 65
  64 -> 68
  65 -> 66
  65 -> 67
  66 -> 67
  67 -> 68
  68 -> 69
  69 -> 70
  70 -> 13
  71 -> 72

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _mdataERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: start = a + 0x20

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: end = start + mload(uint256)(a) << 5

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (start,end)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _mloadERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = mload(uint256)(p)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _orERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = ! ! a | ! ! b

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_MINTED = 64

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_BURNED = 128

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_AUX = 192

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_START_TIMESTAMP = 160

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_BURNED = 1 << 224

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NEXT_INITIALIZED = 225

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_NEXT_INITIALIZED = 1 << 225

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_EXTRA_DATA = 232

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS = (1 << 160) - 1

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13


Contract: IERC721Receiver
==================================================


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENTERED = 2

Edges:
  0 -> 1


Contract: NFTAuctionV4
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: baseURI = _initBaseURI

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dumpWallet = _dumpWallet

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ERC721A(tokenName,tokenSymbol)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Ownable(msg.sender)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ReentrancyGuard()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 5
  5 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 1

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_exists(tokenId),ERC721Metadata: URI query for nonexistent token)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentBaseURI = _baseURI()

  ID: 4
  Type: NodeType.IF
  Expression: bytes(currentBaseURI).length > 0

  ID: 5
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(currentBaseURI,tokenURIs[tokenId],baseExtension))

  ID: 6
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  4 -> 5
  4 -> 6

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: baseURI

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == uint256(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == uint256(0)

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == uint256(0)

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == uint256(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == uint256(0)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = msgSenderMasked == ownerMasked | msgSenderMasked == approvedAddressValue

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _getApprovedSlotAndValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddressValue = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddressValue)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(from)

  ID: 3
  Type: NodeType.IF
  Expression: uint160(prevOwnershipPacked) != fromMasked

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddressValue,fromMasked,uint160(_msgSenderERC721A()))

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == uint256(0)

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == uint256(0)

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,fromMasked,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _batchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: byMasked = uint160(by)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(from)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 4
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: mayTransfer = _orERC721A(byMasked == uint256(0),byMasked == fromMasked) || isApprovedForAll(from,by)

  ID: 8
  Type: NodeType.IF
  Expression: tokenIds.length == uint256(0)

  ID: 9
  Type: NodeType.RETURN
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: end = _currentIndex

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 19
  Type: NodeType.VARIABLE
  Expression: tokenId = _mloadERC721A(ptr)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: miniBatchStart = tokenId

  ID: 21
  Type: NodeType.IF
  Expression: _orERC721A(tokenId < _startTokenId(),end <= tokenId)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: prevOwnershipPacked != 0

  ID: 25
  Type: NodeType.IF
  Expression: tokenId <= prevTokenId

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenIdsNotStrictlyAscending().selector)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 30
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: j = tokenId

  ID: 32
  Type: NodeType.IFLOOP
  Expression: (prevOwnershipPacked = _packedOwnerships[j]) == uint256(0)

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: -- j

  ID: 34
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_BURNED != 0

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: uint160(prevOwnershipPacked) != fromMasked

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 41
  Type: NodeType.IFLOOP
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 42
  Type: NodeType.VARIABLE
  Expression: 

  ID: 43
  Type: NodeType.VARIABLE
  Expression: 

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(uint160(fromMasked)),address(uint160(toMasked)),tokenId,1)

  ID: 46
  Type: NodeType.IF
  Expression: ! mayTransfer

  ID: 47
  Type: NodeType.IF
  Expression: byMasked != approvedAddressValue

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

  ID: 51
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 52
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 53
  Type: NodeType.ENDIF
  Expression: 

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,fromMasked,toMasked,tokenId)

  ID: 56
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 57
  Type: NodeType.IF
  Expression: _mloadERC721A(ptr += 0x20) != ++ tokenId

  ID: 58
  Type: NodeType.BREAK
  Expression: 

  ID: 59
  Type: NodeType.ENDIF
  Expression: 

  ID: 60
  Type: NodeType.IF
  Expression: ptr == ptrEnd

  ID: 61
  Type: NodeType.BREAK
  Expression: 

  ID: 62
  Type: NodeType.ENDIF
  Expression: 

  ID: 63
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[miniBatchStart] = _packOwnershipData(address(uint160(toMasked)),_nextExtraData(address(uint160(fromMasked)),address(uint160(toMasked)),prevOwnershipPacked))

  ID: 65
  Type: NodeType.VARIABLE
  Expression: miniBatchLength = tokenId - miniBatchStart

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[address(uint160(fromMasked))] -= miniBatchLength

  ID: 67
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[address(uint160(toMasked))] += miniBatchLength

  ID: 68
  Type: NodeType.IF
  Expression: tokenId != end

  ID: 69
  Type: NodeType.IF
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 70
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = prevOwnershipPacked

  ID: 71
  Type: NodeType.ENDIF
  Expression: 

  ID: 72
  Type: NodeType.ENDIF
  Expression: 

  ID: 73
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(uint160(fromMasked)),address(uint160(toMasked)),miniBatchStart,miniBatchLength)

  ID: 74
  Type: NodeType.EXPRESSION
  Expression: prevTokenId = tokenId - 1

  ID: 75
  Type: NodeType.ENDLOOP
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 75
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 31
  29 -> 32
  30 -> 34
  31 -> 29
  32 -> 33
  32 -> 30
  33 -> 32
  34 -> 35
  34 -> 36
  35 -> 36
  36 -> 37
  37 -> 38
  37 -> 39
  38 -> 39
  39 -> 40
  40 -> 42
  41 -> 42
  41 -> 63
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  46 -> 50
  47 -> 48
  47 -> 49
  48 -> 49
  49 -> 50
  50 -> 51
  51 -> 52
  52 -> 54
  52 -> 53
  53 -> 55
  54 -> 53
  55 -> 56
  56 -> 57
  57 -> 58
  57 -> 59
  58 -> 63
  59 -> 60
  60 -> 61
  60 -> 62
  61 -> 63
  62 -> 41
  63 -> 64
  64 -> 65
  65 -> 66
  66 -> 67
  67 -> 68
  68 -> 69
  68 -> 72
  69 -> 70
  69 -> 71
  70 -> 71
  71 -> 72
  72 -> 73
  73 -> 74
  74 -> 18

Function: _safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _batchTransferFrom(by,from,to,tokenIds)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 8
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 9
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,_mloadERC721A(ptr),_data)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ptr += 0x20

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  2 -> 13
  3 -> 8
  4 -> 13
  5 -> 6
  6 -> 7
  7 -> 3
  8 -> 9
  8 -> 4
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 8

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == uint256(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == uint256(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == uint256(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint160(to)

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == uint256(0)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: fromMasked = uint160(prevOwnershipPacked)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(fromMasked))

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 7
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 8
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddressValue,fromMasked,uint160(_msgSenderERC721A()))

  ID: 9
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 22
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == uint256(0)

  ID: 23
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 24
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == uint256(0)

  ID: 25
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 13
  8 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  22 -> 29
  23 -> 24
  24 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32

Function: _batchBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenIds.length == uint256(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: end = _currentIndex

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (ptr,ptrEnd) = _mdataERC721A(tokenIds)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: ptr != ptrEnd

  ID: 14
  Type: NodeType.VARIABLE
  Expression: tokenId = _mloadERC721A(ptr)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: miniBatchStart = tokenId

  ID: 16
  Type: NodeType.IF
  Expression: _orERC721A(tokenId < _startTokenId(),end <= tokenId)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: prevOwnershipPacked != 0

  ID: 20
  Type: NodeType.IF
  Expression: tokenId <= prevTokenId

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenIdsNotStrictlyAscending().selector)

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 25
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: j = tokenId

  ID: 27
  Type: NodeType.IFLOOP
  Expression: (prevOwnershipPacked = _packedOwnerships[j]) == uint256(0)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: -- j

  ID: 29
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_BURNED != 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.VARIABLE
  Expression: tokenOwner = address(uint160(prevOwnershipPacked))

  ID: 33
  Type: NodeType.IF
  Expression: tokenOwner != prevTokenOwner

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: prevTokenOwner = tokenOwner

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: mayBurn = _orERC721A(by == address(0),tokenOwner == by) || isApprovedForAll(tokenOwner,by)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 38
  Type: NodeType.IFLOOP
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 39
  Type: NodeType.VARIABLE
  Expression: 

  ID: 40
  Type: NodeType.VARIABLE
  Expression: 

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddressValue) = _getApprovedSlotAndValue(tokenId)

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(tokenOwner,address(0),tokenId,1)

  ID: 43
  Type: NodeType.IF
  Expression: ! mayBurn

  ID: 44
  Type: NodeType.IF
  Expression: uint160(by) != approvedAddressValue

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 49
  Type: NodeType.IF
  Expression: approvedAddressValue

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 52
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,_BITMASK_ADDRESS & tokenOwner,0,tokenId)

  ID: 53
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 54
  Type: NodeType.IF
  Expression: _mloadERC721A(ptr += 0x20) != ++ tokenId

  ID: 55
  Type: NodeType.BREAK
  Expression: 

  ID: 56
  Type: NodeType.ENDIF
  Expression: 

  ID: 57
  Type: NodeType.IF
  Expression: ptr == ptrEnd

  ID: 58
  Type: NodeType.BREAK
  Expression: 

  ID: 59
  Type: NodeType.ENDIF
  Expression: 

  ID: 60
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[miniBatchStart] = _packOwnershipData(tokenOwner,_BITMASK_BURNED | _nextExtraData(tokenOwner,address(0),prevOwnershipPacked))

  ID: 62
  Type: NodeType.VARIABLE
  Expression: miniBatchLength = tokenId - miniBatchStart

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[tokenOwner] += (miniBatchLength << _BITPOS_NUMBER_BURNED) - miniBatchLength

  ID: 64
  Type: NodeType.IF
  Expression: tokenId != end

  ID: 65
  Type: NodeType.IF
  Expression: _packedOwnerships[tokenId] == uint256(0)

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = prevOwnershipPacked

  ID: 67
  Type: NodeType.ENDIF
  Expression: 

  ID: 68
  Type: NodeType.ENDIF
  Expression: 

  ID: 69
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(tokenOwner,address(0),miniBatchStart,miniBatchLength)

  ID: 70
  Type: NodeType.EXPRESSION
  Expression: prevTokenId = tokenId - 1

  ID: 71
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 72
  Type: NodeType.EXPRESSION
  Expression: _burnCounter += tokenIds.length

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 14
  13 -> 14
  13 -> 71
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 23
  20 -> 21
  20 -> 22
  21 -> 22
  22 -> 23
  23 -> 26
  24 -> 27
  25 -> 29
  26 -> 24
  27 -> 28
  27 -> 25
  28 -> 27
  29 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  33 -> 36
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 39
  38 -> 39
  38 -> 60
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  43 -> 47
  44 -> 45
  44 -> 46
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 51
  49 -> 50
  50 -> 52
  51 -> 50
  52 -> 53
  53 -> 54
  54 -> 55
  54 -> 56
  55 -> 60
  56 -> 57
  57 -> 58
  57 -> 59
  58 -> 60
  59 -> 38
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64
  64 -> 65
  64 -> 68
  65 -> 66
  65 -> 67
  66 -> 67
  67 -> 68
  68 -> 69
  69 -> 70
  70 -> 13
  71 -> 72

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == uint256(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _mdataERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: start = a + 0x20

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: end = start + mload(uint256)(a) << 5

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (start,end)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _mloadERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = mload(uint256)(p)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _orERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = ! ! a | ! ! b

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: createAuction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,nft does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(duration > 0,Duration must be greater than 0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,Token ID must be less than or equal to the next token ID)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(basePrice > 0,Base price must be greater than 0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(bytes(uri).length > 0,Token URI must be greater than 0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: tokenURIs[tokenId] = uri

  ID: 7
  Type: NodeType.VARIABLE
  Expression: newAuction = Auction({tokenId:tokenId,startTime:0,duration:duration,basePrice:basePrice,highestBid:0,highestBidder:address(0),previousBidder:address(0),bidders:new address[](0),minimumBidIncrement:_minimumBidIncrement,status:status.idle})

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId] = newAuction

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: AuctionCreated(tokenId,duration,basePrice)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 10
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  10 -> 1

Function: bid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,nft does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].tokenId == tokenId,auction not listed yet)

  ID: 3
  Type: NodeType.IF
  Expression: auctions[tokenId].status == status.live

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].startTime + auctions[tokenId].duration > block.timestamp,Auction has ended)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: auctions[tokenId].status == status.idle

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value >= auctions[tokenId].basePrice,invalid ether sent)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].startTime = block.timestamp

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].status = status.live

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value >= auctions[tokenId].highestBid + auctions[tokenId].minimumBidIncrement,invalid ether sent)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: address(auctions[tokenId].previousBidder).transfer(auctions[tokenId].highestBid)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: timeLeft = (auctions[tokenId].startTime + auctions[tokenId].duration) - block.timestamp

  ID: 13
  Type: NodeType.IF
  Expression: timeLeft <= 300

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].duration += 300 - timeLeft

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: bids[tokenId][msg.sender].push(msg.value)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].highestBid = msg.value

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].highestBidder = msg.sender

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].previousBidder = msg.sender

  ID: 21
  Type: NodeType.IF
  Expression: bids[tokenId][msg.sender].length == 1

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].bidders.push(msg.sender)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: BidPlaced(tokenId,msg.sender,msg.value)

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 25
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 16
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  25 -> 1

Function: endAuction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,nft does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].tokenId == tokenId,auction not listed yet)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].status == status.live || auctions[tokenId].status == status.idle,Auction is not live)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].status = status.Ended

  ID: 5
  Type: NodeType.IF
  Expression: ! readyToMint

  ID: 6
  Type: NodeType.IF
  Expression: checkIfAllAuctionsAreEnded()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(transferNFTs(),Failed to transfer NFTs)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: AuctionEnded(tokenId)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: cancelAuction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,nft does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].tokenId == tokenId,auction not listed yet)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].status == status.live || auctions[tokenId].status == status.idle,Auction is not live or already ended)

  ID: 4
  Type: NodeType.IF
  Expression: auctions[tokenId].status == status.live

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: address(auctions[tokenId].highestBidder).transfer(auctions[tokenId].highestBid)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].highestBidder = dumpWallet

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].highestBid = 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].status = status.cancelled

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: AuctionCancelled(tokenId)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: transferNFTs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: nextTokenId > 11

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = nextTokenId - 12

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < nextTokenId - 1

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: safeTransferFrom(address(this),auctions[i].highestBidder,i)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: readyToMint = true

  ID: 10
  Type: NodeType.RETURN
  Expression: true

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 1

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < 11

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: safeTransferFrom(address(this),auctions[i_scope_0].highestBidder,i_scope_0)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: readyToMint = true

  ID: 19
  Type: NodeType.RETURN
  Expression: true

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 22
  Type: NodeType.IF
  Expression: (auctions[i].highestBidder == dumpWallet)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: auctions[i].status = status.cancelled

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: auctions[i].status = status.completed

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.IF
  Expression: (auctions[i_scope_0].highestBidder == dumpWallet)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: auctions[i_scope_0].status = status.cancelled

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: auctions[i_scope_0].status = status.completed

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 21
  1 -> 4
  1 -> 13
  2 -> 5
  3 -> 9
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 22
  8 -> 5
  9 -> 10
  11 -> 14
  12 -> 18
  13 -> 11
  14 -> 15
  14 -> 12
  15 -> 26
  17 -> 14
  18 -> 19
  21 -> 1
  22 -> 23
  22 -> 24
  23 -> 25
  24 -> 25
  25 -> 8
  26 -> 27
  26 -> 28
  27 -> 29
  28 -> 29
  29 -> 17

Function: checkIfAllAuctionsAreEnded
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: nextTokenId > 11

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = nextTokenId - 12

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < nextTokenId - 1

  ID: 6
  Type: NodeType.IF
  Expression: auctions[i].status != status.Ended || auctions[i].status != status.cancelled

  ID: 7
  Type: NodeType.RETURN
  Expression: false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 1

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < 11

  ID: 14
  Type: NodeType.IF
  Expression: auctions[i_scope_0].status != status.Ended || auctions[i_scope_0].status != status.cancelled

  ID: 15
  Type: NodeType.RETURN
  Expression: false

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  1 -> 12
  2 -> 5
  3 -> 18
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 5
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 14
  13 -> 11
  14 -> 15
  14 -> 16
  16 -> 17
  17 -> 13
  18 -> 19

Function: _setTokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < quantity

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tokenURIs[nextTokenId] = blank

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: nextTokenId ++

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 3
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 7
  7 -> 4

Function: ownerMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(readyToMint,Not ready to mint,auctions in progress)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(nextTokenId + quantity <= 11,Max supply reached)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _safeMint(address(this),quantity)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _setTokenURI(quantity)

  ID: 5
  Type: NodeType.IF
  Expression: nextTokenId == 12

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: readyToMint = false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  8 -> 1

Function: multiTokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: uris = new string[](tokenIds.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < tokenIds.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_exists(tokenIds[i]),ERC721Metadata: URI query for nonexistent token)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: currentBaseURI = _baseURI()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: uris

  ID: 11
  Type: NodeType.IF
  Expression: bytes(currentBaseURI).length > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: uris[i] = string(abi.encodePacked(currentBaseURI,tokenURIs[tokenIds[i]],baseExtension))

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: uris[i] = 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 11
  9 -> 5
  11 -> 12
  11 -> 13
  12 -> 14
  13 -> 14
  14 -> 9

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(readyToMint,satisfy all auctions before withdrawing)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: balance = address(this).balance

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(balance > 0,No ETH to withdraw)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (success,None) = address(msg.sender).call{value: balance}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Transfer failed)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 1

Function: getUpcomingAuctions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < nextTokenId

  ID: 6
  Type: NodeType.IF
  Expression: auctions[i].tokenId != i

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: upcomingAuctions = new NFTAuctionV4.UpcomingAuctionPayload[](count)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: index = 0

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 1

  ID: 15
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < nextTokenId

  ID: 16
  Type: NodeType.IF
  Expression: auctions[i_scope_0].tokenId != i_scope_0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: upcomingAuctions[index] = UpcomingAuctionPayload({tokenId:i_scope_0,tokenURI:tokenURIs[i_scope_0]})

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: index ++

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 21
  Type: NodeType.RETURN
  Expression: upcomingAuctions

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5
  10 -> 11
  11 -> 14
  12 -> 15
  13 -> 21
  14 -> 12
  15 -> 16
  15 -> 13
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 15

Function: getLiveAuctions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i <= nextTokenId

  ID: 6
  Type: NodeType.IF
  Expression: auctions[i].status == status.live || auctions[i].status == status.idle

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: liveAuctions = new NFTAuctionV4.AuctionPayload[](count)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: index = 0

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 1

  ID: 15
  Type: NodeType.IFLOOP
  Expression: i_scope_0 <= nextTokenId

  ID: 16
  Type: NodeType.IF
  Expression: auctions[i_scope_0].status == status.live || auctions[i_scope_0].status == status.idle

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: liveAuctions[index] = AuctionPayload({tokenId:auctions[i_scope_0].tokenId,startTime:auctions[i_scope_0].startTime,duration:auctions[i_scope_0].duration,basePrice:auctions[i_scope_0].basePrice,highestBid:auctions[i_scope_0].highestBid,highestBidder:auctions[i_scope_0].highestBidder,previousBidder:auctions[i_scope_0].previousBidder,status:auctions[i_scope_0].status,tokenURI:tokenURIs[auctions[i_scope_0].tokenId],minimumBidIncrement:auctions[i_scope_0].minimumBidIncrement,bids:getBids(auctions[i_scope_0].tokenId)})

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: index ++

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 21
  Type: NodeType.RETURN
  Expression: liveAuctions

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5
  10 -> 11
  11 -> 14
  12 -> 15
  13 -> 21
  14 -> 12
  15 -> 16
  15 -> 13
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 15

Function: getBids
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,Token ID does not exist)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: auction = auctions[tokenId]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: bidders = auction.bidders

  ID: 4
  Type: NodeType.VARIABLE
  Expression: totalBids = 0

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < bidders.length

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: totalBids += bids[tokenId][bidders[i]].length

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: allBids = new NFTAuctionV4.Bid[](totalBids)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: currentIndex = 0

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < bidders.length

  ID: 17
  Type: NodeType.VARIABLE
  Expression: bidderBids = bids[tokenId][bidders[i_scope_0]]

  ID: 18
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 21
  Type: NodeType.IFLOOP
  Expression: j < bidderBids.length

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: allBids[currentIndex] = Bid({bidder:bidders[i_scope_0],amount:bidderBids[j]})

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: currentIndex ++

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 26
  Type: NodeType.RETURN
  Expression: allBids

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 11
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 8
  11 -> 12
  12 -> 15
  13 -> 16
  14 -> 26
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 20
  18 -> 21
  19 -> 25
  20 -> 18
  21 -> 22
  21 -> 19
  22 -> 23
  23 -> 24
  24 -> 21
  25 -> 16

Function: getEndedAuctions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i <= nextTokenId

  ID: 6
  Type: NodeType.IF
  Expression: auctions[i].status == status.Ended || auctions[i].status == status.completed || auctions[i].status == status.cancelled

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: endedAuctions = new NFTAuctionV4.AuctionPayload[](count)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: index = 0

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 1

  ID: 15
  Type: NodeType.IFLOOP
  Expression: i_scope_0 <= nextTokenId

  ID: 16
  Type: NodeType.IF
  Expression: auctions[i_scope_0].status == status.Ended || auctions[i_scope_0].status == status.completed || auctions[i_scope_0].status == status.cancelled

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: endedAuctions[index] = AuctionPayload({tokenId:auctions[i_scope_0].tokenId,startTime:auctions[i_scope_0].startTime,duration:auctions[i_scope_0].duration,basePrice:auctions[i_scope_0].basePrice,highestBid:auctions[i_scope_0].highestBid,highestBidder:auctions[i_scope_0].highestBidder,previousBidder:auctions[i_scope_0].previousBidder,status:auctions[i_scope_0].status,tokenURI:tokenURIs[auctions[i_scope_0].tokenId],minimumBidIncrement:auctions[i_scope_0].minimumBidIncrement,bids:getBids(auctions[i_scope_0].tokenId)})

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: index ++

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 21
  Type: NodeType.RETURN
  Expression: endedAuctions

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5
  10 -> 11
  11 -> 14
  12 -> 15
  13 -> 21
  14 -> 12
  15 -> 16
  15 -> 13
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 15

Function: getAuctionForTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,Token ID does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].tokenId == tokenId,auction not listed yet)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: auction = AuctionPayload({tokenId:auctions[tokenId].tokenId,startTime:auctions[tokenId].startTime,duration:auctions[tokenId].duration,basePrice:auctions[tokenId].basePrice,highestBid:auctions[tokenId].highestBid,highestBidder:auctions[tokenId].highestBidder,previousBidder:auctions[tokenId].previousBidder,status:auctions[tokenId].status,tokenURI:tokenURIs[auctions[tokenId].tokenId],minimumBidIncrement:auctions[tokenId].minimumBidIncrement,bids:getBids(auctions[tokenId].tokenId)})

  ID: 4
  Type: NodeType.RETURN
  Expression: auction

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setMinimumBidIncrement
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenId <= nextTokenId,Token ID does not exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(auctions[tokenId].status == status.live,Auction is not live)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: auctions[tokenId].minimumBidIncrement = _minimumBidIncrement

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: updateBaseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: baseURI = _newBaseURI

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: onERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ERC721Received(operator,from,tokenId)

  ID: 2
  Type: NodeType.RETURN
  Expression: this.onERC721Received.selector

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: nextTokenId = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: baseExtension = .json

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: readyToMint = true

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_SUPPLY = 10000

Edges:


