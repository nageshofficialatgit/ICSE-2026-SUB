Contract: ERC721
==================================================


Contract: CollectibleToken
==================================================

Function: CollectibleToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ceoAddress = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: cooAddress = msg.sender

Edges:
  0 -> 1
  1 -> 2

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_owns(msg.sender,_tokenId))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToApproved[_tokenId] = _to

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_to,_tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ownershipTokenCount[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: createPromoCollectible
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(collectibleIndexToOwner[tokenId] == address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(promoCreatedCount < PROMO_CREATION_LIMIT)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: collectibleOwner = _owner

  ID: 4
  Type: NodeType.IF
  Expression: collectibleOwner == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: collectibleOwner = cooAddress

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: _price <= 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _price = startingPrice

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: promoCreatedCount ++

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _createCollectible(tokenId,_price)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _transfer(address(0),collectibleOwner,tokenId)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyCOO()

Edges:
  0 -> 13
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  13 -> 1

Function: getCollectible
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tokenId = _tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: sellingPrice = collectibleIndexToPrice[_tokenId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = collectibleIndexToOwner[_tokenId]

  ID: 4
  Type: NodeType.IF
  Expression: sellingPrice == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sellingPrice = startingPrice

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: sellingPrice < firstStepLimit

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: nextSellingPrice = SafeMath.div(SafeMath.mul(sellingPrice,200),94)

  ID: 9
  Type: NodeType.IF
  Expression: sellingPrice < secondStepLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: nextSellingPrice = SafeMath.div(SafeMath.mul(sellingPrice,120),94)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: nextSellingPrice = SafeMath.div(SafeMath.mul(sellingPrice,115),94)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: (tokenId,sellingPrice,owner,nextSellingPrice)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 13
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14

Function: implementsERC721
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: NAME

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = collectibleIndexToOwner[_tokenId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(owner != address(0))

  ID: 3
  Type: NodeType.RETURN
  Expression: owner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: payout
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _payout(_to)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCLevel()

Edges:
  0 -> 2
  2 -> 1

Function: purchase
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = collectibleIndexToOwner[_tokenId]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: newOwner = msg.sender

  ID: 3
  Type: NodeType.VARIABLE
  Expression: sellingPrice = collectibleIndexToPrice[_tokenId]

  ID: 4
  Type: NodeType.IF
  Expression: sellingPrice == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sellingPrice = startingPrice

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _createCollectible(_tokenId,sellingPrice)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addressNotNull(newOwner))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value >= sellingPrice)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice,94),100))

  ID: 11
  Type: NodeType.VARIABLE
  Expression: purchaseExcess = SafeMath.sub(msg.value,sellingPrice)

  ID: 12
  Type: NodeType.IF
  Expression: sellingPrice < firstStepLimit

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice,200),94)

  ID: 14
  Type: NodeType.IF
  Expression: sellingPrice < secondStepLimit

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice,120),94)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice,115),94)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _transfer(oldOwner,newOwner,_tokenId)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: TokenSold(_tokenId,sellingPrice,collectibleIndexToPrice[_tokenId],oldOwner,newOwner)

  ID: 21
  Type: NodeType.IF
  Expression: oldOwner != address(this) && oldOwner != address(0)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: oldOwner.transfer(payment)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(purchaseExcess)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 18
  14 -> 15
  14 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24

Function: priceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: price = collectibleIndexToPrice[_tokenId]

  ID: 2
  Type: NodeType.IF
  Expression: price == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: price = startingPrice

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: price

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: setCEO
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_newCEO != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ceoAddress = _newCEO

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyCEO()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setCOO
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_newCOO != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: cooAddress = _newCOO

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyCEO()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: SYMBOL

Edges:
  0 -> 1

Function: takeOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: newOwner = msg.sender

  ID: 2
  Type: NodeType.VARIABLE
  Expression: oldOwner = collectibleIndexToOwner[_tokenId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addressNotNull(newOwner))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_approved(newOwner,_tokenId))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _transfer(oldOwner,newOwner,_tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_owns(msg.sender,_tokenId))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addressNotNull(_to))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(msg.sender,_to,_tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_owns(_from,_tokenId))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_approved(_to,_tokenId))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addressNotNull(_to))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transfer(_from,_to,_tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _addressNotNull
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _to != address(0)

Edges:
  0 -> 1

Function: _approved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: collectibleIndexToApproved[_tokenId] == _to

Edges:
  0 -> 1

Function: _createCollectible
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToPrice[tokenId] = _price

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply ++

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Birth(tokenId,_price,totalSupply)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _owns
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: claimant == collectibleIndexToOwner[_tokenId]

Edges:
  0 -> 1

Function: _payout
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _to == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ceoAddress.transfer(this.balance)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _to.transfer(this.balance)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownershipTokenCount[_to] ++

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: collectibleIndexToOwner[_tokenId] = _to

  ID: 3
  Type: NodeType.IF
  Expression: _from != address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownershipTokenCount[_from] --

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: delete collectibleIndexToApproved[_tokenId]

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 6
  6 -> 7

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: startingPrice = 1000000000000000

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: firstStepLimit = 53613000000000000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: secondStepLimit = 564957000000000000

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NAME = crypto-youCollect

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SYMBOL = CYC

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PROMO_CREATION_LIMIT = 5000

Edges:
  0 -> 1
  1 -> 2


Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c / a == b)

  ID: 6
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 2
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


