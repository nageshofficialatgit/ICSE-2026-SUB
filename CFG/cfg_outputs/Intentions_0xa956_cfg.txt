Contract: AGWP
==================================================


Contract: AbstractTokenProxy_int
==================================================


Contract: AbstractBaseR_int
==================================================


Contract: AbstractETHRegController_int
==================================================


Contract: AbstractTM_ENS_int
==================================================


Contract: AbstractTM_Resolver_int
==================================================


Contract: Abs_AuctionRegistrar_int
==================================================


Contract: AbstractRR_int
==================================================


Contract: AbstractGWF_int
==================================================


Contract: Intentions
==================================================

Function: getMasterCopy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: masterCopy

Edges:
  0 -> 1

Function: getGWF
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: GWF

Edges:
  0 -> 1

Function: getRegController
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractETHRegController_int(getGWF().controllerContract())

Edges:
  0 -> 1

Function: getAuctionMaster
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: Abs_AuctionRegistrar_int(getGWF().auctionContract())

Edges:
  0 -> 1

Function: hashOfGWP
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: bytes32(_gwp.getTransactionRecord(uint256(uint160(address(getGWF())))))

Edges:
  0 -> 1

Function: getGWP
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: gwp = getGWF().getGWProxy(_dhash)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(gwp != address(0x0) && isContract(gwp),GW)

  ID: 3
  Type: NodeType.RETURN
  Expression: AGWP(gwp)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getPTC
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractTokenProxy_int(getGWF().getProxyToken(_dhash))

Edges:
  0 -> 1

Function: getName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getPTC(_dhash).name()

Edges:
  0 -> 1

Function: getNodeHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(abi.encodePacked(AbstractBaseR_int(getGWF().base()).baseNode(),keccak256(bytes)(abi.encodePacked(dn))))

  ID: 2
  Type: NodeType.RETURN
  Expression: hash

Edges:
  0 -> 1

Function: saveLetterOfIntent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(target) != address(msg.sender),LoI0!)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(target) != k_add00 && isContract(address(target)),LoI1!)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(msg.sender) != k_add00 && isContract(address(msg.sender)),LoI2!)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: __gwp = AGWP(target)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: __gwpInv = AGWP(msg.sender)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(__gwp) != k_add00 && address(__gwp.getGWF()) == address(getGWF()),LoI3!)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(__gwpInv) != k_add00 && address(__gwpInv.getGWF()) == address(getGWF()),LoI4!)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (LOItargetAddr,tNb) = IntentTransactionRecord(AGWP(address(msg.sender)))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tNb > 0 && isContract(LOItargetAddr) && target == LOItargetAddr,LoI5!)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: hash = hashOfGWP(__gwp)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(hash != 0x0,LoI6!)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(getGWP(hash)) == address(target),LoI16!)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: __ptc = getPTC(hash)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(__ptc) != k_add00,LoI7!)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(nbOfShares > 0 && nbOfShares <= __ptc.balanceOf(target),LoI8!)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(getGWF().getOwner(hash) == target,LoI9!)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: hashInv = hashOfGWP(__gwpInv)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(hashInv != 0x0,LoI10!)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(getGWF().getOwner(hashInv) == address(msg.sender),LoI11!)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(getGWP(hashInv)) == msg.sender,LoI17!)

  ID: 23
  Type: NodeType.VARIABLE
  Expression: ctrl = getRegController()

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ctrl.rentPrice(abcdef,uint256(86400 * 365)) <= msg.value,LoI12!)

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: balances[address(msg.sender)] = address(msg.sender).balance

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: intended[msg.sender][target] = nbOfShares

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: investors.push(address(msg.sender))

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: intentInv[target].push(address(msg.sender))

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: LetterOfIntent(msg.sender,target,nbOfShares)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(target))

Edges:
  0 -> 30
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  30 -> 31
  31 -> 1

Function: storeInvestment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(_gwp) != k_add00 && isContract(address(_gwp)) && address(AGWP(_gwp).getGWF()) == address(getGWF()),* not an UngravelGroup!)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_nbOfShares > 0,* not an UngravelGroup2!)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_nbOfShares > 0 && _pricePaidEth > 0,* not an UngravelGroup2b!)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_nbOfShares > 0 && _pricePaidEth > 0 && (uint256(_salt) != 0),* not an UngravelGroup2c!)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: acquired[msg.sender][_gwp] = _nbOfShares

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: invested[msg.sender][_gwp] = _pricePaidEth

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sold[_gwp][msg.sender] = _nbOfShares

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: funded[_gwp][msg.sender] = _pricePaidEth

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: spice[msg.sender][_gwp] = _salt

  ID: 10
  Type: NodeType.VARIABLE
  Expression: cap = uint256(uint256(1200000 * 100000) / _nbOfShares) * uint256(_pricePaidEth)

  ID: 11
  Type: NodeType.IF
  Expression: cap > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: UNG_Mcap = UNG_Mcap - marketCap[_gwp]

  ID: 13
  Type: NodeType.IF
  Expression: cap > marketCap[_gwp]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: marketCap[_gwp] = cap

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UNG_Mcap = UNG_Mcap + cap

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: StoreInvestment(msg.sender,_gwp,_nbOfShares,_pricePaidEth)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: StoreFunding(_gwp,msg.sender,_nbOfShares,_pricePaidEth)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_gwp))

Edges:
  0 -> 20
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 17
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  20 -> 21
  21 -> 22
  22 -> 1

Function: getSpice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: spice[msg.sender][_gwp]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_gwp))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: getMarketCap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(marketCap[msg.sender] / 1000)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

Edges:
  0 -> 2
  2 -> 1

Function: mCap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(marketCap[_gwp] / 1000)

Edges:
  0 -> 1

Function: getUNGmarketCap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: UNG_Mcap <= 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: uint256(UNG_Mcap / 1000)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: didInvestTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (acquired[msg.sender][_gwp] > 0) && (invested[msg.sender][_gwp] > 0) && (getSpice(_gwp) != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_gwp))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: didGetFundingFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (sold[_gwp][_inv] > 0) && (funded[_gwp][_inv] > 0) && (spice[_inv][_gwp] != 0x0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_gwp))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_inv))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: getFundingReport
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(_gwp) != k_add00 && isContract(address(_gwp)) && address(AGWP(_gwp).getGWF()) == address(getGWF()),* no UG)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: h = hashOfGWP(AGWP(_gwp))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(h != 0x0 && getGWF().getOwner(h) == address(_gwp),* no UG2)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(getGWP(h)) == address(_gwp),* no UG3)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(_inv) != k_add00 && isContract(address(_inv)) && address(AGWP(_inv).getGWF()) == address(getGWF()),* no UG4)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: h = hashOfGWP(AGWP(_inv))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(h != 0x0 && getGWF().getOwner(h) == address(_inv),* no UG5)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(getGWP(h)) == address(_inv),* no UG6)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: cap = uint256(marketCap[address(_gwp)] / 1000)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: loi = uint256(getIntendedLOIShares(_gwp,_inv))

  ID: 11
  Type: NodeType.VARIABLE
  Expression: acq = uint256(acquired[_inv][_gwp])

  ID: 12
  Type: NodeType.VARIABLE
  Expression: prc = uint256(invested[_inv][_gwp])

  ID: 13
  Type: NodeType.VARIABLE
  Expression: hsh = bytes32(spice[_inv][_gwp])

  ID: 14
  Type: NodeType.RETURN
  Expression: (cap,hsh,loi,acq,prc,uint256(getUNGmarketCap()))

  ID: 15
  Type: NodeType.RETURN
  Expression: (mCapGWP,dhash,loiShares,shares,price,mcap)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: LoI_arrived_for_GWP
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (intentInv[target].length > 0) && (getIntendedNbOfShares(target) > 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(target))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: hasTransactions(AGWP(target))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: getIntendedNbOfShares
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: j = investors.length

  ID: 2
  Type: NodeType.IF
  Expression: j == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < j

  ID: 8
  Type: NodeType.IF
  Expression: intended[investors[i]][target] > 0

  ID: 9
  Type: NodeType.RETURN
  Expression: intended[investors[i]][target]

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 7
  12 -> 13

Function: getGroupLOIinvestors
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: intentInv[target]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(target))

Edges:
  0 -> 2
  2 -> 1

Function: getIntendedLOIShares
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: j = intentInv[tg].length

  ID: 2
  Type: NodeType.IF
  Expression: j == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < j

  ID: 9
  Type: NodeType.VARIABLE
  Expression: invest = intentInv[tg][i]

  ID: 10
  Type: NodeType.IF
  Expression: invest == inv

  ID: 11
  Type: NodeType.RETURN
  Expression: intended[invest][tg]

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(tg))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(inv))

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 8
  15 -> 16
  16 -> 1

Function: intendedLOIShares
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: j = intentInv[msg.sender].length

  ID: 2
  Type: NodeType.IF
  Expression: j == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < j

  ID: 9
  Type: NodeType.VARIABLE
  Expression: investor = intentInv[msg.sender][i]

  ID: 10
  Type: NodeType.IF
  Expression: investor == inv

  ID: 11
  Type: NodeType.RETURN
  Expression: intended[inv][msg.sender]

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(inv))

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 8
  15 -> 16
  16 -> 1

Function: intendedLOIInvestorName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: j = intentInv[msg.sender].length

  ID: 2
  Type: NodeType.IF
  Expression: j == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < j

  ID: 9
  Type: NodeType.VARIABLE
  Expression: inv = intentInv[msg.sender][i]

  ID: 10
  Type: NodeType.IF
  Expression: (inv == _iv) && (intended[inv][msg.sender] > 0)

  ID: 11
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(bytes32ToStr(toLowerCaseBytes32(mb32(bytes(getName(hashOfGWP(AGWP(inv))))))),tld()))

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(msg.sender))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_iv))

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 8
  15 -> 16
  16 -> 1

Function: getLOIInvestorName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: j = intentInv[tg].length

  ID: 2
  Type: NodeType.IF
  Expression: j == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < j

  ID: 9
  Type: NodeType.VARIABLE
  Expression: inv = intentInv[tg][i]

  ID: 10
  Type: NodeType.IF
  Expression: (inv == _iv) && (intended[inv][tg] > 0)

  ID: 11
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(bytes32ToStr(toLowerCaseBytes32(mb32(bytes(getName(hashOfGWP(AGWP(inv))))))),tld()))

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(tg))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ungravelGW(AGWP(_iv))

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 8
  15 -> 16
  16 -> 1

Function: strlen
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: bytelength = bytes(s).length

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: len = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < bytelength

  ID: 8
  Type: NodeType.VARIABLE
  Expression: b = bytes(s)[i]

  ID: 9
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i += 1

  ID: 11
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 13
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i += 3

  ID: 15
  Type: NodeType.IF
  Expression: b < 0xF8

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i += 4

  ID: 17
  Type: NodeType.IF
  Expression: b < 0xFC

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: i += 5

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i += 6

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 26
  Type: NodeType.RETURN
  Expression: len

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 26
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 24
  11 -> 12
  11 -> 13
  12 -> 23
  13 -> 14
  13 -> 15
  14 -> 22
  15 -> 16
  15 -> 17
  16 -> 21
  17 -> 18
  17 -> 19
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 7

Function: mb32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: a = mload(uint256)(_data + 32)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: bytes32ToStr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bArr = new bytes(32)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < 32

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: bArr[i] = _b[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: string(bArr)

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: toLowerCaseBytes32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: uint256(uint256(uint256(_in) & k_typeMask) >> 252) < 6

  ID: 2
  Type: NodeType.RETURN
  Expression: bytes32(uint256(uint256(_in) | 0x2000000000000000000000000000000000000000000000000000000000000000))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _in

  ID: 5
  Type: NodeType.RETURN
  Expression: _out

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: memcpy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: len >= 32

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(dest,mload(uint256)(src))

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: dest += 32

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: src += 32

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: len -= 32

  ID: 10
  Type: NodeType.IF
  Expression: len == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: mask = 256 ** (32 - len) - 1

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: srcpart_memcpy_asm_1 = mload(uint256)(src) & ~ mask

  ID: 17
  Type: NodeType.VARIABLE
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: destpart_memcpy_asm_1 = mload(uint256)(dest) & mask

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(dest,destpart_memcpy_asm_1 | srcpart_memcpy_asm_1)

  ID: 20
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 3
  2 -> 10
  3 -> 4
  3 -> 2
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 3
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20

Function: substring
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(offset + len <= self.length,substring!!!)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: ret = new bytes(len)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dest = ret + 32

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: src = self + 32 + offset

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: memcpy(dest,src,len)

  ID: 10
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: delArr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: delimiter = new uint8[](2)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: nb = 0

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: bytelength = bytes(s).length

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < bytelength

  ID: 10
  Type: NodeType.VARIABLE
  Expression: b = bytes(s)[i]

  ID: 11
  Type: NodeType.IF
  Expression: b == 0x2e

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: delimiter[nb] = uint8(i)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: nb ++

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i += 1

  ID: 17
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 19
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i += 3

  ID: 21
  Type: NodeType.IF
  Expression: b < 0xF8

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i += 4

  ID: 23
  Type: NodeType.IF
  Expression: b < 0xFC

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: i += 5

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i += 6

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 32
  Type: NodeType.RETURN
  Expression: delimiter

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 32
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  11 -> 14
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 30
  17 -> 18
  17 -> 19
  18 -> 29
  19 -> 20
  19 -> 21
  20 -> 28
  21 -> 22
  21 -> 23
  22 -> 27
  23 -> 24
  23 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 9

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: size = extcodesize(uint256)(addr)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: size > 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: auctionTransactionRecord
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(gwp) != k_add00 && isContract(address(gwp)),Intentions auctTRecord!)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = gwp.getTransactionsCount()

  ID: 4
  Type: NodeType.IF
  Expression: i == 0

  ID: 5
  Type: NodeType.RETURN
  Expression: (address(0x0),0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (i > 0) && (t > 0) && (t & k_typeMask != k_typeMask)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: t = gwp.getTransactionRecord(i)

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: t & k_typeMask == k_typeMask

  ID: 13
  Type: NodeType.RETURN
  Expression: (address(uint160(t & k_aMask)),i)

  ID: 14
  Type: NodeType.RETURN
  Expression: (address(0x0),0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 9
  8 -> 9
  8 -> 11
  9 -> 10
  10 -> 8
  11 -> 12
  12 -> 13
  12 -> 14

Function: IntentTransactionRecord
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: k_typeMask12 = 0xc000000000000000000000000000000000000000000000000000000000000000

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(gwp) != k_add00 && isContract(address(gwp)),Intentions intentTRecord!)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = gwp.getTransactionsCount()

  ID: 5
  Type: NodeType.IF
  Expression: i == 0

  ID: 6
  Type: NodeType.RETURN
  Expression: (address(0x0),0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: (i > 0) && (t > 0) && (t & k_typeMask12 != k_typeMask12)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: t = gwp.getTransactionRecord(i)

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: t & k_typeMask12 == k_typeMask12

  ID: 14
  Type: NodeType.RETURN
  Expression: (address(uint160(t & k_aMask)),i)

  ID: 15
  Type: NodeType.RETURN
  Expression: (address(0x0),0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 10
  9 -> 10
  9 -> 12
  10 -> 11
  11 -> 9
  12 -> 13
  13 -> 14
  13 -> 15

Function: chain_tld
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: chainId == 1

  ID: 2
  Type: NodeType.RETURN
  Expression: .eth

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: chainId == 10

  ID: 5
  Type: NodeType.RETURN
  Expression: .op

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: chainId == 56

  ID: 8
  Type: NodeType.RETURN
  Expression: .bsc

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: chainId == 100

  ID: 11
  Type: NodeType.RETURN
  Expression: .gnosis

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: chainId == 130

  ID: 14
  Type: NodeType.RETURN
  Expression: .uni

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: chainId == 137

  ID: 17
  Type: NodeType.RETURN
  Expression: .matic

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: chainId == 1135

  ID: 20
  Type: NodeType.RETURN
  Expression: .lisk

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.IF
  Expression: chainId == 8453

  ID: 23
  Type: NodeType.RETURN
  Expression: .base

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: chainId == 42161

  ID: 26
  Type: NodeType.RETURN
  Expression: .one

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: chainId == 81457

  ID: 29
  Type: NodeType.RETURN
  Expression: .blast

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: chainId == 167000

  ID: 32
  Type: NodeType.RETURN
  Expression: .tko

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.IF
  Expression: chainId == 421614

  ID: 35
  Type: NodeType.RETURN
  Expression: .arb

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: chainId == 534352

  ID: 38
  Type: NodeType.RETURN
  Expression: .scroll

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.IF
  Expression: chainId == 11155111

  ID: 41
  Type: NodeType.RETURN
  Expression: .sepeth

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.IF
  Expression: chainId == 11155420

  ID: 44
  Type: NodeType.RETURN
  Expression: .opt

  ID: 45
  Type: NodeType.ENDIF
  Expression: 

  ID: 46
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 23
  22 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  33 -> 34
  34 -> 35
  34 -> 36
  36 -> 37
  37 -> 38
  37 -> 39
  39 -> 40
  40 -> 41
  40 -> 42
  42 -> 43
  43 -> 44
  43 -> 45
  45 -> 46

Function: chain_name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: chainId == 1

  ID: 2
  Type: NodeType.RETURN
  Expression: mainnet

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: chainId == 10

  ID: 5
  Type: NodeType.RETURN
  Expression: optmain

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: chainId == 56

  ID: 8
  Type: NodeType.RETURN
  Expression: bscmain

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: chainId == 100

  ID: 11
  Type: NodeType.RETURN
  Expression: gnosis

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: chainId == 130

  ID: 14
  Type: NodeType.RETURN
  Expression: unichain

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: chainId == 137

  ID: 17
  Type: NodeType.RETURN
  Expression: polygon

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: chainId == 1135

  ID: 20
  Type: NodeType.RETURN
  Expression: lisk

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.IF
  Expression: chainId == 8453

  ID: 23
  Type: NodeType.RETURN
  Expression: base

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: chainId == 42161

  ID: 26
  Type: NodeType.RETURN
  Expression: arbmain

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: chainId == 81457

  ID: 29
  Type: NodeType.RETURN
  Expression: blast

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: chainId == 167000

  ID: 32
  Type: NodeType.RETURN
  Expression: taiko

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.IF
  Expression: chainId == 421614

  ID: 35
  Type: NodeType.RETURN
  Expression: arbitrum

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: chainId == 534352

  ID: 38
  Type: NodeType.RETURN
  Expression: scroll

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.IF
  Expression: chainId == 11155111

  ID: 41
  Type: NodeType.RETURN
  Expression: sepolia

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.IF
  Expression: chainId == 11155420

  ID: 44
  Type: NodeType.RETURN
  Expression: optimism

  ID: 45
  Type: NodeType.ENDIF
  Expression: 

  ID: 46
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 23
  22 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  33 -> 34
  34 -> 35
  34 -> 36
  36 -> 37
  37 -> 38
  37 -> 39
  39 -> 40
  40 -> 41
  40 -> 42
  42 -> 43
  43 -> 44
  43 -> 45
  45 -> 46

Function: tld
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: chain_tld(block.chainid)

Edges:
  0 -> 1

Function: chainName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: chain_name(block.chainid)

Edges:
  0 -> 1

Function: setGWFContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(gwfCtr) != k_add00 && isContract(address(gwfCtr)) && getMasterCopy() == msg.sender,gwf)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: GWF = gwfCtr

Edges:
  0 -> 1
  1 -> 2

Function: version
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 20010024

  ID: 2
  Type: NodeType.RETURN
  Expression: v

Edges:
  0 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(getMasterCopy() == msg.sender && address(address(uint160(msg.sender))).send(address(this).balance - 1),iW)

Edges:
  0 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Deposit(msg.sender,msg.value)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(false,Intentions!)

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Deposit(msg.sender,msg.value)

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(strlen(tld()) > 0 && address(_gwf) != k_add00 && isContract(_gwf),Intentions CONST!)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(version() > 20010000,Intentions VERS!)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(strlen(chainName()) > 0,Intentions CHAIN!)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: masterCopy = msg.sender

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: GWF = AbstractGWF_int(_gwf)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: UNG_Mcap = 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Deployment(msg.sender,address(this))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: DeploymentIntentions(address(this),bytes32(getNodeHash(string(abi.encodePacked(chainName())))))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _guardCounter = 1

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_add00 = address(0x0)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_aMask = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_typeMask = 0xf000000000000000000000000000000000000000000000000000000000000000

Edges:
  0 -> 1
  1 -> 2


