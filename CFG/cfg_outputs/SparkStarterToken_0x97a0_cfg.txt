Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2


Contract: IERC20
==================================================


Contract: IERC20Metadata
==================================================


Contract: ERC20
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,amount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,amount)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: increaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - subtractedValue)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - amount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += amount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),account,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - amount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: msgSender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = msgSender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(address(0),msgSender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1


Contract: Address
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: account.code.length > 0

Edges:
  0 -> 1

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: returndata

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 7

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value))

Edges:
  0 -> 1

Function: _callOptionalReturn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: returndata = address(token).functionCall(data,SafeERC20: low-level call failed)

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(abi.decode(returndata,(bool)),SafeERC20: ERC20 operation did not succeed)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4

Function: safeApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)((value == 0) || (token.allowance(address(this),spender) == 0),SafeERC20: approve from non-zero to non-zero allowance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value))

Edges:
  0 -> 1
  1 -> 2


Contract: IPriceFeed
==================================================


Contract: ILpPair
==================================================


Contract: IWETH
==================================================


Contract: IDexRouter
==================================================


Contract: IDexFactory
==================================================


Contract: UNCXLocker
==================================================


Contract: SparkStarterToken
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._teamTokenPercent <= 9999,Cannot mint 100% to team wallet)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _mint(_tokenInfo._teamTokensWallet,_tokenInfo._supply * 1e18 * _tokenInfo._teamTokenPercent / 10000)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _mint(address(this),_tokenInfo._supply * 1e18 - balanceOf(_tokenInfo._teamTokensWallet))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: tokenInfo = _tokenInfo

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: dynamicTaxOn = true

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: whitelistActive = _tokenInfo._isWhitelistLaunch

  ID: 10
  Type: NodeType.IF
  Expression: block.chainid == 1

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD] = true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x000000fee13a103A10D593b9AE06b3e05F2E7E1c] = true

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af] = true

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _tokenLocker = 0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419

  ID: 17
  Type: NodeType.IF
  Expression: block.chainid == 11155111

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0xa3D89E5B9C7a863BF4535F349Bc5619ABe72fb09

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x694AA1769357215DE4FAC081bf1f309aDC325306

  ID: 20
  Type: NodeType.IF
  Expression: block.chainid == 8453

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD] = true

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x5d64D14D2CF4fe5fe4e65B1c7E3D11e18D493091] = true

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x6fF5693b99212Da76ad316178A184AB56D299b43] = true

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _tokenLocker = 0x74E3DFFAc347B9bd2D620Ce6FB0efC23C7E88a31

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Chain not configured)

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: priceFeed = IPriceFeed(_priceFeed)

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: dexRouter = IDexRouter(_v2Router)

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: tokenLocker = _tokenLocker

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: swapTokensAtAmt = totalSupply() * 25 / 100000

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: taxAddress1 = _tokenInfo._taxWallet1

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: taxAddress2 = _tokenInfo._taxWallet2

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: incubatorAddress = _tokenInfo._incubatorWallet

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: platformAddress = _platformAddress

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: buyTax = _tokenInfo._buyTaxes[0]

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._buyTaxes.length == 5)

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._buyTaxes[1] >= _tokenInfo._buyTaxes[2] && _tokenInfo._buyTaxes[2] >= _tokenInfo._buyTaxes[3] && _tokenInfo._buyTaxes[3] >= _tokenInfo._buyTaxes[4],Cannot increase buy tax over time)

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: sellTax = _tokenInfo._sellTaxes[0]

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._sellTaxes.length == 5)

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._sellTaxes[1] >= _tokenInfo._sellTaxes[2] && _tokenInfo._sellTaxes[2] >= _tokenInfo._sellTaxes[3] && _tokenInfo._sellTaxes[3] >= _tokenInfo._sellTaxes[4],Cannot increase sell tax over time)

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * _tokenInfo._maxWallets[0] / 10000)

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._maxWallets.length == 5)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._maxWallets[1] <= _tokenInfo._maxWallets[2] && _tokenInfo._maxWallets[2] <= _tokenInfo._maxWallets[3] && _tokenInfo._maxWallets[3] <= _tokenInfo._maxWallets[4],Cannot decrease max wallet over time)

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: taxAddress1Split = _tokenInfo._taxWallet1Split

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(taxAddress1Split <= 10000,Cannot exceed 100% for tax split)

  ID: 50
  Type: NodeType.IF
  Expression: taxAddress2 == address(0)

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: taxAddress1Split = 10000

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: WETH = dexRouter.WETH()

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: lpPair = IDexFactory(dexRouter.factory()).createPair(address(this),WETH)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: isAMMPair[lpPair] = true

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[lpPair] = true

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[msg.sender] = true

  ID: 58
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[address(this)] = true

  ID: 59
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[address(0xdead)] = true

  ID: 60
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[msg.sender] = true

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(this)] = true

  ID: 62
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(dexRouter)] = true

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(0xdead)] = true

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: _approve(address(this),address(dexRouter),type()(uint256).max)

  ID: 65
  Type: NodeType.EXPRESSION
  Expression: _approve(address(msg.sender),address(dexRouter),totalSupply())

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: ERC20(_tokenInfo._name,_tokenInfo._symbol)

Edges:
  0 -> 66
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 17
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 30
  17 -> 18
  17 -> 20
  18 -> 19
  19 -> 29
  20 -> 21
  20 -> 27
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 50
  50 -> 51
  50 -> 52
  51 -> 52
  52 -> 53
  53 -> 54
  54 -> 55
  55 -> 56
  56 -> 57
  57 -> 58
  58 -> 59
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64
  64 -> 65
  66 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,amount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,amount)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: increaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - subtractedValue)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! exemptFromFees[from] && ! exemptFromFees[to]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tradingAllowed,Trading not active)

  ID: 3
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 4
  Type: NodeType.IF
  Expression: whitelistStartTime + 300 <= block.timestamp

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: whitelistActive = false

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[1]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[1]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[1] / FEE_DIVISOR)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: amount -= handleTax(from,to,amount)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: checkLimits(from,to,amount)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: super._transfer(from,to,amount)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (currentMcap,None) = computeMcap()

  ID: 17
  Type: NodeType.IF
  Expression: currentMcap > athMcap

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: athMcap = currentMcap

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  3 -> 4
  3 -> 10
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),account,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - amount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: checkLimits
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: limited

  ID: 2
  Type: NodeType.VARIABLE
  Expression: exFromLimitsTo = exemptFromLimits[to]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: balanceOfTo = balanceOf(to)

  ID: 4
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 5
  Type: NodeType.IF
  Expression: isAMMPair[from] && ! exFromLimitsTo

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[to],Not whitelisted)

  ID: 7
  Type: NodeType.IF
  Expression: isAMMPair[to] && ! exemptFromLimits[from]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[from],Not whitelisted)

  ID: 9
  Type: NodeType.IF
  Expression: ! exFromLimitsTo

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[to] && whitelistedAddress[from],Not whitelisted)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: isAMMPair[from] && ! exFromLimitsTo

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount + balanceOfTo <= maxWallet,Max Wallet)

  ID: 17
  Type: NodeType.IF
  Expression: ! exFromLimitsTo

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount + balanceOfTo <= maxWallet,Max Wallet)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 21
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 14
  5 -> 6
  5 -> 7
  6 -> 13
  7 -> 8
  7 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21

Function: handleTax
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: balanceOf(address(this)) >= swapTokensAtAmt && ! isAMMPair[from] && lastSwapBackBlock + 1 <= block.number

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: convertTaxes()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: dynamicTaxOn && ! whitelistActive

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: setInternalTaxes()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: tax = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: isAMMPair[to]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: taxes = sellTax

  ID: 11
  Type: NodeType.IF
  Expression: isAMMPair[from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: taxes = buyTax

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: taxes > 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tax = uint128(amount * taxes / FEE_DIVISOR)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: super._transfer(from,address(this),tax)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: tax

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 14
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 18
  16 -> 17
  17 -> 18
  18 -> 19

Function: swapTokensForETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: path[0] = address(this)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path[1] = WETH

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmt,0,path,address(this),block.timestamp)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: convertTaxes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: contractBalance = balanceOf(address(this))

  ID: 2
  Type: NodeType.IF
  Expression: contractBalance == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: lastSwapBackBlock = block.number

  ID: 6
  Type: NodeType.IF
  Expression: contractBalance > swapTokensAtAmt * 10

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: contractBalance = swapTokensAtAmt * 10

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: contractBalance > 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: swapTokensForETH(contractBalance)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ethBalance = address(this).balance

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: block.timestamp <= launchTimestamp + 2592000

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: (success,None) = incubatorAddress.call{value: ethBalance * 2000 / FEE_DIVISOR}()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (success,None) = platformAddress.call{value: ethBalance * 500 / FEE_DIVISOR}()

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ethBalance = address(this).balance

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: taxAddress1Split == 10000

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: ethBalance}()

  ID: 20
  Type: NodeType.VARIABLE
  Expression: taxAddress1Portion = ethBalance * taxAddress1Split / FEE_DIVISOR

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: taxAddress1Portion}()

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress2.call{value: ethBalance - taxAddress1Portion}()

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 24
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 17
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 23
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24

Function: enableTrading
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! tradingAllowed,Trading already enabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tradingAllowed = true

  ID: 3
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whitelistStartTime = block.timestamp

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: launchTimestamp = whitelistStartTime + 300

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: launchTimestamp = block.timestamp

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[1]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[1]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[1] / FEE_DIVISOR)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: renounceOwnership()

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 10
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 1

Function: whitelistWallets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < wallets.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[wallets[i]] = _whitelist

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4
  7 -> 3

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: setInternalTaxes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentTimestamp = block.timestamp

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: currentTimestamp >= launchTimestamp

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: timeSinceLaunch = currentTimestamp - launchTimestamp

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 900

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: dynamicTaxOn = false

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[4]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[4]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: limited = false

  ID: 12
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 600

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[3]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[3]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[3] / FEE_DIVISOR)

  ID: 16
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 300

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[2]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[2]

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[2] / FEE_DIVISOR)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 22
  12 -> 13
  12 -> 16
  13 -> 14
  14 -> 15
  15 -> 21
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: addLp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(address(this).balance > 0 && balanceOf(address(this)) > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: pair = lpPair

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: super._transfer(address(this),address(pair),balanceOf(address(this)))

  ID: 4
  Type: NodeType.IF
  Expression: tokenInfo.lpLockDurationInMonths == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: address(this).balance}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: IERC20(address(WETH)).transfer(address(pair),IERC20(address(WETH)).balanceOf(address(this)))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ILpPair(pair).mint(address(to))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: feeStruct = UNCXLocker(tokenLocker).gFees()

  ID: 9
  Type: NodeType.VARIABLE
  Expression: ethFee = feeStruct.ethFee

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: address(this).balance - ethFee}()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: IERC20(address(WETH)).transfer(address(pair),IERC20(address(WETH)).balanceOf(address(this)))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ILpPair(pair).mint(address(this))

  ID: 13
  Type: NodeType.VARIABLE
  Expression: pairBalance = IERC20(pair).balanceOf(address(this))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: IERC20(pair).approve(tokenLocker,pairBalance)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: UNCXLocker(tokenLocker).lockLPToken{value: ethFee}(pair,pairBalance,block.timestamp + (tokenInfo.lpLockDurationInMonths * 2592000),address(address(0)),true,address(to))

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: (startingMcap,None) = computeMcap()

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 18
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 16
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  18 -> 1

Function: computeMcap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalLiquidityInEth = IERC20(address(WETH)).balanceOf(lpPair)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokensRemainingInPool = balanceOf(lpPair)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: totalSupply = totalSupply()

  ID: 4
  Type: NodeType.IF
  Expression: tokensRemainingInPool > 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mcapInEth = totalLiquidityInEth * totalSupply / tokensRemainingInPool

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mcapInUSD = mcapInEth * uint256(priceFeed.latestAnswer()) / 1e26

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (mcapInUSD,mcapInEth)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: limited = true

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FEE_DIVISOR = 10000

Edges:


Contract: IERCBurn
==================================================


Contract: StructsLibrary
==================================================


