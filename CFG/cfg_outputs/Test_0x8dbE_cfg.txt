Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: OwnablePermissions
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: IERC165
==================================================


Contract: IEOARegistry
==================================================


Contract: ITransferSecurityRegistry
==================================================


Contract: ITransferValidator
==================================================


Contract: ICreatorTokenTransferValidator
==================================================


Contract: ICreatorToken
==================================================


Contract: TransferValidation
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _validateBeforeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _preValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _preValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _preValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _validateAfterTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _postValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _postValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _postValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _preValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: CreatorTokenBase
==================================================

Function: _validateBeforeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _preValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _preValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _preValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _validateAfterTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _postValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _postValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _postValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _preValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: transferValidator.applyCollectionTransferPolicy(caller,from,to)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _postValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: setToDefaultSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(DEFAULT_TRANSFER_VALIDATOR)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setTransferSecurityLevelOfCollection(address(this),DEFAULT_TRANSFER_SECURITY_LEVEL)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setOperatorWhitelistOfCollection(address(this),DEFAULT_OPERATOR_WHITELIST_ID)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setToCustomValidatorAndSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(validator)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setTransferSecurityLevelOfCollection(address(this),level)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: setToCustomSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: validator = getTransferValidator()

  ID: 3
  Type: NodeType.IF
  Expression: address(validator) == address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__SetTransferValidatorFirst()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: validator.setTransferSecurityLevelOfCollection(address(this),level)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: validator.setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: validator.setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: setTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: isValidTransferValidator = false

  ID: 3
  Type: NodeType.IF
  Expression: transferValidator_.code.length > 0

  ID: 4
  Type: NodeType.TRY
  Expression: supportsInterface = IERC165(transferValidator_).supportsInterface(type()(ICreatorTokenTransferValidator).interfaceId)

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isValidTransferValidator = supportsInterface

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: transferValidator_ != address(0) && ! isValidTransferValidator

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__InvalidTransferValidatorContract()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: TransferValidatorUpdated(address(transferValidator),transferValidator_)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: transferValidator = ICreatorTokenTransferValidator(transferValidator_)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 7
  4 -> 8
  5 -> 6
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13

Function: getTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: transferValidator

Edges:
  0 -> 1

Function: getSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getCollectionSecurityPolicy(address(this))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: CollectionSecurityPolicy({transferSecurityLevel:TransferSecurityLevels.Zero,operatorWhitelistId:0,permittedContractReceiversId:0})

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getWhitelistedOperators
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getWhitelistedOperators(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getPermittedContractReceivers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getPermittedContractReceivers(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isOperatorWhitelisted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isOperatorWhitelisted(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId,operator)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isContractReceiverPermitted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isContractReceiverPermitted(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId,receiver)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isTransferAllowed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.TRY
  Expression: transferValidator.applyCollectionTransferPolicy(caller,from,to)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  2 -> 5
  2 -> 7
  3 -> 4
  5 -> 6
  7 -> 8

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_VALIDATOR = address(0x0000721C310194CcfC01E523fc93C9cCcFa2A0Ac)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_SECURITY_LEVEL = TransferSecurityLevels.One

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_OPERATOR_WHITELIST_ID = uint120(1)

Edges:
  0 -> 1
  1 -> 2


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Hashes
==================================================

Function: commutativeKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: _efficientKeccak256(a,b)

  ID: 4
  Type: NodeType.RETURN
  Expression: _efficientKeccak256(b,a)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: _efficientKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,a)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,b)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = keccak256(uint256,uint256)(0x00,0x40)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: MerkleProof
==================================================

Function: verify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProof(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: verifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProofCalldata(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: multiProofVerify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProof(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35

Function: multiProofVerifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProofCalldata(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35


Contract: IERC721A
==================================================


Contract: ERC721A__IERC721Receiver
==================================================


Contract: ERC721A
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = _startTokenId()

  ID: 4
  Type: NodeType.IF
  Expression: _sequentialUpTo() < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialUpToTooSmall().selector)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert URIQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == 0

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == 0

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS))

  ID: 3
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,from,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_MINTED = 64

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_BURNED = 128

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_AUX = 192

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_START_TIMESTAMP = 160

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_BURNED = 1 << 224

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NEXT_INITIALIZED = 225

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_NEXT_INITIALIZED = 1 << 225

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_EXTRA_DATA = 232

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS = (1 << 160) - 1

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13


Contract: IERC721AQueryable
==================================================


Contract: ERC721AQueryable
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = _startTokenId()

  ID: 4
  Type: NodeType.IF
  Expression: _sequentialUpTo() < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialUpToTooSmall().selector)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert URIQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == 0

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == 0

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS))

  ID: 3
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,from,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: explicitOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId >= _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _nextTokenId()

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: ! _ownershipIsInitialized(tokenId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  1 -> 12
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13

Function: explicitOwnershipsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = tokenIds.length

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownerships = mload(uint256)(0x40)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships,i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i = i << 5

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,ownerships + 0x20 + i)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i = i - 0x20

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenId = calldataload(uint256)(tokenIds + i)

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(tokenId)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships + 0x20 + i,ownership)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: ownerships

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 10
  20 -> 21

Function: tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokensOfOwnerIn(owner,start,stop)

Edges:
  0 -> 1

Function: tokensOfOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert NotCompatibleWithSpotMints().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: start = _startTokenId()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stop = _nextTokenId()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: start != stop

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenIds = _tokensOfOwnerIn(owner,start,stop)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10

Function: _tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= stop

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert InvalidQueryRange().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: start < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: start = _startTokenId()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: nextTokenId = _nextTokenId()

  ID: 9
  Type: NodeType.IF
  Expression: stop >= stopLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stop = stopLimit

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: tokenIdsMaxLength = balanceOf(owner)

  ID: 13
  Type: NodeType.IF
  Expression: start >= stop

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = 0

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: tokenIdsMaxLength != 0

  ID: 17
  Type: NodeType.IF
  Expression: stop - start <= tokenIdsMaxLength

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = stop - start

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: tokenIds = mload(uint256)(0x40)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: m = tokenIds + tokenIdsMaxLength + 1 << 5

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 25
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(start)

  ID: 27
  Type: NodeType.VARIABLE
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: ! ownership.burned

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: 

  ID: 32
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 33
  Type: NodeType.IFLOOP
  Expression: ! (start == stop || tokenIdsIdx == tokenIdsMaxLength)

  ID: 34
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 35
  Type: NodeType.IF
  Expression: start == nextTokenId

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: start = _sequentialUpTo() + 1

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: start > _sequentialUpTo()

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = address(0)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.ENDIF
  Expression: 

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(start)

  ID: 43
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 44
  Type: NodeType.VARIABLE
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 = mload(uint256)(ownership + 0x40)

  ID: 46
  Type: NodeType.IF
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 == 0

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.IF
  Expression: mload(uint256)(ownership)

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = mload(uint256)(ownership)

  ID: 51
  Type: NodeType.IF
  Expression: ! currOwnershipAddr ^ owner << 96

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: tokenIdsIdx = tokenIdsIdx + 1

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds + tokenIdsIdx << 5,start)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = 0

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: start = start + 1

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 58
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 59
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 60
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds,tokenIdsIdx)

  ID: 62
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 63
  Type: NodeType.ENDIF
  Expression: 

  ID: 64
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 65
  Type: NodeType.EXPRESSION
  Expression: stopLimit = stop

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: stopLimit = nextTokenId

  ID: 67
  Type: NodeType.ENDIF
  Expression: 

  ID: 68
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 64
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 63
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 34
  33 -> 34
  33 -> 59
  34 -> 35
  34 -> 41
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 48
  46 -> 55
  47 -> 56
  48 -> 50
  48 -> 49
  49 -> 51
  50 -> 49
  51 -> 53
  51 -> 52
  52 -> 47
  53 -> 54
  54 -> 52
  55 -> 47
  56 -> 57
  57 -> 58
  58 -> 33
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 68
  64 -> 65
  64 -> 66
  65 -> 67
  66 -> 67
  67 -> 9


Contract: ERC721ACQueryable
==================================================

Function: setToDefaultSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(DEFAULT_TRANSFER_VALIDATOR)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setTransferSecurityLevelOfCollection(address(this),DEFAULT_TRANSFER_SECURITY_LEVEL)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setOperatorWhitelistOfCollection(address(this),DEFAULT_OPERATOR_WHITELIST_ID)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setToCustomValidatorAndSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(validator)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setTransferSecurityLevelOfCollection(address(this),level)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: setToCustomSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: validator = getTransferValidator()

  ID: 3
  Type: NodeType.IF
  Expression: address(validator) == address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__SetTransferValidatorFirst()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: validator.setTransferSecurityLevelOfCollection(address(this),level)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: validator.setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: validator.setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: setTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: isValidTransferValidator = false

  ID: 3
  Type: NodeType.IF
  Expression: transferValidator_.code.length > 0

  ID: 4
  Type: NodeType.TRY
  Expression: supportsInterface = IERC165(transferValidator_).supportsInterface(type()(ICreatorTokenTransferValidator).interfaceId)

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isValidTransferValidator = supportsInterface

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: transferValidator_ != address(0) && ! isValidTransferValidator

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__InvalidTransferValidatorContract()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: TransferValidatorUpdated(address(transferValidator),transferValidator_)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: transferValidator = ICreatorTokenTransferValidator(transferValidator_)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 7
  4 -> 8
  5 -> 6
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13

Function: getTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: transferValidator

Edges:
  0 -> 1

Function: getSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getCollectionSecurityPolicy(address(this))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: CollectionSecurityPolicy({transferSecurityLevel:TransferSecurityLevels.Zero,operatorWhitelistId:0,permittedContractReceiversId:0})

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getWhitelistedOperators
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getWhitelistedOperators(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getPermittedContractReceivers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getPermittedContractReceivers(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isOperatorWhitelisted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isOperatorWhitelisted(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId,operator)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isContractReceiverPermitted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isContractReceiverPermitted(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId,receiver)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isTransferAllowed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.TRY
  Expression: transferValidator.applyCollectionTransferPolicy(caller,from,to)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  2 -> 5
  2 -> 7
  3 -> 4
  5 -> 6
  7 -> 8

Function: _preValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _validateBeforeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _preValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _preValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _preValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _validateAfterTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _postValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _postValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _postValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _preValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: explicitOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId >= _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _nextTokenId()

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: ! _ownershipIsInitialized(tokenId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  1 -> 12
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13

Function: explicitOwnershipsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = tokenIds.length

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownerships = mload(uint256)(0x40)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships,i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i = i << 5

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,ownerships + 0x20 + i)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i = i - 0x20

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenId = calldataload(uint256)(tokenIds + i)

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(tokenId)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships + 0x20 + i,ownership)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: ownerships

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 10
  20 -> 21

Function: tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokensOfOwnerIn(owner,start,stop)

Edges:
  0 -> 1

Function: tokensOfOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert NotCompatibleWithSpotMints().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: start = _startTokenId()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stop = _nextTokenId()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: start != stop

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenIds = _tokensOfOwnerIn(owner,start,stop)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10

Function: _tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= stop

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert InvalidQueryRange().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: start < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: start = _startTokenId()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: nextTokenId = _nextTokenId()

  ID: 9
  Type: NodeType.IF
  Expression: stop >= stopLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stop = stopLimit

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: tokenIdsMaxLength = balanceOf(owner)

  ID: 13
  Type: NodeType.IF
  Expression: start >= stop

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = 0

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: tokenIdsMaxLength != 0

  ID: 17
  Type: NodeType.IF
  Expression: stop - start <= tokenIdsMaxLength

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = stop - start

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: tokenIds = mload(uint256)(0x40)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: m = tokenIds + tokenIdsMaxLength + 1 << 5

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 25
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(start)

  ID: 27
  Type: NodeType.VARIABLE
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: ! ownership.burned

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: 

  ID: 32
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 33
  Type: NodeType.IFLOOP
  Expression: ! (start == stop || tokenIdsIdx == tokenIdsMaxLength)

  ID: 34
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 35
  Type: NodeType.IF
  Expression: start == nextTokenId

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: start = _sequentialUpTo() + 1

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: start > _sequentialUpTo()

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = address(0)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.ENDIF
  Expression: 

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(start)

  ID: 43
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 44
  Type: NodeType.VARIABLE
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 = mload(uint256)(ownership + 0x40)

  ID: 46
  Type: NodeType.IF
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 == 0

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.IF
  Expression: mload(uint256)(ownership)

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = mload(uint256)(ownership)

  ID: 51
  Type: NodeType.IF
  Expression: ! currOwnershipAddr ^ owner << 96

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: tokenIdsIdx = tokenIdsIdx + 1

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds + tokenIdsIdx << 5,start)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = 0

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: start = start + 1

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 58
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 59
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 60
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds,tokenIdsIdx)

  ID: 62
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 63
  Type: NodeType.ENDIF
  Expression: 

  ID: 64
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 65
  Type: NodeType.EXPRESSION
  Expression: stopLimit = stop

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: stopLimit = nextTokenId

  ID: 67
  Type: NodeType.ENDIF
  Expression: 

  ID: 68
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 64
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 63
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 34
  33 -> 34
  33 -> 59
  34 -> 35
  34 -> 41
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 48
  46 -> 55
  47 -> 56
  48 -> 50
  48 -> 49
  49 -> 51
  50 -> 49
  51 -> 53
  51 -> 52
  52 -> 47
  53 -> 54
  54 -> 52
  55 -> 47
  56 -> 57
  57 -> 58
  58 -> 33
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 68
  64 -> 65
  64 -> 66
  65 -> 67
  66 -> 67
  67 -> 9

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: CreatorTokenBase()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ERC721A(name_,symbol_)

Edges:
  0 -> 1
  1 -> 2

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(ICreatorToken).interfaceId || ERC721A.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert URIQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == 0

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == 0

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS))

  ID: 3
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,from,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < quantity

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _validateBeforeTransfer(from,to,startTokenId + i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ++ i

Edges:
  0 -> 3
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < quantity

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _validateAfterTransfer(from,to,startTokenId + i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ++ i

Edges:
  0 -> 3
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _msgSender()

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _tokenType
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint16(721)

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_VALIDATOR = address(0x0000721C310194CcfC01E523fc93C9cCcFa2A0Ac)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_SECURITY_LEVEL = TransferSecurityLevels.One

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_OPERATOR_WHITELIST_ID = uint120(1)

Edges:
  0 -> 1
  1 -> 2


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENTERED = 2

Edges:
  0 -> 1


Contract: IERC721L
==================================================


Contract: ERC2981
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_feeDenominator() != 0,Fee denominator cannot be zero.)

Edges:
  0 -> 1

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: s_supportsInterface_asm_0 = interfaceId >> 224

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = s_supportsInterface_asm_0 == 0x01ffc9a7 | s_supportsInterface_asm_0 == 0x2a55205a

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed_royaltyInfo_asm_0 = sload(uint256)(keccak256(uint256,uint256)(0x00,0x40))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: receiver = packed_royaltyInfo_asm_0 >> 96

  ID: 8
  Type: NodeType.IF
  Expression: ! receiver

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: packed_royaltyInfo_asm_0 = sload(uint256)(mload(uint256)(0x20))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: receiver = packed_royaltyInfo_asm_0 >> 96

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: x_royaltyInfo_asm_0 = salePrice

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: y_royaltyInfo_asm_0 = packed_royaltyInfo_asm_0 ^ receiver << 96

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: returndatacopy(uint256,uint256,uint256)(returndatasize()(),returndatasize()(),y_royaltyInfo_asm_0 * x_royaltyInfo_asm_0 > ~ 0 / y_royaltyInfo_asm_0)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: royaltyAmount = x_royaltyInfo_asm_0 * y_royaltyInfo_asm_0 / feeDenominator

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: (receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  8 -> 9
  9 -> 12
  10 -> 11
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: feeNumerator = feeNumerator << 160 >> 160

  ID: 4
  Type: NodeType.IF
  Expression: feeNumerator > feeDenominator

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0x350a88b3)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed__setDefaultRoyalty_asm_0 = receiver << 96

  ID: 10
  Type: NodeType.IF
  Expression: ! packed__setDefaultRoyalty_asm_0

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0xb4457eaa)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(_ERC2981_MASTER_SLOT_SEED,packed__setDefaultRoyalty_asm_0 | feeNumerator)

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 12
  10 -> 11
  11 -> 14
  12 -> 13
  13 -> 11
  14 -> 15

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(_ERC2981_MASTER_SLOT_SEED,0)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: feeNumerator = feeNumerator << 160 >> 160

  ID: 4
  Type: NodeType.IF
  Expression: feeNumerator > feeDenominator

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0x350a88b3)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed__setTokenRoyalty_asm_0 = receiver << 96

  ID: 10
  Type: NodeType.IF
  Expression: ! packed__setTokenRoyalty_asm_0

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0xb4457eaa)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(keccak256(uint256,uint256)(0x00,0x40),packed__setTokenRoyalty_asm_0 | feeNumerator)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 12
  10 -> 11
  11 -> 14
  12 -> 13
  13 -> 11
  14 -> 15
  15 -> 16
  16 -> 17

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(keccak256(uint256,uint256)(0x00,0x40),0)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ERC2981_MASTER_SLOT_SEED = 0xaa4ec00224afccfdb7

Edges:


Contract: Test
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(msg.sender,100)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _mintStages.push(MintStageInfo({cost:50000000000000000,walletLimit:5,merkleRoot:0x0,maxStageSupply:0,startTimeUnixSeconds:1742662886,endTimeUnixSeconds:1747846886}))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ERC721ACQueryable(Test,Test)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Ownable(msg.sender)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: super.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId) || ERC721ACQueryable.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed_royaltyInfo_asm_0 = sload(uint256)(keccak256(uint256,uint256)(0x00,0x40))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: receiver = packed_royaltyInfo_asm_0 >> 96

  ID: 8
  Type: NodeType.IF
  Expression: ! receiver

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: packed_royaltyInfo_asm_0 = sload(uint256)(mload(uint256)(0x20))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: receiver = packed_royaltyInfo_asm_0 >> 96

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: x_royaltyInfo_asm_0 = salePrice

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: y_royaltyInfo_asm_0 = packed_royaltyInfo_asm_0 ^ receiver << 96

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: returndatacopy(uint256,uint256,uint256)(returndatasize()(),returndatasize()(),y_royaltyInfo_asm_0 * x_royaltyInfo_asm_0 > ~ 0 / y_royaltyInfo_asm_0)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: royaltyAmount = x_royaltyInfo_asm_0 * y_royaltyInfo_asm_0 / feeDenominator

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: (receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  8 -> 9
  9 -> 12
  10 -> 11
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: feeNumerator = feeNumerator << 160 >> 160

  ID: 4
  Type: NodeType.IF
  Expression: feeNumerator > feeDenominator

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0x350a88b3)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed__setDefaultRoyalty_asm_0 = receiver << 96

  ID: 10
  Type: NodeType.IF
  Expression: ! packed__setDefaultRoyalty_asm_0

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0xb4457eaa)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(_ERC2981_MASTER_SLOT_SEED,packed__setDefaultRoyalty_asm_0 | feeNumerator)

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 12
  10 -> 11
  11 -> 14
  12 -> 13
  13 -> 11
  14 -> 15

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(_ERC2981_MASTER_SLOT_SEED,0)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeDenominator = _feeDenominator()

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: feeNumerator = feeNumerator << 160 >> 160

  ID: 4
  Type: NodeType.IF
  Expression: feeNumerator > feeDenominator

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0x350a88b3)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed__setTokenRoyalty_asm_0 = receiver << 96

  ID: 10
  Type: NodeType.IF
  Expression: ! packed__setTokenRoyalty_asm_0

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,0xb4457eaa)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x1c,0x04)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(keccak256(uint256,uint256)(0x00,0x40),packed__setTokenRoyalty_asm_0 | feeNumerator)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 12
  10 -> 11
  11 -> 14
  12 -> 13
  13 -> 11
  14 -> 15
  15 -> 16
  16 -> 17

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,tokenId)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,_ERC2981_MASTER_SLOT_SEED)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(keccak256(uint256,uint256)(0x00,0x40),0)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _tokenType
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint16(721)

Edges:
  0 -> 1

Function: setToDefaultSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(DEFAULT_TRANSFER_VALIDATOR)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setTransferSecurityLevelOfCollection(address(this),DEFAULT_TRANSFER_SECURITY_LEVEL)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setOperatorWhitelistOfCollection(address(this),DEFAULT_OPERATOR_WHITELIST_ID)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setToCustomValidatorAndSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setTransferValidator(validator)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setTransferSecurityLevelOfCollection(address(this),level)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ICreatorTokenTransferValidator(validator).setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: setToCustomSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: validator = getTransferValidator()

  ID: 3
  Type: NodeType.IF
  Expression: address(validator) == address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__SetTransferValidatorFirst()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: validator.setTransferSecurityLevelOfCollection(address(this),level)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: validator.setOperatorWhitelistOfCollection(address(this),operatorWhitelistId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: validator.setPermittedContractReceiverAllowlistOfCollection(address(this),permittedContractReceiversAllowlistId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: setTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCallerIsContractOwner()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: isValidTransferValidator = false

  ID: 3
  Type: NodeType.IF
  Expression: transferValidator_.code.length > 0

  ID: 4
  Type: NodeType.TRY
  Expression: supportsInterface = IERC165(transferValidator_).supportsInterface(type()(ICreatorTokenTransferValidator).interfaceId)

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isValidTransferValidator = supportsInterface

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: transferValidator_ != address(0) && ! isValidTransferValidator

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert CreatorTokenBase__InvalidTransferValidatorContract()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: TransferValidatorUpdated(address(transferValidator),transferValidator_)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: transferValidator = ICreatorTokenTransferValidator(transferValidator_)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 7
  4 -> 8
  5 -> 6
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13

Function: getTransferValidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: transferValidator

Edges:
  0 -> 1

Function: getSecurityPolicy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getCollectionSecurityPolicy(address(this))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: CollectionSecurityPolicy({transferSecurityLevel:TransferSecurityLevels.Zero,operatorWhitelistId:0,permittedContractReceiversId:0})

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getWhitelistedOperators
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getWhitelistedOperators(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getPermittedContractReceivers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.getPermittedContractReceivers(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: new address[](0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isOperatorWhitelisted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isOperatorWhitelisted(transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId,operator)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isContractReceiverPermitted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: transferValidator.isContractReceiverPermitted(transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId,receiver)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: isTransferAllowed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(transferValidator) != address(0)

  ID: 2
  Type: NodeType.TRY
  Expression: transferValidator.applyCollectionTransferPolicy(caller,from,to)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  2 -> 5
  2 -> 7
  3 -> 4
  5 -> 6
  7 -> 8

Function: _preValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _validateBeforeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _preValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _preValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _preValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _validateAfterTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: fromZeroAddress = from == address(0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: toZeroAddress = to == address(0)

  ID: 3
  Type: NodeType.IF
  Expression: fromZeroAddress && toZeroAddress

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ShouldNotMintToBurnAddress()()

  ID: 5
  Type: NodeType.IF
  Expression: fromZeroAddress

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _postValidateMint(_msgSender(),to,tokenId,msg.value)

  ID: 7
  Type: NodeType.IF
  Expression: toZeroAddress

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _postValidateBurn(_msgSender(),from,tokenId,msg.value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _postValidateTransfer(_msgSender(),from,to,tokenId,msg.value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 12
  5 -> 6
  5 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: _preValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _preValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _postValidateTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: explicitOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId >= _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _nextTokenId()

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: ! _ownershipIsInitialized(tokenId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: _ownershipAt(tokenId)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  1 -> 12
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13

Function: explicitOwnershipsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = tokenIds.length

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownerships = mload(uint256)(0x40)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships,i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i = i << 5

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,ownerships + 0x20 + i)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i = i - 0x20

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenId = calldataload(uint256)(tokenIds + i)

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(tokenId)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ownerships + 0x20 + i,ownership)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: ownerships

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 10
  20 -> 21

Function: tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokensOfOwnerIn(owner,start,stop)

Edges:
  0 -> 1

Function: tokensOfOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert NotCompatibleWithSpotMints().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: start = _startTokenId()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stop = _nextTokenId()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: start != stop

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenIds = _tokensOfOwnerIn(owner,start,stop)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10

Function: _tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= stop

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert InvalidQueryRange().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: start < _startTokenId()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: start = _startTokenId()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: nextTokenId = _nextTokenId()

  ID: 9
  Type: NodeType.IF
  Expression: stop >= stopLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stop = stopLimit

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: tokenIdsMaxLength = balanceOf(owner)

  ID: 13
  Type: NodeType.IF
  Expression: start >= stop

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = 0

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: tokenIdsMaxLength != 0

  ID: 17
  Type: NodeType.IF
  Expression: stop - start <= tokenIdsMaxLength

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = stop - start

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: tokenIds = mload(uint256)(0x40)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: m = tokenIds + tokenIdsMaxLength + 1 << 5

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 25
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(start)

  ID: 27
  Type: NodeType.VARIABLE
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: ! ownership.burned

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: 

  ID: 32
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 33
  Type: NodeType.IFLOOP
  Expression: ! (start == stop || tokenIdsIdx == tokenIdsMaxLength)

  ID: 34
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 35
  Type: NodeType.IF
  Expression: start == nextTokenId

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: start = _sequentialUpTo() + 1

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: start > _sequentialUpTo()

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = address(0)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.ENDIF
  Expression: 

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(start)

  ID: 43
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 44
  Type: NodeType.VARIABLE
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 = mload(uint256)(ownership + 0x40)

  ID: 46
  Type: NodeType.IF
  Expression: switch_expr_126766_1398_0__tokensOfOwnerIn_asm_1 == 0

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.IF
  Expression: mload(uint256)(ownership)

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = mload(uint256)(ownership)

  ID: 51
  Type: NodeType.IF
  Expression: ! currOwnershipAddr ^ owner << 96

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: tokenIdsIdx = tokenIdsIdx + 1

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds + tokenIdsIdx << 5,start)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = 0

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: start = start + 1

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m)

  ID: 58
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 59
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 60
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds,tokenIdsIdx)

  ID: 62
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 63
  Type: NodeType.ENDIF
  Expression: 

  ID: 64
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 65
  Type: NodeType.EXPRESSION
  Expression: stopLimit = stop

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: stopLimit = nextTokenId

  ID: 67
  Type: NodeType.ENDIF
  Expression: 

  ID: 68
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 64
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 63
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 34
  33 -> 34
  33 -> 59
  34 -> 35
  34 -> 41
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 48
  46 -> 55
  47 -> 56
  48 -> 50
  48 -> 49
  49 -> 51
  50 -> 49
  51 -> 53
  51 -> 52
  52 -> 47
  53 -> 54
  54 -> 52
  55 -> 47
  56 -> 57
  57 -> 58
  58 -> 33
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 68
  64 -> 65
  64 -> 66
  65 -> 67
  66 -> 67
  67 -> 9

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _sequentialUpTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: type()(uint256).max

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _burnCounter - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: result = _currentIndex - _startTokenId()

  ID: 2
  Type: NodeType.IF
  Expression: _sequentialUpTo() != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += _spotMinted

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: _totalSpotMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _spotMinted

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert BalanceQueryForZeroAddress().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert URIQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _currentBaseURI

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId),_tokenURISuffix))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _ownershipIsInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _packedOwnerships[index] != 0

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[tokenId]

  ID: 3
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 4
  Type: NodeType.IF
  Expression: _packedOwnershipExists(packed)

  ID: 5
  Type: NodeType.RETURN
  Expression: packed

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: packed == 0

  ID: 10
  Type: NodeType.IF
  Expression: tokenId >= _currentIndex

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- tokenId]

  ID: 16
  Type: NodeType.IF
  Expression: packed == 0

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 20
  Type: NodeType.RETURN
  Expression: packed

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 25
  Type: NodeType.RETURN
  Expression: packed

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnerQueryForNonexistentToken().selector)

  ID: 29
  Type: NodeType.RETURN
  Expression: packed

Edges:
  0 -> 1
  1 -> 2
  1 -> 27
  2 -> 3
  3 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 23
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 13
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 13
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId,true)

Edges:
  0 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalQueryForNonexistentToken().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _startTokenId() <= tokenId

  ID: 2
  Type: NodeType.IF
  Expression: tokenId > _sequentialUpTo()

  ID: 3
  Type: NodeType.RETURN
  Expression: _packedOwnershipExists(_packedOwnerships[tokenId])

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: tokenId < _currentIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: (packed = _packedOwnerships[tokenId]) == 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_BURNED == 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 12
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 8
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: _packedOwnershipExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = packed & _BITMASK_ADDRESS > packed & _BITMASK_BURNED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS))

  ID: 3
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferFromIncorrectOwner().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 9
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 19
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 23
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 24
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 25
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 26
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 32
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,from,toMasked,tokenId)

  ID: 34
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToZeroAddress().selector)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  16 -> 17
  17 -> 19
  18 -> 17
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  25 -> 26
  25 -> 29
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferToNonERC721ReceiverImplementer().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 9
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 13
  Type: NodeType.VARIABLE
  Expression: tokenId = startTokenId

  ID: 14
  Type: NodeType.IF
  Expression: end - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: ++ tokenId != end

  ID: 19
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 22
  19 -> 20
  20 -> 21
  21 -> 18
  22 -> 23
  23 -> 24

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintZeroQuantity().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintERC2309QuantityExceedsLimit().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.IF
  Expression: startTokenId + quantity - 1 > _sequentialUpTo()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SequentialMintExceedsLimit().selector)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _mintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId <= _sequentialUpTo()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(revert SpotMintTokenIdTooSmall().selector)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnerships[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: _packedOwnershipExists(prevOwnershipPacked)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TokenAlreadyExists().selector)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,tokenId,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_nextInitializedFlag(1) | _nextExtraData(address(0),to,prevOwnershipPacked))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1

  ID: 11
  Type: NodeType.VARIABLE
  Expression: toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _revert(revert MintToZeroAddress().selector)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ++ _spotMinted

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _safeMintSpot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMintSpot(to,tokenId,)

Edges:
  0 -> 1

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: approvalCheck && _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _revert(revert ApprovalCallerNotOwnerNorApproved().selector)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _revert(revert TransferCallerNotOwnerNorApproved().selector)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(revert OwnershipNotInitializedForExtraData().selector)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,errorSelector)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0x00,0x04)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: originalSize = _mintStages.length

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < originalSize

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _mintStages.pop()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < newStages.length

  ID: 12
  Type: NodeType.IF
  Expression: i_scope_0 >= 1

  ID: 13
  Type: NodeType.IF
  Expression: newStages[i_scope_0].startTimeUnixSeconds < newStages[i_scope_0 - 1].endTimeUnixSeconds

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientStageTimeGap()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _assertValidStartAndEndTimestamp(newStages[i_scope_0].startTimeUnixSeconds,newStages[i_scope_0].endTimeUnixSeconds)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _mintStages.push(MintStageInfo({cost:newStages[i_scope_0].cost,walletLimit:newStages[i_scope_0].walletLimit,merkleRoot:newStages[i_scope_0].merkleRoot,maxStageSupply:newStages[i_scope_0].maxStageSupply,startTimeUnixSeconds:newStages[i_scope_0].startTimeUnixSeconds,endTimeUnixSeconds:newStages[i_scope_0].endTimeUnixSeconds}))

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: UpdateStage(i_scope_0,newStages[i_scope_0].cost,newStages[i_scope_0].walletLimit,newStages[i_scope_0].merkleRoot,newStages[i_scope_0].maxStageSupply,newStages[i_scope_0].startTimeUnixSeconds,newStages[i_scope_0].endTimeUnixSeconds)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 21
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 16
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 11
  21 -> 1

Function: getNumberStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _mintStages.length

Edges:
  0 -> 1

Function: getMaxMintableSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _maxMintableSupply

Edges:
  0 -> 1

Function: setMaxMintableSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: maxMintableSupply > _maxMintableSupply

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotIncreaseMaxMintableSupply()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _maxMintableSupply = maxMintableSupply

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetMaxMintableSupply(maxMintableSupply)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: getGlobalWalletLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _globalWalletLimit

Edges:
  0 -> 1

Function: setGlobalWalletLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: globalWalletLimit > _maxMintableSupply

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert GlobalWalletLimitOverflow()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _globalWalletLimit = globalWalletLimit

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetGlobalWalletLimit(globalWalletLimit)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: totalMintedByAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _numberMinted(a)

Edges:
  0 -> 1

Function: getStageInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: index >= _mintStages.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(InvalidStage)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: walletMinted = _stageMintedCountsPerWallet[index][msg.sender]

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stageMinted = _stageMintedCounts[index]

  ID: 6
  Type: NodeType.RETURN
  Expression: (_mintStages[index],walletMinted,stageMinted)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: updateStage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: index >= _mintStages.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStage()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: index >= 1

  ID: 5
  Type: NodeType.IF
  Expression: startTimeUnixSeconds < _mintStages[index - 1].endTimeUnixSeconds

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientStageTimeGap()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _assertValidStartAndEndTimestamp(startTimeUnixSeconds,endTimeUnixSeconds)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].cost = cost

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].walletLimit = walletLimit

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].merkleRoot = merkleRoot

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].maxStageSupply = maxStageSupply

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].startTimeUnixSeconds = startTimeUnixSeconds

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].endTimeUnixSeconds = endTimeUnixSeconds

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UpdateStage(index,cost,walletLimit,merkleRoot,maxStageSupply,startTimeUnixSeconds,endTimeUnixSeconds)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 17
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  17 -> 1

Function: mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _mintInternal(qty,msg.sender,proof)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 2
  2 -> 1

Function: _mintInternal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: stageTimestamp = uint64(block.timestamp)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: activeStage = getActiveStageFromTimestamp(stageTimestamp)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: stage = _mintStages[activeStage]

  ID: 5
  Type: NodeType.IF
  Expression: stage.cost < threshold

  ID: 6
  Type: NodeType.IF
  Expression: msg.value < (stage.cost + min_fee) * qty

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: msg.value < stage.cost * qty

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: stage.maxStageSupply > 0

  ID: 14
  Type: NodeType.IF
  Expression: _stageMintedCounts[activeStage] + qty > stage.maxStageSupply

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert StageSupplyExceeded()()

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: _globalWalletLimit > 0

  ID: 19
  Type: NodeType.IF
  Expression: _numberMinted(to) + qty > _globalWalletLimit

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert WalletGlobalLimitExceeded()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.IF
  Expression: stage.walletLimit > 0

  ID: 24
  Type: NodeType.IF
  Expression: _stageMintedCountsPerWallet[activeStage][to] + qty > stage.walletLimit

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: revert WalletStageLimitExceeded()()

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: stage.merkleRoot != 0

  ID: 29
  Type: NodeType.IF
  Expression: MerkleProof.processProof(proof,keccak256(bytes)(abi.encodePacked(to))) != stage.merkleRoot

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: revert InvalidProof()()

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: _stageMintedCountsPerWallet[activeStage][to] += qty

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: _stageMintedCounts[activeStage] += qty

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,qty)

  ID: 36
  Type: NodeType.IF
  Expression: stage.cost < threshold

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(min_fee * qty)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: address(owner()).transfer(msg.value - (min_fee * qty))

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(msg.value / 66)

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: address(owner()).transfer(msg.value - (msg.value / 66))

  ID: 41
  Type: NodeType.ENDIF
  Expression: 

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: hasSupply(qty)

Edges:
  0 -> 42
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 17
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 22
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 32
  29 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  36 -> 39
  37 -> 38
  38 -> 41
  39 -> 40
  40 -> 41
  42 -> 1

Function: ownerMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value < min_fee * qty

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,qty)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(msg.value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: hasSupply(qty)

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 7
  7 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: value = address(this).balance

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = msg.sender.call{value: value}()

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert WithdrawFailed()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Withdraw(value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  8 -> 1

Function: setBaseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _baseURIPermanent

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdatePermanentBaseURI()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _currentBaseURI = baseURI

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetBaseURI(baseURI)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: setBaseURIPermanent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _baseURIPermanent = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: PermanentBaseURI(_currentBaseURI)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setTokenURISuffix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _tokenURISuffix = suffix

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: getTokenURISuffix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokenURISuffix

Edges:
  0 -> 1

Function: getActiveStageFromTimestamp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < _mintStages.length

  ID: 5
  Type: NodeType.IF
  Expression: timestamp >= _mintStages[i].startTimeUnixSeconds && timestamp < _mintStages[i].endTimeUnixSeconds

  ID: 6
  Type: NodeType.RETURN
  Expression: i

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStage()()

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: _assertValidStartAndEndTimestamp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= end

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStartAndEndTimestamp()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _requireCallerIsContractOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _checkOwner()

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _maxMintableSupply = 10

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _globalWalletLimit = 5

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: lmnft = 0x9E6865DAEeeDD093ea4A4f6c9bFbBB0cE6Bc8b17

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: min_fee = 33000000000000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: threshold = 2000000000000000

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _currentBaseURI = ipfs://QmcEiEocUpvUVioN5nAdGtNZxwv59suMYgpXQneoRWuWk2/

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _tokenURISuffix = .json

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_VALIDATOR = address(0x0000721C310194CcfC01E523fc93C9cCcFa2A0Ac)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_TRANSFER_SECURITY_LEVEL = TransferSecurityLevels.One

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_OPERATOR_WHITELIST_ID = uint120(1)

Edges:
  0 -> 1
  1 -> 2


