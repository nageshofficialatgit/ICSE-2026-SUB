Contract: Errors
==================================================


Contract: Address
==================================================

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(this).balance < amount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Errors.InsufficientBalance(address(this).balance,amount)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = recipient.call{value: amount}()

  ID: 7
  Type: NodeType.IF
  Expression: ! success

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(this).balance < value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Errors.InsufficientBalance(address(this).balance,value)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 7
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! success

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata)

  ID: 3
  Type: NodeType.IF
  Expression: returndata.length == 0 && target.code.length == 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert AddressEmptyCode(address)(target)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: returndata

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! success

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata)

  ID: 3
  Type: NodeType.RETURN
  Expression: returndata

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Errors.FailedCall()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENTERED = 2

Edges:
  0 -> 1


Contract: AutomationCompatibleInterface
==================================================


Contract: AutomationBase
==================================================

Function: _preventExecution
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tx.origin != address(0) && tx.origin != address(0x1111111111111111111111111111111111111111)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OnlySimulatedBackend()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3


Contract: AggregatorV3Interface
==================================================


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Initializable
==================================================

Function: _checkInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _isInitializing()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NotInitializing()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: $ = _getInitializableStorage()

  ID: 2
  Type: NodeType.IF
  Expression: $._initializing

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InvalidInitialization()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: $._initialized != type()(uint64).max

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: $._initialized = type()(uint64).max

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint64).max)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _getInitializableStorage()._initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _getInitializableStorage()._initializing

Edges:
  0 -> 1

Function: _getInitializableStorage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: $ = INITIALIZABLE_STORAGE

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: $

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00

Edges:


Contract: KeeperCompatible
==================================================

Function: _preventExecution
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tx.origin != address(0) && tx.origin != address(0x1111111111111111111111111111111111111111)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OnlySimulatedBackend()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3


Contract: IUniswapV2Router02
==================================================


Contract: IUniswapV2Pair
==================================================


Contract: IERC20
==================================================


Contract: ERC20Detailed
==================================================

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _decimals = decimals_

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _decimals

Edges:
  0 -> 1


Contract: IDogePriceOracle
==================================================


Contract: CollarToken
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_initialSupply > 0,Initial supply must be greater than 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_owners.length >= _required,Owners less than required)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_required > 0,Required must be greater than 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_initialTokenHolder != address(0),Invalid token holder)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ERC20Detailed.initialize(DOGE FATHER,COLLAR,uint8(DECIMALS))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _totalSupply = _initialSupply * 10 ** DECIMALS

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _gonsPerFragment = TOTAL_GONS / _totalSupply

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _gonBalances[_initialTokenHolder] = TOTAL_GONS

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: owners = _owners

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: required = _required

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: priceFeedETH = AggregatorV3Interface(_priceFeedETH)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: priceFeedDOGE = IDogePriceOracle(_priceFeedDOGE)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),_initialTokenHolder,_totalSupply)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: Ownable(address(this))

Edges:
  0 -> 14
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  14 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: _preventExecution
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tx.origin != address(0) && tx.origin != address(0x1111111111111111111111111111111111111111)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OnlySimulatedBackend()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _decimals = decimals_

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _decimals

Edges:
  0 -> 1

Function: isOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 5
  Type: NodeType.IF
  Expression: owners[i] == account

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: createProposal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isOwner(msg.sender),Only owners can create proposals)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: proposalCount ++

  ID: 3
  Type: NodeType.VARIABLE
  Expression: proposal = proposals[proposalCount]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: proposal.action = action

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: proposal.target = target

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: proposal.value = value

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: proposal.data = data

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: proposal.approvalCount = 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: proposal.executed = false

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ProposalCreated(proposalCount,action,target,value,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: approveProposal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isOwner(msg.sender),Only owners can approve)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proposal = proposals[proposalId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(proposal.data.length > 0,Proposal does not exist)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! proposal.approved[msg.sender],Already approved)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: proposal.approved[msg.sender] = true

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: proposal.approvalCount ++

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ProposalApproved(proposalId,msg.sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: executeProposal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: proposal = proposals[proposalId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(proposal.approvalCount >= required,Not enough approvals)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! proposal.executed,Already executed)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: proposal.executed = true

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,None) = proposal.target.call{value: proposal.value}(proposal.data)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Execution failed)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ProposalExecuted(proposalId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: checkUpkeep
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: upkeepNeeded = block.timestamp >= lastRebaseTime + rebaseInterval && (rebaseActive || _shouldActivateRebasing())

  ID: 2
  Type: NodeType.RETURN
  Expression: (upkeepNeeded,)

  ID: 3
  Type: NodeType.RETURN
  Expression: (upkeepNeeded)

Edges:
  0 -> 1
  1 -> 2

Function: performUpkeep
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp >= lastRebaseTime + rebaseInterval,Rebase interval not met)

  ID: 2
  Type: NodeType.IF
  Expression: uniswapPair != address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IUniswapV2Pair(uniswapPair).sync()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: ! rebaseActive

  ID: 6
  Type: NodeType.IF
  Expression: _shouldActivateRebasing()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: rebaseActive = true

  ID: 8
  Type: NodeType.RETURN
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _rebase()

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyKeeper()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 10
  6 -> 7
  6 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  12 -> 13
  13 -> 1

Function: _shouldActivateRebasing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentPrice = getCollarPriceInUSD()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: dogePrice = getDogePrice()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: targetPrice = (dogePrice * targetRatio) / 1e18

  ID: 4
  Type: NodeType.RETURN
  Expression: currentPrice >= targetPrice

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getDogePrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: price = priceFeedDOGE.getPrice()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(price > 0,Invalid DOGE price)

  ID: 3
  Type: NodeType.RETURN
  Expression: price

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getEthPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (None,price,None,updatedAt,None) = priceFeedETH.latestRoundData()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(price > 0,Invalid ETH price)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp - updatedAt < 3600,Stale ETH price)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: feedDecimals = priceFeedETH.decimals()

  ID: 7
  Type: NodeType.RETURN
  Expression: uint256(price) * (10 ** (18 - feedDecimals))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: getCollarPriceFromV2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: uniswapPair == address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: pair = IUniswapV2Pair(uniswapPair)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (reserve0,reserve1,None) = pair.getReserves()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reserve0 > 0 && reserve1 > 0,Insufficient liquidity)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: isCollarToken0 = pair.token0() == address(this)

  ID: 12
  Type: NodeType.RETURN
  Expression: (uint256(tokenReserve) * 1e18) / uint256(collarReserve)

  ID: 13
  Type: NodeType.IF
  Expression: isCollarToken0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: collarReserve = reserve0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: collarReserve = reserve1

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.IF
  Expression: isCollarToken0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenReserve = reserve1

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: tokenReserve = reserve0

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 13
  13 -> 14
  13 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 20
  19 -> 20
  20 -> 12

Function: getCollarPriceInUSD
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: collarPriceInETH = getCollarPriceFromV2()

  ID: 2
  Type: NodeType.IF
  Expression: collarPriceInETH == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: ethPriceInUSD = getEthPrice()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: collarPriceInUSD = (collarPriceInETH * ethPriceInUSD) / 1e18

  ID: 7
  Type: NodeType.RETURN
  Expression: collarPriceInUSD

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: _rebase
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: uniswapPair != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: IUniswapV2Pair(uniswapPair).sync()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: currentPrice = getCollarPriceInUSD()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: dogePrice = getDogePrice()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_totalSupply > 0,Rebase failed: total supply is zero)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: targetPrice = (dogePrice * targetRatio) / 1e18

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(targetPrice > 0,Invalid target price)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentPrice > 0,Invalid current price)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: oldSupply = _totalSupply

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: currentPrice > targetPrice

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: deviation = ((currentPrice - targetPrice) * 1e18) / targetPrice

  ID: 15
  Type: NodeType.IF
  Expression: currentPrice < targetPrice

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: deviation = ((targetPrice - currentPrice) * 1e18) / targetPrice

  ID: 17
  Type: NodeType.RETURN
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.IF
  Expression: deviation < MIN_DEVIATION_THRESHOLD

  ID: 21
  Type: NodeType.RETURN
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: adjustment = (_totalSupply * deviation) / 1e18

  ID: 24
  Type: NodeType.IF
  Expression: currentPrice > targetPrice

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_totalSupply + adjustment >= _totalSupply,Overflow detected)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += adjustment

  ID: 27
  Type: NodeType.IF
  Expression: currentPrice < targetPrice

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(adjustment <= _totalSupply,Underflow detected)

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= adjustment

  ID: 30
  Type: NodeType.RETURN
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: _gonsPerFragment = TOTAL_GONS / _totalSupply

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: lastRebaseTime = block.timestamp

  ID: 35
  Type: NodeType.IF
  Expression: uniswapPair != address(0)

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: IUniswapV2Pair(uniswapPair).sync()

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: Rebase(oldSupply,_totalSupply)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 19
  15 -> 16
  15 -> 17
  16 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  20 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 27
  25 -> 26
  26 -> 32
  27 -> 28
  27 -> 30
  28 -> 29
  29 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 37
  36 -> 37
  37 -> 38

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _gonBalances[account] / _gonsPerFragment

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _allowedFragments[msg.sender][spender] = value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowedFragments[owner_][spender]

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sender != address(0),Transfer from zero address is not allowed)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(recipient != address(0),Transfer to zero address is not allowed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,Transfer amount must be greater than zero)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: gonAmount = amount * _gonsPerFragment

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_gonBalances[sender] >= gonAmount,Insufficient balance)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: currentAllowance = _allowedFragments[sender][msg.sender]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= amount,Transfer amount exceeds allowance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _gonBalances[sender] -= gonAmount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _gonBalances[recipient] += gonAmount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _allowedFragments[sender][msg.sender] -= amount

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Transfer(sender,recipient,amount)

  ID: 12
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(recipient != address(0),Transfer to zero address is not allowed)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: gonAmount = amount * _gonsPerFragment

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_gonBalances[msg.sender] >= gonAmount,Insufficient balance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _gonBalances[msg.sender] -= gonAmount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _gonBalances[recipient] += gonAmount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,recipient,amount)

  ID: 7
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: setUniswapPaireToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_uniswapPair != address(0),Invalid paired token)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: uniswapPair = _uniswapPair

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: UniswapPairUpdated(_uniswapPair)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: addKeeper
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_keeper != address(0),Invalid address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: keepers[_keeper] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: KeeperAdded(_keeper)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: setTargetRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_targetRatio > 0 && _targetRatio < MAX_TARGET_THRESHOLD,Invalid target ratio)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: targetRatio = _targetRatio

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TargetRatioUpdated(_targetRatio)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: removeKeeper
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_keeper != address(0),Invalid address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(keepers[_keeper],Not a keeper)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: keepers[_keeper] = false

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: KeeperRemoved(_keeper)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: setRebaseInterval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rebaseInterval = _interval

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RebaseIntervalUpdated(_interval)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: toggleRebaseActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rebaseActive = _active

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RebaseStateChanged(_active)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setPriceFeedEth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_newPriceFeedETH != address(0),Invalid address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(_newPriceFeedETH),Address is not a contract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: priceFeedETH = AggregatorV3Interface(_newPriceFeedETH)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: PriceFeedEthUpdated(_newPriceFeedETH)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: setPriceFeedDoge
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_newPriceFeedDoge != address(0),Invalid address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(_newPriceFeedDoge),Address is not a contract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: priceFeedDOGE = IDogePriceOracle(_newPriceFeedDoge)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: PriceFeedDogeUpdated(_newPriceFeedDoge)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: codehash = extcodehash(uint256)(account)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (codehash != accountHash && codehash != 0x0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: rebaseInterval = 86400

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: targetRatio = 500000000000000000000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_TARGET_THRESHOLD = 501000000000000000000

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: rebaseActive = false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DECIMALS = 18

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: TOTAL_GONS = type()(uint256).max - (type()(uint256).max % 1e18)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_DEVIATION_THRESHOLD = 1e15

Edges:
  0 -> 1
  1 -> 2


