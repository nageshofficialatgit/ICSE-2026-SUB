Contract: IERC20
==================================================


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.transfer,(to,value)))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.transferFrom,(from,to,value)))

Edges:
  0 -> 1

Function: trySafeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _callOptionalReturnBool(token,abi.encodeCall(token.transfer,(to,value)))

Edges:
  0 -> 1

Function: trySafeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _callOptionalReturnBool(token,abi.encodeCall(token.transferFrom,(from,to,value)))

Edges:
  0 -> 1

Function: safeIncreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: forceApprove(token,spender,oldAllowance + value)

Edges:
  0 -> 1
  1 -> 2

Function: safeDecreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance < requestedDecrease

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedDecreaseAllowance(address,uint256,uint256)(spender,currentAllowance,requestedDecrease)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: forceApprove(token,spender,currentAllowance - requestedDecrease)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: forceApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: approvalCall = abi.encodeCall(token.approve,(spender,value))

  ID: 2
  Type: NodeType.IF
  Expression: ! _callOptionalReturnBool(token,approvalCall)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.approve,(spender,0)))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,approvalCall)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _callOptionalReturn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: success__callOptionalReturn_asm_0 = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data + 0x20,mload(uint256)(data),0,0x20)

  ID: 6
  Type: NodeType.IF
  Expression: ! success__callOptionalReturn_asm_0

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ptr__callOptionalReturn_asm_0 = mload(uint256)(0x40)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: returndatacopy(uint256,uint256,uint256)(ptr__callOptionalReturn_asm_0,0,returndatasize()())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(ptr__callOptionalReturn_asm_0,returndatasize()())

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: returnSize = returndatasize()()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: returnValue = mload(uint256)(0)

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedOperation(address)(address(token))

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: returnSize == 0

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: address(token).code.length == 0

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: returnValue != 1

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  6 -> 7
  7 -> 12
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 7
  12 -> 13
  13 -> 14
  14 -> 18
  16 -> 17
  18 -> 19
  18 -> 20
  19 -> 21
  20 -> 21
  21 -> 16
  21 -> 17

Function: _callOptionalReturnBool
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data + 0x20,mload(uint256)(data),0,0x20)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: returnSize = returndatasize()()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: returnValue = mload(uint256)(0)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: returnSize == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: success && address(token).code.length > 0

  ID: 12
  Type: NodeType.RETURN
  Expression: success && returnValue == 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  10 -> 11
  10 -> 12


Contract: IDEXFactory
==================================================


Contract: IDEXRouter
==================================================


Contract: IDividendDistributor
==================================================


Contract: DividendDistributor
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _token = msg.sender

  ID: 3
  Type: NodeType.IF
  Expression: _router != address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: router = IDEXRouter(_router)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: router = IDEXRouter(routerAddress)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 3
  3 -> 4
  3 -> 5
  4 -> 6
  5 -> 6
  6 -> 2

Function: setDistributionCriteria
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: minPeriod = newMinPeriod

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: minDistribution = newMinDistribution

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyToken()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setShare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: shares[shareholder].amount > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: distributeDividend(shareholder)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: amount > 0 && shares[shareholder].amount == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: addShareholder(shareholder)

  ID: 6
  Type: NodeType.IF
  Expression: amount == 0 && shares[shareholder].amount > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: removeShareholder(shareholder)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: totalShares = (totalShares - shares[shareholder].amount) + amount

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: shares[shareholder].amount = amount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyToken()

Edges:
  0 -> 13
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 9
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  13 -> 1

Function: deposit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balanceBefore = RewardToken.balanceOf(address(this))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path[0] = router.WETH()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: path[1] = address(RewardToken)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(0,path,address(this),block.timestamp)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: amount = RewardToken.balanceOf(address(this)) - balanceBefore

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: totalDividends = totalDividends + amount

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: dividendsPerShare = dividendsPerShare + (dividendsPerShareAccuracyFactor * amount / totalShares)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyToken()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: process
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: shareholderCount = shareholders.length

  ID: 2
  Type: NodeType.IF
  Expression: shareholderCount == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: iterations = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: gasUsed = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: gasLeft = gasleft()()

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: gasUsed < gas && iterations < shareholderCount

  ID: 10
  Type: NodeType.IF
  Expression: currentIndex >= shareholderCount

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: currentIndex = 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: shouldDistribute(shareholders[currentIndex])

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: distributeDividend(shareholders[currentIndex])

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: gasUsed = gasUsed + (gasLeft - gasleft()())

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: gasLeft = gasleft()()

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: currentIndex ++

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: iterations ++

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyToken()

Edges:
  0 -> 21
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 20
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 9
  21 -> 1

Function: shouldDistribute
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: shareholderClaims[shareholder] + minPeriod < block.timestamp && getUnpaidEarnings(shareholder) > minDistribution

Edges:
  0 -> 1

Function: distributeDividend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: shares[shareholder].amount == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amount = getUnpaidEarnings(shareholder)

  ID: 5
  Type: NodeType.IF
  Expression: amount > 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: totalDistributed = totalDistributed + amount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: RewardToken.safeTransfer(shareholder,amount)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: shareholderClaims[shareholder] = block.timestamp

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: claimDividend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(shouldDistribute(msg.sender),Too soon. Need to wait!)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: distributeDividend(msg.sender)

Edges:
  0 -> 1
  1 -> 2

Function: getUnpaidEarnings
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: shares[shareholder].amount == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: shareholderTotalExcluded = shares[shareholder].totalExcluded

  ID: 6
  Type: NodeType.IF
  Expression: shareholderTotalDividends <= shareholderTotalExcluded

  ID: 7
  Type: NodeType.RETURN
  Expression: 0

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.RETURN
  Expression: shareholderTotalDividends - shareholderTotalExcluded

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9

Function: getCumulativeDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: share * dividendsPerShare / dividendsPerShareAccuracyFactor

Edges:
  0 -> 1

Function: addShareholder
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: shareholderIndexes[shareholder] = shareholders.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: shareholders.push(shareholder)

Edges:
  0 -> 1
  1 -> 2

Function: removeShareholder
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: shareholders.pop()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getUserRewardStatus
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (shareholderClaims[userAddress],getUnpaidEarnings(userAddress))

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RewardToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: dividendsPerShareAccuracyFactor = 10 ** 18

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minPeriod = 1800

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minDistribution = 1 * (10 ** 4)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: msgSender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = msgSender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(address(0),msgSender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1


Contract: RICH
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: router = IDEXRouter(routerAddress)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: pair = IDEXFactory(router.factory()).createPair(router.WETH(),address(this))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _allowances[address(this)][address(router)] = type()(uint256).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dividendDistributor = new DividendDistributor(address(router))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: isFeeExempt[msg.sender] = true

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isFeeExempt[address(this)] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: isTxLimitExempt[msg.sender] = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[pair] = true

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[msg.sender] = true

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[address(this)] = true

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[DEAD] = true

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[ZERO] = true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _balances[msg.sender] = _totalSupply

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),msg.sender,_totalSupply)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _decimals

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: getCirculatingSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply - (balanceOf(DEAD) + balanceOf(ZERO))

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[holder][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _allowances[msg.sender][spender] = amount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: approveMax
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: approve(spender,type()(uint256).max)

Edges:
  0 -> 1

Function: changeIsFeeExempt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: isFeeExempt[holder] = exempt

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeIsTxLimitExempt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: isTxLimitExempt[holder] = exempt

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeIsDividendExempt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(holder != address(this) && holder != pair)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: isDividendExempt[holder] = exempt

  ID: 3
  Type: NodeType.IF
  Expression: exempt

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dividendDistributor.setShare(holder,0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dividendDistributor.setShare(holder,_balances[holder])

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 6
  5 -> 6
  7 -> 1

Function: changeSwapSettings
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: swapEnabled = enableSwap

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: swapThreshold = newSwapLimit

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeDistributionCriteria
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: dividendDistributor.setDistributionCriteria(newinPeriod,newMinDistribution)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeDistributorSettings
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(gas < 750000)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: distributorGas = gas

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _transferFrom(msg.sender,recipient,amount)

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _allowances[sender][msg.sender] != type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _transferFrom(sender,recipient,amount)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: inSwap

  ID: 2
  Type: NodeType.RETURN
  Expression: _basicTransfer(sender,recipient,amount)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isTxLimitExempt[sender] || tradingOpen,Trading not open yet)

  ID: 5
  Type: NodeType.IF
  Expression: recipient == pair && ! inSwap && swapEnabled && _balances[address(this)] >= swapThreshold

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: swap()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _balances[sender] = _balances[sender] - amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _balances[recipient] = _balances[recipient] + finalAmount

  ID: 11
  Type: NodeType.IF
  Expression: ! isDividendExempt[sender]

  ID: 12
  Type: NodeType.TRY
  Expression: dividendDistributor.setShare(sender,_balances[sender])

  ID: 13
  Type: NodeType.CATCH
  Expression: 

  ID: 14
  Type: NodeType.CATCH
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: ! isDividendExempt[recipient]

  ID: 17
  Type: NodeType.TRY
  Expression: dividendDistributor.setShare(recipient,_balances[recipient])

  ID: 18
  Type: NodeType.CATCH
  Expression: 

  ID: 19
  Type: NodeType.CATCH
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.TRY
  Expression: dividendDistributor.process(distributorGas)

  ID: 22
  Type: NodeType.CATCH
  Expression: 

  ID: 23
  Type: NodeType.CATCH
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: Transfer(sender,recipient,finalAmount)

  ID: 25
  Type: NodeType.RETURN
  Expression: true

  ID: 26
  Type: NodeType.IF
  Expression: (! isFeeExempt[sender] && ! isFeeExempt[recipient]) && (sender == pair || recipient == pair)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: finalAmount = takeFee(sender,amount)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: finalAmount = amount

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 26
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  12 -> 14
  12 -> 15
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 20
  17 -> 18
  17 -> 19
  17 -> 20
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  21 -> 24
  22 -> 24
  23 -> 24
  24 -> 25
  26 -> 27
  26 -> 28
  27 -> 29
  28 -> 29
  29 -> 10

Function: _basicTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _balances[sender] = _balances[sender] - amount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _balances[recipient] = _balances[recipient] + amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(sender,recipient,amount)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: takeFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: feeAmount = amount * totalFee / 100

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _balances[address(this)] = _balances[address(this)] + feeAmount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(sender,address(this),feeAmount)

  ID: 4
  Type: NodeType.RETURN
  Expression: amount - feeAmount

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: tradingStatus
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tradingOpen = newStatus

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: setMaxThresholdCnt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: maxThresholdCnt = count

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeMarketingWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: marketingAddress = newMarketing

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: swap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: swapThresholdCnt ++

  ID: 2
  Type: NodeType.IF
  Expression: swapThresholdCnt < maxThresholdCnt && _balances[address(this)] < swapThreshold * 10

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: amountToSwap = _balances[address(this)]

  ID: 6
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: path[0] = address(this)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: path[1] = router.WETH()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: router.swapExactTokensForETHSupportingFeeOnTransferTokens(amountToSwap,0,path,address(this),block.timestamp)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amountETH = address(this).balance

  ID: 11
  Type: NodeType.VARIABLE
  Expression: amountETHReflection = amountETH * holdersRewardFee / totalFee

  ID: 12
  Type: NodeType.VARIABLE
  Expression: amountETHMarketing = amountETH - amountETHReflection

  ID: 13
  Type: NodeType.VARIABLE
  Expression: pathM = new address[](2)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: pathM[0] = router.WETH()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: pathM[1] = address(RewardToken)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountETHMarketing}(0,pathM,marketingAddress,block.timestamp)

  ID: 17
  Type: NodeType.TRY
  Expression: dividendDistributor.deposit{value: amountETHReflection}()

  ID: 18
  Type: NodeType.CATCH
  Expression: 

  ID: 19
  Type: NodeType.CATCH
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: swapThresholdCnt = 0

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: lockTheSwap()

Edges:
  0 -> 21
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  17 -> 20
  18 -> 20
  19 -> 20
  21 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEAD = 0x000000000000000000000000000000000000dEaD

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ZERO = 0x0000000000000000000000000000000000000000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RewardToken = 0xdAC17F958D2ee523a2206206994597C13D831ec7

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: marketingAddress = 0x47656Bb850A38d0F9E945Ea519a8f7711E0D06F6

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _totalSupply = 250_000_000 * (10 ** _decimals)

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: marketingFee = 1

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: holdersRewardFee = 2

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalFee = 3

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tradingOpen = false

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: distributorGas = 500000

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: swapEnabled = true

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: swapThreshold = _totalSupply / 100000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: swapThresholdCnt = 0

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxThresholdCnt = 4

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _name = RICH

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _symbol = RICH

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _decimals = 18

Edges:
  0 -> 1
  1 -> 2


