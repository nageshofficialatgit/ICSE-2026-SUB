Contract: OraclizeI
==================================================


Contract: OraclizeAddrResolverI
==================================================


Contract: usingOraclize
==================================================

Function: oraclize_setNetwork
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_mainnet)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_ropsten3)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_kovan)

  ID: 14
  Type: NodeType.RETURN
  Expression: true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_rinkeby)

  ID: 19
  Type: NodeType.RETURN
  Expression: true

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)

  ID: 23
  Type: NodeType.RETURN
  Expression: true

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)

  ID: 27
  Type: NodeType.RETURN
  Expression: true

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)

  ID: 31
  Type: NodeType.RETURN
  Expression: true

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  15 -> 16
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  24 -> 25
  25 -> 26
  25 -> 28
  26 -> 27
  28 -> 29
  29 -> 30
  29 -> 32
  30 -> 31
  32 -> 33

Function: __callback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: myid

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: proof

Edges:
  0 -> 1
  2 -> 3
  3 -> 4

Function: oraclize_getPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.getPrice(datasource,gaslimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_query
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: dynargs = new bytes[](5)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dynargs[0] = args[0]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dynargs[1] = args[1]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dynargs[2] = args[2]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dynargs[3] = args[3]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dynargs[4] = args[4]

  ID: 7
  Type: NodeType.RETURN
  Expression: oraclize_query(datasource,dynargs,gaslimit)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

  ID: 9
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: oraclize_cbAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.cbAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setProofType(proofP)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setCustomGasPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setCustomGasPrice(gasPrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_randomDS_getSessionPubKeyHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.randomDS_getSessionPubKeyHash()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: getCodeSize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: _size

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: parseAddr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tmp = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: iaddr = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 2

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < 2 + 2 * 20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: iaddr *= 256

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: b1 = uint160(tmp[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: b2 = uint160(tmp[i + 1])

  ID: 12
  Type: NodeType.IF
  Expression: (b1 >= 97) && (b1 <= 102)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b1 -= 87

  ID: 14
  Type: NodeType.IF
  Expression: (b1 >= 65) && (b1 <= 70)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: b1 -= 55

  ID: 16
  Type: NodeType.IF
  Expression: (b1 >= 48) && (b1 <= 57)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b1 -= 48

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: (b2 >= 97) && (b2 <= 102)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: b2 -= 87

  ID: 23
  Type: NodeType.IF
  Expression: (b2 >= 65) && (b2 <= 70)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: b2 -= 55

  ID: 25
  Type: NodeType.IF
  Expression: (b2 >= 48) && (b2 <= 57)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: b2 -= 48

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: iaddr += (b1 * 16 + b2)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 32
  Type: NodeType.RETURN
  Expression: address(iaddr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 32
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 20
  14 -> 15
  14 -> 16
  15 -> 19
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 29
  23 -> 24
  23 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 8

Function: strCompare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: a = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: b = bytes(_b)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: minLength = a.length

  ID: 4
  Type: NodeType.IF
  Expression: b.length < minLength

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: minLength = b.length

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < minLength

  ID: 11
  Type: NodeType.IF
  Expression: a[i] < b[i]

  ID: 12
  Type: NodeType.RETURN
  Expression: - 1

  ID: 13
  Type: NodeType.IF
  Expression: a[i] > b[i]

  ID: 14
  Type: NodeType.RETURN
  Expression: 1

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: a.length < b.length

  ID: 19
  Type: NodeType.RETURN
  Expression: - 1

  ID: 20
  Type: NodeType.IF
  Expression: a.length > b.length

  ID: 21
  Type: NodeType.RETURN
  Expression: 1

  ID: 22
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 18
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  17 -> 10
  18 -> 19
  18 -> 20
  20 -> 21
  20 -> 22

Function: indexOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: h = bytes(_haystack)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: n = bytes(_needle)

  ID: 3
  Type: NodeType.IF
  Expression: h.length < 1 || n.length < 1 || (n.length > h.length)

  ID: 4
  Type: NodeType.RETURN
  Expression: - 1

  ID: 5
  Type: NodeType.IF
  Expression: h.length > (2 ** 128 - 1)

  ID: 6
  Type: NodeType.RETURN
  Expression: - 1

  ID: 7
  Type: NodeType.VARIABLE
  Expression: subindex = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < h.length

  ID: 12
  Type: NodeType.IF
  Expression: h[i] == n[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: subindex = 1

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: subindex ++

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: subindex == n.length

  ID: 19
  Type: NodeType.RETURN
  Expression: int256(i)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.RETURN
  Expression: - 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 10
  8 -> 11
  9 -> 23
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 21
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 15
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 11

Function: strConcat
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: strConcat(_a,_b,,,)

Edges:
  0 -> 1

Function: parseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bresult = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: mint = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: decimals = false

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < bresult.length

  ID: 8
  Type: NodeType.IF
  Expression: (bresult[i] >= 48) && (bresult[i] <= 57)

  ID: 9
  Type: NodeType.IF
  Expression: decimals

  ID: 10
  Type: NodeType.IF
  Expression: _b == 0

  ID: 11
  Type: NodeType.BREAK
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _b --

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mint *= 10

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mint += uint256(bresult[i]) - 48

  ID: 17
  Type: NodeType.IF
  Expression: bresult[i] == 46

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: decimals = true

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 22
  Type: NodeType.IF
  Expression: _b > 0

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mint *= 10 ** _b

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: mint

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 22
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 17
  9 -> 10
  9 -> 14
  10 -> 11
  10 -> 12
  11 -> 5
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 7
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25

Function: uint2str
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: i == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = i

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: j != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: j /= 10

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: bstr = new bytes(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: k = len - 1

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bstr[k --] = bytes1(48 + i % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i /= 10

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: string(bstr)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: stra2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: ba2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: oraclize_setNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_network_name = _network_name

Edges:
  0 -> 1

Function: oraclize_getNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize_network_name

Edges:
  0 -> 1

Function: oraclize_newRandomDSQuery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((_nbytes > 0) && (_nbytes <= 32))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: nbytes = new bytes(1)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: nbytes[0] = bytes1(_nbytes)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: unonce = new bytes(32)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash()

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: args = (unonce,nbytes,sessionKeyHash)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: queryId = oraclize_query(_delay,random,args,_customGasLimit)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_setCommitment(queryId,keccak256()(bytes8(_delay),args[1],sha256()(args[0]),args[2]))

  ID: 12
  Type: NodeType.RETURN
  Expression: queryId

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: oraclize_randomDS_setCommitment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_args[queryId] = commitment

Edges:
  0 -> 1

Function: verifySig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sigr_ = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: offset = 4 + (uint256(dersig[3]) - 0x20)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sigr_ = copyBytes(dersig,offset,32,sigr_,0)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sigs_ = new bytes(32)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: offset += 32 + 2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sigs_ = copyBytes(dersig,offset + (uint256(dersig[offset - 1]) - 0x20),32,sigs_,0)

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,27,sigr,sigs)

  ID: 14
  Type: NodeType.IF
  Expression: address(keccak256()(pubkey)) == signer

  ID: 15
  Type: NodeType.RETURN
  Expression: true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,28,sigr,sigs)

  ID: 17
  Type: NodeType.RETURN
  Expression: (address(keccak256()(pubkey)) == signer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: oraclize_randomDS_proofVerify__sessionKeyValidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sig2 = new bytes(uint256(proof[sig2offset + 1]) + 2)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset,sig2.length,sig2,0)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: appkey1_pubkey = new bytes(64)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 1,64,appkey1_pubkey,0)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: tosign2 = new bytes(1 + 65 + 32)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tosign2[0] = bytes1(1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 65,65,tosign2,1)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: CODEHASH = 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(CODEHASH,0,32,tosign2,1 + 65)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign2),sig2,appkey1_pubkey)

  ID: 12
  Type: NodeType.IF
  Expression: sigok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: LEDGERKEY = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4

  ID: 16
  Type: NodeType.VARIABLE
  Expression: tosign3 = new bytes(1 + 65)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: tosign3[0] = 0xFE

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3,65,tosign3,1)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: sig3 = new bytes(uint256(proof[3 + 65 + 1]) + 2)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 65,sig3.length,sig3,0)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign3),sig3,LEDGERKEY)

  ID: 22
  Type: NodeType.RETURN
  Expression: sigok

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: oraclize_randomDS_proofVerify__returnCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_proof[0] != L) || (_proof[1] != P) || (_proof[2] != 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: 1

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: proofVerified = oraclize_randomDS_proofVerify__main(_proof,_queryId,bytes(_result),oraclize_getNetworkName())

  ID: 5
  Type: NodeType.IF
  Expression: proofVerified == false

  ID: 6
  Type: NodeType.RETURN
  Expression: 2

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: matchBytes32Prefix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: match_ = true

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < n_random_bytes

  ID: 6
  Type: NodeType.IF
  Expression: content[i] != prefix[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: match_ = false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: match_

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5

Function: oraclize_randomDS_proofVerify__main
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ledgerProofLength = 3 + 65 + (uint256(proof[3 + 65 + 1]) + 2) + 32

  ID: 2
  Type: NodeType.VARIABLE
  Expression: keyhash = new bytes(32)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32,keyhash,0)

  ID: 4
  Type: NodeType.IF
  Expression: ! (keccak256()(keyhash) == keccak256()(sha256()(context_name,queryId)))

  ID: 5
  Type: NodeType.RETURN
  Expression: false

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: sig1 = new bytes(uint256(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + (32 + 8 + 1 + 32),sig1.length,sig1,0)

  ID: 9
  Type: NodeType.IF
  Expression: ! matchBytes32Prefix(sha256()(sig1),result,uint256(proof[ledgerProofLength + 32 + 8]))

  ID: 10
  Type: NodeType.RETURN
  Expression: false

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: commitmentSlice1 = new bytes(8 + 1 + 32)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + 32,8 + 1 + 32,commitmentSlice1,0)

  ID: 14
  Type: NodeType.VARIABLE
  Expression: sessionPubkey = new bytes(64)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 64,64,sessionPubkey,0)

  ID: 17
  Type: NodeType.VARIABLE
  Expression: sessionPubkeyHash = sha256()(sessionPubkey)

  ID: 18
  Type: NodeType.IF
  Expression: oraclize_randomDS_args[queryId] == keccak256()(commitmentSlice1,sessionPubkeyHash)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: delete oraclize_randomDS_args[queryId]

  ID: 20
  Type: NodeType.RETURN
  Expression: false

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.VARIABLE
  Expression: tosign1 = new bytes(32 + 8 + 1 + 32)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32 + 8 + 1 + 32,tosign1,0)

  ID: 24
  Type: NodeType.IF
  Expression: ! verifySig(sha256()(tosign1),sig1,sessionPubkey)

  ID: 25
  Type: NodeType.RETURN
  Expression: false

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.IF
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof,sig2offset)

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.RETURN
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  27 -> 29
  28 -> 29
  29 -> 30

Function: copyBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: minLength = length + toOffset

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(to.length >= minLength)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 32 + fromOffset

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = 32 + toOffset

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < (32 + fromOffset + length)

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i += 32

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: j += 32

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: to

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 11
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 6
  11 -> 12

Function: safer_ecrecover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (ret,addr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: ecrecovery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: sig.length != 65

  ID: 5
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: v < 27

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: v += 27

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: v != 27 && v != 28

  ID: 13
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: safer_ecrecover(hash,v,r,s)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: day = 60 * 60 * 24

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: week = 60 * 60 * 24 * 7

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: month = 60 * 60 * 24 * 30

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_NONE = 0x00

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_TLSNotary = 0x10

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Android = 0x20

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Ledger = 0x30

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Native = 0xF0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofStorage_IPFS = 0x01

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_auto = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_mainnet = 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_testnet = 2

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_morden = 2

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_consensys = 161

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13


Contract: CoinInterface
==================================================


Contract: SweepsToken
==================================================

Function: SweepsToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tokBalance[owner] = _totalSupply

Edges:
  0 -> 1
  1 -> 2

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: tokBalance[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.sender == owner)

  ID: 2
  Type: NodeType.IF
  Expression: tokBalance[msg.sender] >= _amount && _amount > 0 && tokBalance[_to] + _amount > tokBalance[_to]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: tokBalance[msg.sender] -= _amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: tokBalance[_to] += _amount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_amount)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  5 -> 6

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _totalSupply = 4000000

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = SWEEP

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Ethereum Sweepstakes SWEEP Token

Edges:
  0 -> 1


Contract: EthereumSweepstakes
==================================================

Function: oraclize_setNetwork
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_mainnet)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_ropsten3)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_kovan)

  ID: 14
  Type: NodeType.RETURN
  Expression: true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_rinkeby)

  ID: 19
  Type: NodeType.RETURN
  Expression: true

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)

  ID: 23
  Type: NodeType.RETURN
  Expression: true

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)

  ID: 27
  Type: NodeType.RETURN
  Expression: true

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)

  ID: 31
  Type: NodeType.RETURN
  Expression: true

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  15 -> 16
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  24 -> 25
  25 -> 26
  25 -> 28
  26 -> 27
  28 -> 29
  29 -> 30
  29 -> 32
  30 -> 31
  32 -> 33

Function: __callback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.sender != oraclize_cbAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: oraclize_randomDS_proofVerify__returnCode(_queryId,_result,_proof) != 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: randomNumber = uint256(block.blockhash(block.number - 1))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: randomNumber = uint256(keccak256()(_result))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: sweepsState == SweepsStates.DRAWING_WINNER

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold >= 1)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.DRAWING_SECONDARY_WINNERS

  ID: 11
  Type: NodeType.VARIABLE
  Expression: rand = randomNumber % numTokensSold

  ID: 12
  Type: NodeType.VARIABLE
  Expression: endIndex = numTokensSold - 1

  ID: 13
  Type: NodeType.VARIABLE
  Expression: primaryWinner = drawPool[rand]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: drawPool[rand] = drawPool[endIndex]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: delete drawPool[endIndex]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: -- numTokensSold

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: winner_announced(primaryWinner,jackpots.primaryJackpot)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: primaryWinner.transfer(jackpots.primaryJackpot)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 19
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: oraclize_getPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.getPrice(datasource,gaslimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_query
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: dynargs = new bytes[](5)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dynargs[0] = args[0]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dynargs[1] = args[1]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dynargs[2] = args[2]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dynargs[3] = args[3]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dynargs[4] = args[4]

  ID: 7
  Type: NodeType.RETURN
  Expression: oraclize_query(datasource,dynargs,gaslimit)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

  ID: 9
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: oraclize_cbAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.cbAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setProofType(proofP)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setCustomGasPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setCustomGasPrice(gasPrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_randomDS_getSessionPubKeyHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.randomDS_getSessionPubKeyHash()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: getCodeSize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: _size

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: parseAddr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tmp = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: iaddr = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 2

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < 2 + 2 * 20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: iaddr *= 256

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: b1 = uint160(tmp[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: b2 = uint160(tmp[i + 1])

  ID: 12
  Type: NodeType.IF
  Expression: (b1 >= 97) && (b1 <= 102)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b1 -= 87

  ID: 14
  Type: NodeType.IF
  Expression: (b1 >= 65) && (b1 <= 70)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: b1 -= 55

  ID: 16
  Type: NodeType.IF
  Expression: (b1 >= 48) && (b1 <= 57)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b1 -= 48

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: (b2 >= 97) && (b2 <= 102)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: b2 -= 87

  ID: 23
  Type: NodeType.IF
  Expression: (b2 >= 65) && (b2 <= 70)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: b2 -= 55

  ID: 25
  Type: NodeType.IF
  Expression: (b2 >= 48) && (b2 <= 57)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: b2 -= 48

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: iaddr += (b1 * 16 + b2)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 32
  Type: NodeType.RETURN
  Expression: address(iaddr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 32
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 20
  14 -> 15
  14 -> 16
  15 -> 19
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 29
  23 -> 24
  23 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 8

Function: strCompare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: a = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: b = bytes(_b)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: minLength = a.length

  ID: 4
  Type: NodeType.IF
  Expression: b.length < minLength

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: minLength = b.length

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < minLength

  ID: 11
  Type: NodeType.IF
  Expression: a[i] < b[i]

  ID: 12
  Type: NodeType.RETURN
  Expression: - 1

  ID: 13
  Type: NodeType.IF
  Expression: a[i] > b[i]

  ID: 14
  Type: NodeType.RETURN
  Expression: 1

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: a.length < b.length

  ID: 19
  Type: NodeType.RETURN
  Expression: - 1

  ID: 20
  Type: NodeType.IF
  Expression: a.length > b.length

  ID: 21
  Type: NodeType.RETURN
  Expression: 1

  ID: 22
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 18
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  17 -> 10
  18 -> 19
  18 -> 20
  20 -> 21
  20 -> 22

Function: indexOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: h = bytes(_haystack)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: n = bytes(_needle)

  ID: 3
  Type: NodeType.IF
  Expression: h.length < 1 || n.length < 1 || (n.length > h.length)

  ID: 4
  Type: NodeType.RETURN
  Expression: - 1

  ID: 5
  Type: NodeType.IF
  Expression: h.length > (2 ** 128 - 1)

  ID: 6
  Type: NodeType.RETURN
  Expression: - 1

  ID: 7
  Type: NodeType.VARIABLE
  Expression: subindex = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < h.length

  ID: 12
  Type: NodeType.IF
  Expression: h[i] == n[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: subindex = 1

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: subindex ++

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: subindex == n.length

  ID: 19
  Type: NodeType.RETURN
  Expression: int256(i)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.RETURN
  Expression: - 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 10
  8 -> 11
  9 -> 23
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 21
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 15
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 11

Function: strConcat
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: strConcat(_a,_b,,,)

Edges:
  0 -> 1

Function: parseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bresult = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: mint = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: decimals = false

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < bresult.length

  ID: 8
  Type: NodeType.IF
  Expression: (bresult[i] >= 48) && (bresult[i] <= 57)

  ID: 9
  Type: NodeType.IF
  Expression: decimals

  ID: 10
  Type: NodeType.IF
  Expression: _b == 0

  ID: 11
  Type: NodeType.BREAK
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _b --

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mint *= 10

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mint += uint256(bresult[i]) - 48

  ID: 17
  Type: NodeType.IF
  Expression: bresult[i] == 46

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: decimals = true

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 22
  Type: NodeType.IF
  Expression: _b > 0

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mint *= 10 ** _b

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: mint

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 22
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 17
  9 -> 10
  9 -> 14
  10 -> 11
  10 -> 12
  11 -> 5
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 7
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25

Function: uint2str
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: i == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = i

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: j != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: j /= 10

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: bstr = new bytes(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: k = len - 1

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bstr[k --] = bytes1(48 + i % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i /= 10

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: string(bstr)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: stra2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: ba2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: oraclize_setNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_network_name = _network_name

Edges:
  0 -> 1

Function: oraclize_getNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize_network_name

Edges:
  0 -> 1

Function: oraclize_newRandomDSQuery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((_nbytes > 0) && (_nbytes <= 32))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: nbytes = new bytes(1)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: nbytes[0] = bytes1(_nbytes)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: unonce = new bytes(32)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash()

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: args = (unonce,nbytes,sessionKeyHash)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: queryId = oraclize_query(_delay,random,args,_customGasLimit)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_setCommitment(queryId,keccak256()(bytes8(_delay),args[1],sha256()(args[0]),args[2]))

  ID: 12
  Type: NodeType.RETURN
  Expression: queryId

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: oraclize_randomDS_setCommitment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_args[queryId] = commitment

Edges:
  0 -> 1

Function: verifySig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sigr_ = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: offset = 4 + (uint256(dersig[3]) - 0x20)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sigr_ = copyBytes(dersig,offset,32,sigr_,0)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sigs_ = new bytes(32)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: offset += 32 + 2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sigs_ = copyBytes(dersig,offset + (uint256(dersig[offset - 1]) - 0x20),32,sigs_,0)

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,27,sigr,sigs)

  ID: 14
  Type: NodeType.IF
  Expression: address(keccak256()(pubkey)) == signer

  ID: 15
  Type: NodeType.RETURN
  Expression: true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,28,sigr,sigs)

  ID: 17
  Type: NodeType.RETURN
  Expression: (address(keccak256()(pubkey)) == signer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: oraclize_randomDS_proofVerify__sessionKeyValidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sig2 = new bytes(uint256(proof[sig2offset + 1]) + 2)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset,sig2.length,sig2,0)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: appkey1_pubkey = new bytes(64)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 1,64,appkey1_pubkey,0)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: tosign2 = new bytes(1 + 65 + 32)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tosign2[0] = bytes1(1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 65,65,tosign2,1)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: CODEHASH = 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(CODEHASH,0,32,tosign2,1 + 65)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign2),sig2,appkey1_pubkey)

  ID: 12
  Type: NodeType.IF
  Expression: sigok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: LEDGERKEY = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4

  ID: 16
  Type: NodeType.VARIABLE
  Expression: tosign3 = new bytes(1 + 65)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: tosign3[0] = 0xFE

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3,65,tosign3,1)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: sig3 = new bytes(uint256(proof[3 + 65 + 1]) + 2)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 65,sig3.length,sig3,0)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign3),sig3,LEDGERKEY)

  ID: 22
  Type: NodeType.RETURN
  Expression: sigok

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: oraclize_randomDS_proofVerify__returnCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_proof[0] != L) || (_proof[1] != P) || (_proof[2] != 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: 1

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: proofVerified = oraclize_randomDS_proofVerify__main(_proof,_queryId,bytes(_result),oraclize_getNetworkName())

  ID: 5
  Type: NodeType.IF
  Expression: proofVerified == false

  ID: 6
  Type: NodeType.RETURN
  Expression: 2

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: matchBytes32Prefix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: match_ = true

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < n_random_bytes

  ID: 6
  Type: NodeType.IF
  Expression: content[i] != prefix[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: match_ = false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: match_

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5

Function: oraclize_randomDS_proofVerify__main
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ledgerProofLength = 3 + 65 + (uint256(proof[3 + 65 + 1]) + 2) + 32

  ID: 2
  Type: NodeType.VARIABLE
  Expression: keyhash = new bytes(32)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32,keyhash,0)

  ID: 4
  Type: NodeType.IF
  Expression: ! (keccak256()(keyhash) == keccak256()(sha256()(context_name,queryId)))

  ID: 5
  Type: NodeType.RETURN
  Expression: false

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: sig1 = new bytes(uint256(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + (32 + 8 + 1 + 32),sig1.length,sig1,0)

  ID: 9
  Type: NodeType.IF
  Expression: ! matchBytes32Prefix(sha256()(sig1),result,uint256(proof[ledgerProofLength + 32 + 8]))

  ID: 10
  Type: NodeType.RETURN
  Expression: false

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: commitmentSlice1 = new bytes(8 + 1 + 32)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + 32,8 + 1 + 32,commitmentSlice1,0)

  ID: 14
  Type: NodeType.VARIABLE
  Expression: sessionPubkey = new bytes(64)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 64,64,sessionPubkey,0)

  ID: 17
  Type: NodeType.VARIABLE
  Expression: sessionPubkeyHash = sha256()(sessionPubkey)

  ID: 18
  Type: NodeType.IF
  Expression: oraclize_randomDS_args[queryId] == keccak256()(commitmentSlice1,sessionPubkeyHash)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: delete oraclize_randomDS_args[queryId]

  ID: 20
  Type: NodeType.RETURN
  Expression: false

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.VARIABLE
  Expression: tosign1 = new bytes(32 + 8 + 1 + 32)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32 + 8 + 1 + 32,tosign1,0)

  ID: 24
  Type: NodeType.IF
  Expression: ! verifySig(sha256()(tosign1),sig1,sessionPubkey)

  ID: 25
  Type: NodeType.RETURN
  Expression: false

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.IF
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof,sig2offset)

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.RETURN
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  27 -> 29
  28 -> 29
  29 -> 30

Function: copyBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: minLength = length + toOffset

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(to.length >= minLength)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 32 + fromOffset

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = 32 + toOffset

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < (32 + fromOffset + length)

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i += 32

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: j += 32

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: to

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 11
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 6
  11 -> 12

Function: safer_ecrecover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (ret,addr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: ecrecovery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: sig.length != 65

  ID: 5
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: v < 27

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: v += 27

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: v != 27 && v != 28

  ID: 13
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: safer_ecrecover(hash,v,r,s)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15

Function: EthereumSweepstakes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: numTokensSold = 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.OPEN

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: sweepsToken = new SweepsToken()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sweepsCreationTime = now

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: management
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(withdrawamount > 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(withdrawamount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: withdrawamount = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: min
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: calculateJackpots
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: jackpots.primaryJackpot = ((numTokensSold * 375 * 10 ** 18) / 1000)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: jackpots.secondJackPot = ((numTokensSold * 375 * 10 ** 18) / 100000)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: jackpots.tertiaryAJackPot = ((numTokensSold * 375 * 10 ** 18) / 1000000)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: jackpots.tertiaryBJackPot = ((numTokensSold * 375 * 10 ** 18) / 10000000)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: jackpots.tertiaryCJackPot = ((numTokensSold * 375 * 10 ** 18) / 100000000)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: jackpots.tertiaryDJackPot = ((numTokensSold * 375 * 10 ** 18) / 1000000000)

  ID: 12
  Type: NodeType.IF
  Expression: numTokensSold > 1

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: jackpots.numSecondaryWinners = min(10,(numTokensSold - 1))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: jackpots.numSecondaryWinners = min(10,0)

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: numTokensSold > 11

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryAWinners = min(100,(numTokensSold - 11))

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryAWinners = min(100,0)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.IF
  Expression: numTokensSold > 111

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryBWinners = min(1000,(numTokensSold - 111))

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryBWinners = min(1000,0)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: numTokensSold > 1111

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryCWinners = min(10000,(numTokensSold - 1111))

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryCWinners = min(10000,0)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: numTokensSold > 11111

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryDWinners = min(100000,(numTokensSold - 11111))

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: jackpots.numTertiaryDWinners = min(100000,0)

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 12
  12 -> 13
  12 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  20 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31

Function: buyTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold < max_tickets)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokensBought = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: etherReceived = msg.value / (10 ** 18)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tokensRemaining = sweepsToken.balanceOf(this)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(tokensRemaining > 0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool)(etherReceived <= 10)

  ID: 7
  Type: NodeType.IF
  Expression: tokensRemaining >= etherReceived

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokensBought = etherReceived

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tokensRemaining -= etherReceived

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: tokensBought = tokensRemaining

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: tokensRemaining = 0

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: i < tokensBought

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: drawPool.push(msg.sender)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: numTokensSold ++

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: tickets_bought(Payment received; Sweeps tokens sent,tokensBought)

  ID: 21
  Type: NodeType.IF
  Expression: tokensRemaining <= 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.CLOSED

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: withdrawamount += ((tokensBought * 10 ** 18) * 40) / 100

  ID: 25
  Type: NodeType.IF
  Expression: sweepsToken.transfer(msg.sender,tokensBought) == false

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: revert()()

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.RETURN
  Expression: true

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: StateTransitions()

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.OPEN)

  ID: 31
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 29
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 12
  10 -> 11
  11 -> 12
  12 -> 15
  13 -> 16
  14 -> 20
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 18
  18 -> 19
  19 -> 16
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  29 -> 30
  30 -> 1

Function: updateRandomNumber
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: N = numBytes

  ID: 2
  Type: NodeType.VARIABLE
  Expression: delay = 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_newRandomDSQuery(delay,N,callBackGas)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: closeOutSweeps
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: calculateJackpots()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclize_setProof(proofType_Ledger)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: updateRandomNumber(32,1000000)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: StateTransitions()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_WINNER)

  ID: 8
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  7 -> 1

Function: drawWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numWinners > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: rand = randomNumber ^ uint256(block.blockhash(block.number - 1))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: winnerAddresses = new address[](numWinners)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: bitMask = uint256(0x3FFFFF)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: endIndex = numTokensSold - 1

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: j < numWinners

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: winnerIndex = uint256(rand & bitMask) % numTokensSold

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: rand >>= shift

  ID: 13
  Type: NodeType.IF
  Expression: j > 255

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: rand ^= (rand << 104)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: rand ^= (rand >> 136)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: rand ^= (rand << 40)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: rand = (rand ^ uint256(block.blockhash(block.number - 1)))

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: winnerAddresses[j] = drawPool[winnerIndex]

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: drawPool[winnerIndex] = drawPool[endIndex]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: delete drawPool[endIndex]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: -- endIndex

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: -- numTokensSold

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 25
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 26
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: j = 0

  ID: 28
  Type: NodeType.IFLOOP
  Expression: j < numWinners

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: winner_announced(winnerAddresses[j],jackpot)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: winnerAddresses[j].transfer(jackpot)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

Edges:
  0 -> 32
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 27
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 10
  25 -> 28
  27 -> 25
  28 -> 29
  28 -> 26
  29 -> 30
  30 -> 31
  31 -> 28
  32 -> 1

Function: drawSecondaryWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold > 1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.DRAWING_TERTIARY_A_WINNERS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: drawWinners(jackpots.numSecondaryWinners,jackpots.secondJackPot,22)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_SECONDARY_WINNERS)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 5
  5 -> 1

Function: drawTertiaryAWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold > 1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numToProcess > 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: numWinnersToProcess = min(numToProcess,jackpots.numTertiaryAWinners - numTertiaryAWinnersPaidOut)

  ID: 4
  Type: NodeType.IF
  Expression: numWinnersToProcess < numToProcess

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.DRAWING_TERTIARY_B_WINNERS

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: numTertiaryAWinnersPaidOut += numWinnersToProcess

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: drawWinners(jackpots.numTertiaryAWinners,jackpots.tertiaryAJackPot,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_TERTIARY_A_WINNERS)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 1

Function: drawTertiaryBWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold > 1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numToProcess > 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: numWinnersToProcess = min(numToProcess,jackpots.numTertiaryBWinners - numTertiaryBWinnersPaidOut)

  ID: 4
  Type: NodeType.IF
  Expression: numWinnersToProcess < numToProcess

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.DRAWING_TERTIARY_C_WINNERS

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: numTertiaryBWinnersPaidOut += numWinnersToProcess

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: drawWinners(numWinnersToProcess,jackpots.tertiaryBJackPot,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_TERTIARY_B_WINNERS)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 1

Function: drawTertiaryCWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold > 1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numToProcess > 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: numWinnersToProcess = min(numToProcess,jackpots.numTertiaryCWinners - numTertiaryCWinnersPaidOut)

  ID: 4
  Type: NodeType.IF
  Expression: numWinnersToProcess < numToProcess

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.DRAWING_TERTIARY_D_WINNERS

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: numTertiaryCWinnersPaidOut += numWinnersToProcess

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: drawWinners(numWinnersToProcess,jackpots.tertiaryCJackPot,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_TERTIARY_C_WINNERS)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 1

Function: drawTertiaryDWinners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numTokensSold > 1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(numToProcess > 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: numWinnersToProcess = min(numToProcess,jackpots.numTertiaryDWinners - numTertiaryDWinnersPaidOut)

  ID: 4
  Type: NodeType.IF
  Expression: numWinnersToProcess < numToProcess

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sweepsState = SweepsStates.WINNERS_PAID_SWEEPS_COMPLETE

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: numTertiaryDWinnersPaidOut += numWinnersToProcess

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: drawWinners(numWinnersToProcess,jackpots.tertiaryDJackPot,1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: atState(SweepsStates.DRAWING_TERTIARY_D_WINNERS)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 1

Function: Fund_Contract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: buyTokens()

Edges:
  0 -> 1

Function: cleanUp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(sweepsState > SweepsStates.DRAWING_WINNER)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: selfdestruct(address)(owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyBy(owner)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: day = 60 * 60 * 24

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: week = 60 * 60 * 24 * 7

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: month = 60 * 60 * 24 * 30

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_NONE = 0x00

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_TLSNotary = 0x10

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Android = 0x20

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Ledger = 0x30

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Native = 0xF0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofStorage_IPFS = 0x01

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_auto = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_mainnet = 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_testnet = 2

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_morden = 2

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_consensys = 161

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Ethereum Sweepstakes

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: max_tickets = 4000000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15


