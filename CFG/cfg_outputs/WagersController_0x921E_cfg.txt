Contract: IERC20
==================================================


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: WagersController
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: feeWallet = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Ownable(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Ownable(_msgSender())

Edges:
  0 -> 3
  2 -> 1
  3 -> 2

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: setNativeToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(nativeToken_) != address(0),Wrong token address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: nativeToken = nativeToken_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setNonNativeTokenFeePercent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feePercent <= FEE_PARTS,Fee cannot be bigger than 100%!)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: nonNativeTokenFeePercent = feePercent

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setFeeWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(feeWallet_) != address(0),Wrong wallet address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: feeWallet = feeWallet_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: createWager
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_wager.eventStartTime == 0,Wager has already created!)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(eventStartTime > block.timestamp,The event should start in the future!)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(participants.length >= 2,There must be at least 2 participants!)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _wager.eventName = eventName

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _wager.eventStartTime = eventStartTime

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < participants.length

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _wager.participants.push(participants[i])

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: WagerCreated(eventId,eventName)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 14
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 13
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 10
  14 -> 1

Function: wager
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[wagerId]

  ID: 2
  Type: NodeType.RETURN
  Expression: (_wager.eventName,_wager.eventStartTime,_wager.participants,_wager.outcome,_wager.winner)

  ID: 3
  Type: NodeType.RETURN
  Expression: (eventName,eventStartTime,participants,outcome,winner)

Edges:
  0 -> 1
  1 -> 2

Function: announceOutcome
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(outcome != Outcome.NotSet,Unacceptable state!)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_wager.outcome == Outcome.NotSet,Already completed!)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _wager.outcome = outcome

  ID: 5
  Type: NodeType.IF
  Expression: outcome == Outcome.Win

  ID: 6
  Type: NodeType.VARIABLE
  Expression: found = false

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < _wager.participants.length

  ID: 11
  Type: NodeType.IF
  Expression: keccak256(bytes)(abi.encodePacked(winner)) == keccak256(bytes)(abi.encodePacked(_wager.participants[i]))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: found = true

  ID: 13
  Type: NodeType.BREAK
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(found,Participant not found)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _wager.winner = winner

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: OutcomeAnnounced(_wager.outcome,_wager.winner)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 20
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 18
  6 -> 9
  7 -> 10
  8 -> 16
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  11 -> 14
  12 -> 13
  13 -> 8
  14 -> 15
  15 -> 10
  16 -> 17
  17 -> 18
  18 -> 19
  20 -> 1

Function: placeBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_wager.outcome == Outcome.NotSet,Already completed!)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_wager.eventStartTime > block.timestamp,The event has already started!)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(outcome == Outcome.Draw || outcome == Outcome.Win,Wrong outcome provided!)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.balanceOf(_msgSender()) >= amount,Insufficient funds!)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.allowance(_msgSender(),address(this)) >= amount,Insufficient allowance!)

  ID: 7
  Type: NodeType.IF
  Expression: outcome == Outcome.Draw

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: winner = 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: found = false

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < _wager.participants.length

  ID: 14
  Type: NodeType.IF
  Expression: keccak256(bytes)(abi.encodePacked(winner)) == keccak256(bytes)(abi.encodePacked(_wager.participants[i]))

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: found = true

  ID: 16
  Type: NodeType.BREAK
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(found,Participant not found)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _wager.betters[token][_msgSender()].bet[outcome][winner] += amount

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _wager.betters[token][_msgSender()].totalAmount += amount

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _wager.totalOutcomeAmount[token][outcome][winner] += amount

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: token.transferFrom(_msgSender(),address(this),amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 20
  9 -> 12
  10 -> 13
  11 -> 19
  12 -> 10
  13 -> 14
  13 -> 11
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 11
  17 -> 18
  18 -> 13
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24

Function: betAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.RETURN
  Expression: _wager.betters[token][better].bet[outcome][winner]

Edges:
  0 -> 1
  1 -> 2

Function: betsTotalOutcomeAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.RETURN
  Expression: _wager.totalOutcomeAmount[token][outcome][winner]

Edges:
  0 -> 1
  1 -> 2

Function: betterTotalBetsAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.RETURN
  Expression: _wager.betters[token][better].totalAmount

Edges:
  0 -> 1
  1 -> 2

Function: betterPayouts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.RETURN
  Expression: _wager.betters[token][better].payouts

Edges:
  0 -> 1
  1 -> 2

Function: calcPayout
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 3
  Type: NodeType.IF
  Expression: _wager.outcome == Outcome.Cancelled

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: payout.amount = _wager.betters[token][better].totalAmount

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: _wager.outcome == Outcome.Draw && _wager.betters[token][better].bet[Outcome.Draw][] > 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: totalWinAmount = _wager.totalOutcomeAmount[token][Outcome.Draw][]

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 12
  Type: NodeType.IFLOOP
  Expression: i < _wager.participants.length

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: totalLossAmount += _wager.totalOutcomeAmount[token][Outcome.Win][_wager.participants[i]]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: payout.amount = totalLossAmount * _wager.betters[token][better].bet[Outcome.Draw][] / totalWinAmount

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: payout.amount += _wager.betters[token][better].bet[Outcome.Draw][]

  ID: 17
  Type: NodeType.IF
  Expression: payout.amount == 0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: payout.amount = _wager.betters[token][better].bet[Outcome.Draw][]

  ID: 19
  Type: NodeType.IF
  Expression: token != nativeToken

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: payout.fee = payout.amount * nonNativeTokenFeePercent / FEE_PARTS

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: payout.amount -= payout.fee

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: _wager.outcome == Outcome.Win && _wager.betters[token][better].bet[Outcome.Win][_wager.winner] > 0

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: totalWinAmount = _wager.totalOutcomeAmount[token][Outcome.Win][_wager.winner]

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < _wager.participants.length

  ID: 30
  Type: NodeType.IF
  Expression: keccak256(bytes)(abi.encodePacked(_wager.participants[i_scope_0])) != keccak256(bytes)(abi.encodePacked(_wager.winner))

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: totalLossAmount += _wager.totalOutcomeAmount[token][Outcome.Win][_wager.participants[i_scope_0]]

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: totalLossAmount += _wager.totalOutcomeAmount[token][Outcome.Draw][]

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: payout.amount = totalLossAmount * _wager.betters[token][better].bet[Outcome.Win][_wager.winner] / totalWinAmount

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: payout.amount += _wager.betters[token][better].bet[Outcome.Win][_wager.winner]

  ID: 37
  Type: NodeType.IF
  Expression: payout.amount == 0

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: payout.amount = _wager.betters[token][better].bet[Outcome.Win][_wager.winner]

  ID: 39
  Type: NodeType.IF
  Expression: token != nativeToken

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: payout.fee = payout.amount * nonNativeTokenFeePercent / FEE_PARTS

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: payout.amount -= payout.fee

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.ENDIF
  Expression: 

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.ENDIF
  Expression: 

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: payout.amount -= _wager.betters[token][better].payouts

  ID: 48
  Type: NodeType.RETURN
  Expression: payout

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 46
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 24
  8 -> 11
  9 -> 12
  10 -> 15
  11 -> 9
  12 -> 13
  12 -> 10
  13 -> 14
  14 -> 12
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 23
  19 -> 20
  19 -> 22
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 45
  24 -> 25
  24 -> 44
  25 -> 28
  26 -> 29
  27 -> 34
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 31
  30 -> 32
  31 -> 32
  32 -> 33
  33 -> 29
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  37 -> 39
  38 -> 43
  39 -> 40
  39 -> 42
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48

Function: claimPayout
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _wager = _wagers[eventId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_wager.outcome != Outcome.NotSet,Not completed yet!)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: payout = calcPayout(eventId,_msgSender(),token)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(payout.amount > 0,Nothing to pay!)

  ID: 5
  Type: NodeType.IF
  Expression: payout.fee > 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: token.transfer(feeWallet,payout.fee)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _wager.betters[token][_msgSender()].payouts += payout.amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: token.transfer(_msgSender(),payout.amount)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: PayoutClaimed(_msgSender(),eventId,token,payout.amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FEE_PARTS = 10_000

Edges:


