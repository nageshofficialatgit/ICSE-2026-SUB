Contract: Token
==================================================


Contract: ECTools
==================================================

Function: recoverSigner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_hashedMsg != 0x00)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: prefix = Ethereum Signed Message:
32

  ID: 3
  Type: NodeType.VARIABLE
  Expression: prefixedHash = keccak256()(abi.encodePacked(prefix,_hashedMsg))

  ID: 4
  Type: NodeType.IF
  Expression: bytes(_sig).length != 132

  ID: 5
  Type: NodeType.RETURN
  Expression: 0x0

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: sig = hexstrToBytes(substring(_sig,2,132))

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: v < 27

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: v += 27

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: v < 27 || v > 28

  ID: 17
  Type: NodeType.RETURN
  Expression: 0x0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: ecrecover(bytes32,uint8,bytes32,bytes32)(prefixedHash,v,r,s)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19

Function: isSignedBy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addr != 0x0)

  ID: 2
  Type: NodeType.RETURN
  Expression: _addr == recoverSigner(_hashedMsg,_sig)

Edges:
  0 -> 1
  1 -> 2

Function: hexstrToBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: len = bytes(_hexstr).length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(len % 2 == 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: bstr = bytes(new string(len / 2))

  ID: 4
  Type: NodeType.VARIABLE
  Expression: k = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < len

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: s = substring(_hexstr,i,i + 1)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: r = substring(_hexstr,i + 1,i + 2)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: p = parseInt16Char(s) * 16 + parseInt16Char(r)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: bstr[k ++] = uintToBytes32(p)[31]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 16
  Type: NodeType.RETURN
  Expression: bstr

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 16
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 10

Function: parseInt16Char
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bresult = bytes(_char)

  ID: 2
  Type: NodeType.IF
  Expression: (bresult[0] >= 48) && (bresult[0] <= 57)

  ID: 3
  Type: NodeType.RETURN
  Expression: uint256(bresult[0]) - 48

  ID: 4
  Type: NodeType.IF
  Expression: (bresult[0] >= 65) && (bresult[0] <= 70)

  ID: 5
  Type: NodeType.RETURN
  Expression: uint256(bresult[0]) - 55

  ID: 6
  Type: NodeType.IF
  Expression: (bresult[0] >= 97) && (bresult[0] <= 102)

  ID: 7
  Type: NodeType.RETURN
  Expression: uint256(bresult[0]) - 87

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: uintToBytes32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: b = new bytes(32)

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: toEthereumSignedMessage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: len = bytes(_msg).length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(len > 0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: prefix = Ethereum Signed Message:


  ID: 4
  Type: NodeType.RETURN
  Expression: keccak256()(abi.encodePacked(prefix,uintToString(len),_msg))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: uintToString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: len = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: m = _uint + 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: m != 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: m /= 10

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: b = new bytes(len)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = len - 1

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.IFLOOP
  Expression: _uint != 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: remainder = _uint % 10

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _uint = _uint / 10

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: b[i --] = bytes1(48 + remainder)

  ID: 15
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: str = string(b)

  ID: 17
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  14 -> 11
  15 -> 16
  16 -> 17

Function: substring
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: strBytes = bytes(_str)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_startIndex <= _endIndex)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_startIndex >= 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_endIndex <= strBytes.length)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: result = new bytes(_endIndex - _startIndex)

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = _startIndex

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < _endIndex

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: result[i - _startIndex] = strBytes[i]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.RETURN
  Expression: string(result)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 12
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 9


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[msg.sender] >= _value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] -= _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_to] += _value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

  ID: 6
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] += _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] -= _value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] -= _value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

  ID: 4
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1


Contract: HumanStandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[msg.sender] >= _value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] -= _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_to] += _value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

  ID: 6
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] += _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] -= _value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] -= _value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

  ID: 4
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = _initialAmount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply = _initialAmount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: name = _tokenName

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: decimals = _decimalUnits

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: symbol = _tokenSymbol

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: approveAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: version = H0.1

Edges:


Contract: LedgerChannel
==================================================

Function: createChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].partyAddresses[0] == address(0),Channel has already been created.)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_partyI != 0x0,No partyI address provided to LC creation)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_balances[0] >= 0 && _balances[1] >= 0,Balances cannot be negative)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].partyAddresses[0] = msg.sender

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].partyAddresses[1] = _partyI

  ID: 6
  Type: NodeType.IF
  Expression: _balances[0] != 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value == _balances[0],Eth balance does not match sent value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[0] = msg.value

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: _balances[1] != 0

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].token = HumanStandardToken(_token)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transferFrom(msg.sender,this,_balances[1]),CreateChannel: token transfer failure)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[0] = _balances[1]

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].sequence = 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].confirmTime = _confirmTime

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].LCopenTimeout = now + _confirmTime

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].initialDeposit = _balances

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: DidLCOpen(_lcID,msg.sender,_partyI,_balances[0],_token,_balances[1],Channels[_lcID].LCopenTimeout)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 14
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: LCOpenTimeout
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(now > Channels[_lcID].LCopenTimeout)

  ID: 3
  Type: NodeType.IF
  Expression: Channels[_lcID].initialDeposit[0] != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0])

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: Channels[_lcID].initialDeposit[1] != 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0],Channels[_lcID].erc20Balances[0]),CreateChannel: token transfer failure)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: DidLCClose(_lcID,0,Channels[_lcID].ethBalances[0],Channels[_lcID].erc20Balances[0],0,0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: delete Channels[_lcID]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10

Function: joinChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(Channels[_lcID].isOpen == false)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.sender == Channels[_lcID].partyAddresses[1])

  ID: 3
  Type: NodeType.IF
  Expression: _balances[0] != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value == _balances[0],state balance does not match sent value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[1] = msg.value

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: _balances[1] != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transferFrom(msg.sender,this,_balances[1]),joinChannel: token transfer failure)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[1] = _balances[1]

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].initialDeposit[0] += _balances[0]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].initialDeposit[1] += _balances[1]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].isOpen = true

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: numChannels ++

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: DidLCJoin(_lcID,_balances[0],_balances[1])

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15

Function: deposit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].isOpen == true,Tried adding funds to a closed channel)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1])

  ID: 3
  Type: NodeType.IF
  Expression: Channels[_lcID].partyAddresses[0] == recipient

  ID: 4
  Type: NodeType.IF
  Expression: isToken

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transferFrom(msg.sender,this,_balance),deposit: token transfer failure)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[2] += _balance

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value == _balance,state balance does not match sent value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[2] += msg.value

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: Channels[_lcID].partyAddresses[1] == recipient

  ID: 12
  Type: NodeType.IF
  Expression: isToken

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transferFrom(msg.sender,this,_balance),deposit: token transfer failure)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[3] += _balance

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value == _balance,state balance does not match sent value)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[3] += msg.value

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: DidLCDeposit(_lcID,recipient,_balance,isToken)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 10
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 18
  12 -> 13
  12 -> 15
  13 -> 14
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: consensusCloseChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(Channels[_lcID].isOpen == true)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(totalEthDeposit == _balances[0] + _balances[1])

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(totalTokenDeposit == _balances[2] + _balances[3])

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _state = keccak256()(abi.encodePacked(_lcID,true,_sequence,uint256(0),bytes32(0x0),Channels[_lcID].partyAddresses[0],Channels[_lcID].partyAddresses[1],_balances[0],_balances[1],_balances[2],_balances[3]))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state,_sigA))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool)(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state,_sigI))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].isOpen = false

  ID: 10
  Type: NodeType.IF
  Expression: _balances[0] != 0 || _balances[1] != 0

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].partyAddresses[0].transfer(_balances[0])

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].partyAddresses[1].transfer(_balances[1])

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: _balances[2] != 0 || _balances[3] != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0],_balances[2]),happyCloseChannel: token transfer failure)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1],_balances[3]),happyCloseChannel: token transfer failure)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: numChannels --

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: DidLCClose(_lcID,_sequence,_balances[0],_balances[1],_balances[2],_balances[3])

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 13
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: updateLCstate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: channel = Channels[_lcID]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.isOpen)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.sequence < updateParams[0])

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3])

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5])

  ID: 6
  Type: NodeType.IF
  Expression: channel.isUpdateLCSettling == true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.updateLCtimeout > now)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: _state = keccak256()(abi.encodePacked(_lcID,false,updateParams[0],updateParams[1],_VCroot,channel.partyAddresses[0],channel.partyAddresses[1],updateParams[2],updateParams[3],updateParams[4],updateParams[5]))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.partyAddresses[0] == ECTools.recoverSigner(_state,_sigA))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.partyAddresses[1] == ECTools.recoverSigner(_state,_sigI))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: channel.sequence = updateParams[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: channel.numOpenVC = updateParams[1]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[0] = updateParams[2]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[1] = updateParams[3]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[0] = updateParams[4]

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[1] = updateParams[5]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: channel.VCrootHash = _VCroot

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: channel.isUpdateLCSettling = true

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: channel.updateLCtimeout = now + channel.confirmTime

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: DidLCUpdateState(_lcID,updateParams[0],updateParams[1],updateParams[2],updateParams[3],updateParams[4],updateParams[5],_VCroot,channel.updateLCtimeout)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21

Function: initVCstate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].isOpen,LC is closed.)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! virtualChannels[_vcID].isClose,VC is closed.)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].updateLCtimeout < now,LC timeout not over.)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(virtualChannels[_vcID].updateVCtimeout == 0)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _initState = keccak256()(abi.encodePacked(_vcID,uint256(0),_partyA,_partyB,_bond[0],_bond[1],_balances[0],_balances[1],_balances[2],_balances[3]))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_partyA == ECTools.recoverSigner(_initState,sigA))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_isContained(_initState,_proof,Channels[_lcID].VCrootHash) == true)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].partyA = _partyA

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].partyB = _partyB

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].sequence = uint256(0)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].ethBalances[0] = _balances[0]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].ethBalances[1] = _balances[1]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].erc20Balances[0] = _balances[2]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].erc20Balances[1] = _balances[3]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].bond = _bond

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].isInSettlementState = true

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: DidVCInit(_lcID,_vcID,_proof,uint256(0),_partyA,_partyB,_balances[0],_balances[1])

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18

Function: settleVC
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].isOpen,LC is closed.)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! virtualChannels[_vcID].isClose,VC is closed.)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(virtualChannels[_vcID].sequence < updateSeq,VC sequence is higher than update sequence.)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],State updates may only increase recipient balance.)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] && virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],Incorrect balances for bonded amount)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool)(Channels[_lcID].updateLCtimeout < now)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _updateState = keccak256()(abi.encodePacked(_vcID,updateSeq,_partyA,_partyB,virtualChannels[_vcID].bond[0],virtualChannels[_vcID].bond[1],updateBal[0],updateBal[1],updateBal[2],updateBal[3]))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool)(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState,sigA))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].challenger = msg.sender

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].sequence = updateSeq

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].ethBalances[0] = updateBal[0]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].ethBalances[1] = updateBal[1]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].erc20Balances[0] = updateBal[2]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].erc20Balances[1] = updateBal[3]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: DidVCSettle(_lcID,_vcID,updateSeq,updateBal[0],updateBal[1],msg.sender,virtualChannels[_vcID].updateVCtimeout)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16

Function: closeVirtualChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Channels[_lcID].isOpen,LC is closed.)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(virtualChannels[_vcID].isInSettlementState,VC is not in settlement state.)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(virtualChannels[_vcID].updateVCtimeout < now,Update vc timeout has not elapsed.)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! virtualChannels[_vcID].isClose,VC is already closed)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].numOpenVC --

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: virtualChannels[_vcID].isClose = true

  ID: 7
  Type: NodeType.IF
  Expression: virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1]

  ID: 12
  Type: NodeType.IF
  Expression: virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0]

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: DidVCClose(_lcID,_vcID,virtualChannels[_vcID].erc20Balances[0],virtualChannels[_vcID].erc20Balances[1])

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 12
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 18
  12 -> 13
  12 -> 17
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: byzantineCloseChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: channel = Channels[_lcID]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(channel.isOpen,Channel is not open)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.isUpdateLCSettling == true)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(channel.numOpenVC == 0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(channel.updateLCtimeout < now,LC timeout over.)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3]

  ID: 8
  Type: NodeType.VARIABLE
  Expression: possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1]

  ID: 9
  Type: NodeType.VARIABLE
  Expression: possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1]

  ID: 10
  Type: NodeType.IF
  Expression: possibleTotalEthBeforeDeposit < totalEthDeposit

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[0] += channel.ethBalances[2]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[1] += channel.ethBalances[3]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: require(bool)(possibleTotalEthBeforeDeposit == totalEthDeposit)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: possibleTotalTokenBeforeDeposit < totalTokenDeposit

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[0] += channel.erc20Balances[2]

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[1] += channel.erc20Balances[3]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool)(possibleTotalTokenBeforeDeposit == totalTokenDeposit)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: ethbalanceA = channel.ethBalances[0]

  ID: 21
  Type: NodeType.VARIABLE
  Expression: ethbalanceI = channel.ethBalances[1]

  ID: 22
  Type: NodeType.VARIABLE
  Expression: tokenbalanceA = channel.erc20Balances[0]

  ID: 23
  Type: NodeType.VARIABLE
  Expression: tokenbalanceI = channel.erc20Balances[1]

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[0] = 0

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: channel.ethBalances[1] = 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[0] = 0

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: channel.erc20Balances[1] = 0

  ID: 28
  Type: NodeType.IF
  Expression: ethbalanceA != 0 || ethbalanceI != 0

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: channel.partyAddresses[0].transfer(ethbalanceA)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: channel.partyAddresses[1].transfer(ethbalanceI)

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: tokenbalanceA != 0 || tokenbalanceI != 0

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(channel.token.transfer(channel.partyAddresses[0],tokenbalanceA),byzantineCloseChannel: token transfer failure)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(channel.token.transfer(channel.partyAddresses[1],tokenbalanceI),byzantineCloseChannel: token transfer failure)

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: channel.isOpen = false

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: numChannels --

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: DidLCClose(_lcID,channel.sequence,ethbalanceA,ethbalanceI,tokenbalanceA,tokenbalanceI)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 13
  11 -> 12
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 18
  16 -> 17
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 31
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  32 -> 35
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38

Function: _isContained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: cursor = _hash

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 64

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i <= _proof.length

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: cursor < proofElem

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: cursor = keccak256()(abi.encodePacked(cursor,proofElem))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: cursor = keccak256()(abi.encodePacked(proofElem,cursor))

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i += 32

  ID: 14
  Type: NodeType.RETURN
  Expression: cursor == _root

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 14
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 6

Function: getChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: channel = Channels[id]

  ID: 2
  Type: NodeType.RETURN
  Expression: (channel.partyAddresses,channel.ethBalances,channel.erc20Balances,channel.initialDeposit,channel.sequence,channel.confirmTime,channel.VCrootHash,channel.LCopenTimeout,channel.updateLCtimeout,channel.isOpen,channel.isUpdateLCSettling,channel.numOpenVC)

Edges:
  0 -> 1
  1 -> 2

Function: getVirtualChannel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: virtualChannel = virtualChannels[id]

  ID: 2
  Type: NodeType.RETURN
  Expression: (virtualChannel.isClose,virtualChannel.isInSettlementState,virtualChannel.sequence,virtualChannel.challenger,virtualChannel.updateVCtimeout,virtualChannel.partyA,virtualChannel.partyB,virtualChannel.partyI,virtualChannel.ethBalances,virtualChannel.erc20Balances,virtualChannel.bond)

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: numChannels = 0

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NAME = Ledger Channel

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: VERSION = 0.0.1

Edges:
  0 -> 1


