Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1


Contract: EnumerableSet
==================================================

Function: _add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _contains(set,value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: set._values.push(value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: set._indexes[value] = set._values.length

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4

Function: _remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: valueIndex = set._indexes[value]

  ID: 2
  Type: NodeType.IF
  Expression: valueIndex != 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: toDeleteIndex = valueIndex - 1

  ID: 4
  Type: NodeType.VARIABLE
  Expression: lastIndex = set._values.length - 1

  ID: 5
  Type: NodeType.IF
  Expression: lastIndex != toDeleteIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: lastValue = set._values[lastIndex]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: set._values[toDeleteIndex] = lastValue

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: set._indexes[lastValue] = valueIndex

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: set._values.pop()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: delete set._indexes[value]

  ID: 12
  Type: NodeType.RETURN
  Expression: true

  ID: 13
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: _contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._indexes[value] != 0

Edges:
  0 -> 1

Function: _length
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values.length

Edges:
  0 -> 1

Function: _at
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values[index]

Edges:
  0 -> 1

Function: _values
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values

Edges:
  0 -> 1

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _add(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _remove(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _contains(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: length
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _length(set._inner)

Edges:
  0 -> 1

Function: at
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(_at(set._inner,index))

Edges:
  0 -> 1

Function: values
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: store = _values(set._inner)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = store

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: IAccessControlUpgradeable
==================================================


Contract: IERC721ReceiverUpgradeable
==================================================


Contract: AddressUpgradeable
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: account.code.length > 0

Edges:
  0 -> 1

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: returndata

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 7

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: IERC165Upgradeable
==================================================


Contract: MathUpgradeable
==================================================

Function: max
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a > b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: average
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (a & b) + (a ^ b) / 2

Edges:
  0 -> 1

Function: ceilDiv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.RETURN
  Expression: (a - 1) / b + 1

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: mulDiv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = mulDiv(x,y,denominator)

  ID: 2
  Type: NodeType.IF
  Expression: rounding == Rounding.Up && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result += 1

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: sqrt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = sqrt(a)

  ID: 3
  Type: NodeType.IF
  Expression: rounding == Rounding.Up && result * result < a

  ID: 4
  Type: NodeType.RETURN
  Expression: result + 1

  ID: 5
  Type: NodeType.RETURN
  Expression: result + 0

Edges:
  0 -> 1
  1 -> 3
  3 -> 4
  3 -> 5

Function: log2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log2(value)

  ID: 3
  Type: NodeType.IF
  Expression: rounding == Rounding.Up && 1 << result < value

  ID: 4
  Type: NodeType.RETURN
  Expression: result + 1

  ID: 5
  Type: NodeType.RETURN
  Expression: result + 0

Edges:
  0 -> 1
  1 -> 3
  3 -> 4
  3 -> 5

Function: log10
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log10(value)

  ID: 3
  Type: NodeType.IF
  Expression: rounding == Rounding.Up && 10 ** result < value

  ID: 4
  Type: NodeType.RETURN
  Expression: result + 1

  ID: 5
  Type: NodeType.RETURN
  Expression: result + 0

Edges:
  0 -> 1
  1 -> 3
  3 -> 4
  3 -> 5

Function: log256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: result = log256(value)

  ID: 3
  Type: NodeType.IF
  Expression: rounding == Rounding.Up && 1 << (result << 3) < value

  ID: 4
  Type: NodeType.RETURN
  Expression: result + 1

  ID: 5
  Type: NodeType.RETURN
  Expression: result + 0

Edges:
  0 -> 1
  1 -> 3
  3 -> 4
  3 -> 5


Contract: SignedMathUpgradeable
==================================================

Function: max
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a > b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: average
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: x = (a & b) + ((a ^ b) >> 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: x + (int256(uint256(x) >> 255) & (a ^ b))

Edges:
  0 -> 1
  1 -> 2

Function: abs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: n >= 0

  ID: 3
  Type: NodeType.RETURN
  Expression: uint256(n)

  ID: 4
  Type: NodeType.RETURN
  Expression: uint256(- n)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4


Contract: FairxyzEditionsConstants
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: FAIRXYZ_STAGES_REGISTRY = fairxyzStagesRegistry_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MAX_EDITION_SIZE = maxEditionSize_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MAX_RECIPIENTS_PER_AIRDROP = maxRecipientsPerAirdrop_

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_NAME_HASH = keccak256(bytes)(Fair.xyz)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_VERSION_HASH = keccak256(bytes)(2.0.0)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_DOMAIN_TYPE_HASH = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_EDITION_MINT_TYPE_HASH = keccak256(bytes)(EditionMint(uint256 editionId,address recipient,uint256 quantity,uint256 nonce,uint256 maxMints))

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CREATOR_ROLE = keccak256(bytes)(CREATOR_ROLE)

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EXTERNAL_MINTER_ROLE = keccak256(bytes)(EXTERNAL_MINTER_ROLE)

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ROYALTY_DENOMINATOR = 10000

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SIGNATURE_VALID_BLOCKS = 75

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7


Contract: IOperatorFilterRegistry
==================================================


Contract: OperatorFilterRegistryErrorsAndEvents
==================================================


Contract: IFairxyz721Editions
==================================================


Contract: IFairxyzMintStagesRegistry
==================================================


Contract: IFairxyzOperatorFiltererUpgradeable
==================================================


Contract: ITokenURI
==================================================


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Initializable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1


Contract: IERC721Upgradeable
==================================================


Contract: IERC2981Upgradeable
==================================================


Contract: IFairxyzEditions
==================================================


Contract: ReentrancyGuardUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ReentrancyGuard_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ReentrancyGuard_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ReentrancyGuard_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ENTERED = 2

Edges:
  0 -> 1


Contract: IERC721MetadataUpgradeable
==================================================


Contract: ContextUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1


Contract: MulticallUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Multicall_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Multicall_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: multicall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: results = new bytes[](data.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < data.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: results[i] = AddressUpgradeable.functionDelegateCall(address(this),data[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: results

  ID: 9
  Type: NodeType.RETURN
  Expression: results

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5


Contract: StringsUpgradeable
==================================================

Function: toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: value < 0

  ID: 3
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(-,toString(SignedMathUpgradeable.abs(value))))

  ID: 4
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(,toString(SignedMathUpgradeable.abs(value))))

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: toHexString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: toHexString(uint256(uint160(addr)),_ADDRESS_LENGTH)

Edges:
  0 -> 1

Function: equal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(bytes(a)) == keccak256(bytes)(bytes(b))

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _SYMBOLS = 0123456789abcdef

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ADDRESS_LENGTH = 20

Edges:
  0 -> 1


Contract: OwnableUpgradeable
==================================================

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: PausableUpgradeable
==================================================

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1


Contract: ECDSAUpgradeable
==================================================

Function: _throwError
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: error == RecoverError.NoError

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: error == RecoverError.InvalidSignature

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ECDSA: invalid signature)

  ID: 5
  Type: NodeType.IF
  Expression: error == RecoverError.InvalidSignatureLength

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ECDSA: invalid signature length)

  ID: 7
  Type: NodeType.IF
  Expression: error == RecoverError.InvalidSignatureS

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ECDSA: invalid signature 's' value)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  4 -> 11
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: tryRecover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0

  ID: 2
  Type: NodeType.RETURN
  Expression: (address(0),RecoverError.InvalidSignatureS)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: signer = ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)

  ID: 5
  Type: NodeType.IF
  Expression: signer == address(0)

  ID: 6
  Type: NodeType.RETURN
  Expression: (address(0),RecoverError.InvalidSignature)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (signer,RecoverError.NoError)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: recover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (recovered,error) = tryRecover(hash,v,r,s)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _throwError(error)

  ID: 5
  Type: NodeType.RETURN
  Expression: recovered

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: toEthSignedMessageHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(abi.encodePacked(Ethereum Signed Message:
,StringsUpgradeable.toString(s.length),s))

Edges:
  0 -> 1

Function: toTypedDataHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ptr_toTypedDataHash_asm_0 = mload(uint256)(0x40)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x02,domainSeparator)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x22,structHash)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: data = keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,0x42)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.RETURN
  Expression: data

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: toDataWithIntendedValidatorHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(abi.encodePacked( ,validator,data))

Edges:
  0 -> 1


Contract: ERC165Upgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC165Upgradeable).interfaceId

Edges:
  0 -> 1


Contract: Ownable2StepUpgradeable
==================================================

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _pendingOwner = newOwner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferStarted(owner(),newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _pendingOwner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: super._transferOwnership(newOwner)

Edges:
  0 -> 1
  1 -> 2

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Ownable2Step_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable2Step_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: pendingOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _pendingOwner

Edges:
  0 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: OperatorFilterRegistry
==================================================

Function: isOperatorAllowed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != address(0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: filteredOperatorsRef = _filteredOperators[registration]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: filteredCodeHashesRef = _filteredCodeHashes[registration]

  ID: 7
  Type: NodeType.IF
  Expression: filteredOperatorsRef.contains(operator)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert AddressFiltered(address)(operator)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: operator.code.length > 0

  ID: 11
  Type: NodeType.VARIABLE
  Expression: codeHash = operator.codehash

  ID: 12
  Type: NodeType.IF
  Expression: filteredCodeHashesRef.contains(codeHash)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert CodeHashFiltered(address,bytes32)(operator,codeHash)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 16
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 15
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17

Function: register
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _registrations[registrant] != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert AlreadyRegistered()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = registrant

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: RegistrationUpdated(registrant,true)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: unregister
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _subscribers[registration].remove(registrant)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: SubscriptionUpdated(registrant,registration,false)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: RegistrationUpdated(registrant,false)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: registerAndSubscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert AlreadyRegistered()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registrant == subscription

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert CannotSubscribeToSelf()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: subscriptionRegistration = _registrations[subscription]

  ID: 9
  Type: NodeType.IF
  Expression: subscriptionRegistration == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(subscription)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: subscriptionRegistration != subscription

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert CannotSubscribeToRegistrantWithSubscription(address)(subscription)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = subscription

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _subscribers[subscription].add(registrant)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: RegistrationUpdated(registrant,true)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: SubscriptionUpdated(registrant,subscription,true)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 19
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  19 -> 1

Function: registerAndCopyEntries
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registrantToCopy == registrant

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotCopyFromSelf()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 5
  Type: NodeType.IF
  Expression: registration != address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert AlreadyRegistered()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: registrantRegistration = _registrations[registrantToCopy]

  ID: 9
  Type: NodeType.IF
  Expression: registrantRegistration == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrantToCopy)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = registrant

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: RegistrationUpdated(registrant,true)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _copyEntries(registrant,registrantToCopy)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 15
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  15 -> 1

Function: updateOperator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdateWhileSubscribed(address)(registration)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: filteredOperatorsRef = _filteredOperators[registrant]

  ID: 9
  Type: NodeType.IF
  Expression: ! filtered

  ID: 10
  Type: NodeType.VARIABLE
  Expression: removed = filteredOperatorsRef.remove(operator)

  ID: 11
  Type: NodeType.IF
  Expression: ! removed

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: revert AddressNotFiltered(address)(operator)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: added = filteredOperatorsRef.add(operator)

  ID: 15
  Type: NodeType.IF
  Expression: ! added

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: revert AddressAlreadyFiltered(address)(operator)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: OperatorUpdated(registrant,operator,filtered)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 20
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 14
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 18
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  20 -> 1

Function: updateCodeHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: codeHash == EOA_CODEHASH

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotFilterEOAs()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 5
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdateWhileSubscribed(address)(registration)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: filteredCodeHashesRef = _filteredCodeHashes[registrant]

  ID: 12
  Type: NodeType.IF
  Expression: ! filtered

  ID: 13
  Type: NodeType.VARIABLE
  Expression: removed = filteredCodeHashesRef.remove(codeHash)

  ID: 14
  Type: NodeType.IF
  Expression: ! removed

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert CodeHashNotFiltered(bytes32)(codeHash)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: added = filteredCodeHashesRef.add(codeHash)

  ID: 18
  Type: NodeType.IF
  Expression: ! added

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: revert CodeHashAlreadyFiltered(bytes32)(codeHash)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: CodeHashUpdated(registrant,codeHash,filtered)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 23
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 17
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 21
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  23 -> 1

Function: updateOperators
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdateWhileSubscribed(address)(registration)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: filteredOperatorsRef = _filteredOperators[registrant]

  ID: 9
  Type: NodeType.VARIABLE
  Expression: operatorsLength = operators.length

  ID: 10
  Type: NodeType.IF
  Expression: ! filtered

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i < operatorsLength

  ID: 15
  Type: NodeType.VARIABLE
  Expression: operator = operators[i]

  ID: 16
  Type: NodeType.VARIABLE
  Expression: removed = filteredOperatorsRef.remove(operator)

  ID: 17
  Type: NodeType.IF
  Expression: ! removed

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: revert AddressNotFiltered(address)(operator)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 21
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 24
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < operatorsLength

  ID: 25
  Type: NodeType.VARIABLE
  Expression: operator_scope_1 = operators[i_scope_0]

  ID: 26
  Type: NodeType.VARIABLE
  Expression: added = filteredOperatorsRef.add(operator_scope_1)

  ID: 27
  Type: NodeType.IF
  Expression: ! added

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: revert AddressAlreadyFiltered(address)(operator_scope_1)

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: ++ i_scope_0

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: OperatorsUpdated(registrant,operators,filtered)

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 33
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 13
  10 -> 23
  11 -> 14
  12 -> 31
  13 -> 11
  14 -> 15
  14 -> 12
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 14
  21 -> 24
  22 -> 31
  23 -> 21
  24 -> 25
  24 -> 22
  25 -> 26
  26 -> 27
  27 -> 28
  27 -> 29
  28 -> 29
  29 -> 30
  30 -> 24
  31 -> 32
  33 -> 1

Function: updateCodeHashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdateWhileSubscribed(address)(registration)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: filteredCodeHashesRef = _filteredCodeHashes[registrant]

  ID: 9
  Type: NodeType.VARIABLE
  Expression: codeHashesLength = codeHashes.length

  ID: 10
  Type: NodeType.IF
  Expression: ! filtered

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i < codeHashesLength

  ID: 15
  Type: NodeType.VARIABLE
  Expression: codeHash = codeHashes[i]

  ID: 16
  Type: NodeType.VARIABLE
  Expression: removed = filteredCodeHashesRef.remove(codeHash)

  ID: 17
  Type: NodeType.IF
  Expression: ! removed

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: revert CodeHashNotFiltered(bytes32)(codeHash)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 21
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 24
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < codeHashesLength

  ID: 25
  Type: NodeType.VARIABLE
  Expression: codeHash_scope_1 = codeHashes[i_scope_0]

  ID: 26
  Type: NodeType.IF
  Expression: codeHash_scope_1 == EOA_CODEHASH

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: revert CannotFilterEOAs()()

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.VARIABLE
  Expression: added = filteredCodeHashesRef.add(codeHash_scope_1)

  ID: 30
  Type: NodeType.IF
  Expression: ! added

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: revert CodeHashAlreadyFiltered(bytes32)(codeHash_scope_1)

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: ++ i_scope_0

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: CodeHashesUpdated(registrant,codeHashes,filtered)

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 36
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 13
  10 -> 23
  11 -> 14
  12 -> 34
  13 -> 11
  14 -> 15
  14 -> 12
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 14
  21 -> 24
  22 -> 34
  23 -> 21
  24 -> 25
  24 -> 22
  25 -> 26
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  30 -> 32
  31 -> 32
  32 -> 33
  33 -> 24
  34 -> 35
  36 -> 1

Function: subscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registrant == newSubscription

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotSubscribeToSelf()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: newSubscription == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert CannotSubscribeToZeroAddress()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 8
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: registration == newSubscription

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: revert AlreadySubscribed(address)(newSubscription)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: newSubscriptionRegistration = _registrations[newSubscription]

  ID: 15
  Type: NodeType.IF
  Expression: newSubscriptionRegistration == address(0)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(newSubscription)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: newSubscriptionRegistration != newSubscription

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: revert CannotSubscribeToRegistrantWithSubscription(address)(newSubscription)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _subscribers[registration].remove(registrant)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: SubscriptionUpdated(registrant,registration,false)

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = newSubscription

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _subscribers[newSubscription].add(registrant)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: SubscriptionUpdated(registrant,newSubscription,true)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 28
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  28 -> 1

Function: unsubscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: registration == registrant

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert NotSubscribed()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _subscribers[registration].remove(registrant)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _registrations[registrant] = registrant

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: SubscriptionUpdated(registrant,registration,false)

  ID: 11
  Type: NodeType.IF
  Expression: copyExistingEntries

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _copyEntries(registrant,registration)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 14
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  14 -> 1

Function: copyEntriesOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registrant == registrantToCopy

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotCopyFromSelf()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 5
  Type: NodeType.IF
  Expression: registration == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdateWhileSubscribed(address)(registration)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: registrantRegistration = _registrations[registrantToCopy]

  ID: 12
  Type: NodeType.IF
  Expression: registrantRegistration == address(0)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrantToCopy)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _copyEntries(registrant,registrantToCopy)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: onlyAddressOrOwner(registrant)

Edges:
  0 -> 16
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  16 -> 1

Function: _copyEntries
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: filteredOperatorsRef = _filteredOperators[registrantToCopy]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: filteredCodeHashesRef = _filteredCodeHashes[registrantToCopy]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: filteredOperatorsLength = filteredOperatorsRef.length()

  ID: 4
  Type: NodeType.VARIABLE
  Expression: filteredCodeHashesLength = filteredCodeHashesRef.length()

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < filteredOperatorsLength

  ID: 9
  Type: NodeType.VARIABLE
  Expression: operator = filteredOperatorsRef.at(i)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: added = _filteredOperators[registrant].add(operator)

  ID: 11
  Type: NodeType.IF
  Expression: added

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OperatorUpdated(registrant,operator,true)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 18
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < filteredCodeHashesLength

  ID: 19
  Type: NodeType.VARIABLE
  Expression: codehash = filteredCodeHashesRef.at(i_scope_0)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: added_scope_1 = _filteredCodeHashes[registrant].add(codehash)

  ID: 21
  Type: NodeType.IF
  Expression: added_scope_1

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: CodeHashUpdated(registrant,codehash,true)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: ++ i_scope_0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 17
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 8
  15 -> 18
  17 -> 15
  18 -> 19
  18 -> 16
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 18

Function: subscriptionOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: subscription = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: subscription == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NotRegistered(address)(registrant)

  ID: 4
  Type: NodeType.IF
  Expression: subscription == registrant

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: subscription = address(0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: subscription

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 7
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8

Function: subscribers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _subscribers[registrant].values()

Edges:
  0 -> 1

Function: subscriberAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _subscribers[registrant].at(index)

Edges:
  0 -> 1

Function: isOperatorFiltered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredOperators[registration].contains(operator)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredOperators[registrant].contains(operator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: isCodeHashFiltered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registration].contains(codeHash)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registrant].contains(codeHash)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: isCodeHashOfFiltered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: codeHash = operatorWithCode.codehash

  ID: 2
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 3
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 4
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registration].contains(codeHash)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registrant].contains(codeHash)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6

Function: isRegistered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _registrations[registrant] != address(0)

Edges:
  0 -> 1

Function: filteredOperators
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredOperators[registration].values()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredOperators[registrant].values()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: filteredCodeHashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registration].values()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registrant].values()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: filteredOperatorAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredOperators[registration].at(index)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredOperators[registrant].at(index)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: filteredCodeHashAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registration = _registrations[registrant]

  ID: 2
  Type: NodeType.IF
  Expression: registration != registrant

  ID: 3
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registration].at(index)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _filteredCodeHashes[registrant].at(index)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: codeHashOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: a.codehash

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EOA_CODEHASH = keccak256(bytes)()

Edges:


Contract: AccessControlUpgradeable
==================================================

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __AccessControl_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __AccessControl_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: hasRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].members[account]

Edges:
  0 -> 1

Function: _checkRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: getRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].adminRole

Edges:
  0 -> 1

Function: grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: renounceRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

Edges:
  0 -> 1
  1 -> 2

Function: _setupRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

Edges:
  0 -> 1

Function: _setRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: previousAdminRole = getRoleAdmin(role)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].adminRole = adminRole

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleAdminChanged(role,previousAdminRole,adminRole)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleGranted(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: _revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleRevoked(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_ADMIN_ROLE = 0x00

Edges:


Contract: FairxyzOperatorFiltererUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: REGISTRY_ADDRESS = registry_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: DEFAULT_SUBSCRIPTION_ADDRESS = defaultSubscription_

Edges:
  0 -> 1
  1 -> 2

Function: __FairxyzOperatorFilterer_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __FairxyzOperatorFilterer_init_unchained(enabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __FairxyzOperatorFilterer_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: enabled && REGISTRY_ADDRESS.code.length > 0 && DEFAULT_SUBSCRIPTION_ADDRESS != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: IOperatorFilterRegistry(REGISTRY_ADDRESS).registerAndSubscribe(address(this),DEFAULT_SUBSCRIPTION_ADDRESS)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: toggleOperatorFilterDisabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: disabled = ! operatorFilterDisabled

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = disabled

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OperatorFilterDisabled(disabled)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1


Contract: Fairxyz721Upgradeable
==================================================

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC721Upgradeable).interfaceId || interfaceId == type()(IERC721MetadataUpgradeable).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __Fairxyz721_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Fairxyz721_init_unchained(name_,symbol_)

Edges:
  0 -> 1

Function: __Fairxyz721_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC721: address zero is not a valid owner)

  ID: 2
  Type: NodeType.RETURN
  Expression: _balances[owner]

Edges:
  0 -> 1
  1 -> 2

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _ownerOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC721: invalid token ID)

  ID: 3
  Type: NodeType.RETURN
  Expression: owner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != owner,ERC721: approval to current owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_msgSender() == owner || isApprovedForAll(owner,_msgSender()),ERC721: approve caller is not token owner or approved for all)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_exists(tokenId),ERC721: invalid token ID)

  ID: 2
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId]

Edges:
  0 -> 1
  1 -> 2

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setApprovalForAll(_msgSender(),operator,approved)

Edges:
  0 -> 1

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenId),ERC721: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,tokenId)

Edges:
  0 -> 1
  1 -> 2

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenId),ERC721: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeTransfer(from,to,tokenId,data)

Edges:
  0 -> 1
  1 -> 2

Function: _safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_checkOnERC721Received(from,to,tokenId,data),ERC721: transfer to non ERC721Receiver implementer)

Edges:
  0 -> 1
  1 -> 2

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _ownerOf(tokenId) != address(0)

Edges:
  0 -> 1

Function: _isApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.RETURN
  Expression: (spender == owner || isApprovedForAll(owner,spender) || _tokenApprovals[tokenId] == spender)

Edges:
  0 -> 1
  1 -> 2

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(owner,address(0),tokenId,1)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: delete _tokenApprovals[tokenId]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _balances[owner] -= 1

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: delete _owners[tokenId]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(owner,address(0),tokenId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(owner,address(0),tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ownerOf(tokenId) == from,ERC721: transfer from incorrect owner)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC721: transfer to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(from,to,tokenId,1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: delete _tokenApprovals[tokenId]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _balances[from] -= 1

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += 1

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _owners[tokenId] = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,tokenId)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId] = to

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(ownerOf(tokenId),to,tokenId)

Edges:
  0 -> 1
  1 -> 2

Function: _setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != operator,ERC721: approve to caller)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[owner][operator] = approved

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(owner,operator,approved)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _checkOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: retval = IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(),from,tokenId,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: retval == IERC721ReceiverUpgradeable.onERC721Received.selector

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC721: transfer to non ERC721Receiver implementer)

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: true

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 12
  2 -> 3
  2 -> 5
  2 -> 13
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 13

Function: _afterTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: __unsafe_increaseBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

Edges:
  0 -> 1


Contract: FairxyzEditionsBaseUpgradeable
==================================================

Function: __ReentrancyGuard_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ReentrancyGuard_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ReentrancyGuard_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __Ownable2Step_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable2Step_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: pendingOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _pendingOwner

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: __Multicall_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Multicall_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: multicall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: results = new bytes[](data.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < data.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: results[i] = AddressUpgradeable.functionDelegateCall(address(this),data[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: results

  ID: 9
  Type: NodeType.RETURN
  Expression: results

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: __AccessControl_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __AccessControl_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AccessControlUpgradeable.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: hasRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].members[account]

Edges:
  0 -> 1

Function: _checkRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: getRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].adminRole

Edges:
  0 -> 1

Function: grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: renounceRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

Edges:
  0 -> 1
  1 -> 2

Function: _setupRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

Edges:
  0 -> 1

Function: _setRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: previousAdminRole = getRoleAdmin(role)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].adminRole = adminRole

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleAdminChanged(role,previousAdminRole,adminRole)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleGranted(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: _revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleRevoked(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_ADMIN_ROLE = 0x00

Edges:


Contract: FairxyzEditionsUpgradeable
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _disableInitializers()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: FairxyzEditionsConstants(fairxyzStagesRegistry_,maxEditionSize_,maxRecipientsPerAirdrop_)

Edges:
  0 -> 2
  2 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IFairxyzEditions).interfaceId || interfaceId == type()(IERC2981Upgradeable).interfaceId || FairxyzEditionsBaseUpgradeable.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: __ReentrancyGuard_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ReentrancyGuard_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ReentrancyGuard_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __Ownable2Step_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable2Step_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: pendingOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _pendingOwner

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: __Multicall_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Multicall_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: multicall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: results = new bytes[](data.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < data.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: results[i] = AddressUpgradeable.functionDelegateCall(address(this),data[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: results

  ID: 9
  Type: NodeType.RETURN
  Expression: results

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: __AccessControl_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __AccessControl_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: hasRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].members[account]

Edges:
  0 -> 1

Function: _checkRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _msgSender() != owner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _checkRole(role,_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: getRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].adminRole

Edges:
  0 -> 1

Function: grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: renounceRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

Edges:
  0 -> 1
  1 -> 2

Function: _setupRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

Edges:
  0 -> 1

Function: _setRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: previousAdminRole = getRoleAdmin(role)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].adminRole = adminRole

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleAdminChanged(role,previousAdminRole,adminRole)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleGranted(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: _revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleRevoked(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: __FairxyzEditions_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __FairxyzEditions_init_unchained(owner_,defaultMintingExtension_,defaultRoyaltyExtension_)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __FairxyzEditions_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner_ == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _primarySaleReceiver = owner_

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(owner_)

  ID: 6
  Type: NodeType.IF
  Expression: defaultMintingExtension_ != address(0)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _setMintingExtension(defaultMintingExtension_)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: defaultRoyaltyExtension_ != address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _setRoyaltyExtension(defaultRoyaltyExtension_)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 12
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  12 -> 1

Function: mintEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: _mintingExtension != address(0)

  ID: 3
  Type: NodeType.IF
  Expression: msg.sender != _mintingExtension

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert SenderIsNotExtension()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isExtension = true

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (fairxyzParameters,stageIndex,stage) = _stagesRegistry().viewActiveStage(address(this),editionId)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _checkMintSignature(editionId,recipient,quantity,signatureNonce,signatureMaxMints,stage.signatureReleased,signature,fairxyzParameters.fairxyzSigner)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: ! isExtension

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: costPerToken = stage.price + fairxyzParameters.fairxyzFee

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _verifyPayment(quantity,costPerToken)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: handler = _handleEditionMinting(editionId,recipient,quantity,signatureNonce,signatureMaxMints,stageIndex,stage)

  ID: 19
  Type: NodeType.IF
  Expression: ! isExtension

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: address(fairxyzParameters.fairxyzWithdrawAddress).sendValue(fairxyzParameters.fairxyzFee * handler.allowedQuantity)

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _handleEmissionAndTransfers(editionId,stageIndex,recipient,handler.allowedQuantity,handler.editionMintedTotal,quantity,costPerToken)

  ID: 23
  Type: NodeType.RETURN
  Expression: handler

  ID: 24
  Type: NodeType.RETURN
  Expression: handler

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23

Function: editionTotalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _editionMintedCount[editionId] - _editionBurnedCount[editionId]

Edges:
  0 -> 1

Function: getEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _editions[editionId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 2
  2 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i <= _editionsCount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: supply += editionTotalSupply(i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 7
  Type: NodeType.RETURN
  Expression: supply

Edges:
  0 -> 3
  1 -> 4
  2 -> 7
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4

Function: airdropEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numberOfRecipients = recipients.length

  ID: 2
  Type: NodeType.IF
  Expression: numberOfRecipients == 0 || numberOfRecipients > _maxRecipientsPerAirdrop()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InvalidNumberOfRecipients()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: totalQuantity = numberOfRecipients * quantity

  ID: 6
  Type: NodeType.VARIABLE
  Expression: editionMintedTotal = _editionMintedCount[editionId]

  ID: 7
  Type: NodeType.IF
  Expression: totalQuantity + editionMintedTotal > _editionMintLimit(_editions[editionId].maxSupply)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughSupplyRemaining()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _editionMintedCount[editionId] = editionMintedTotal + totalQuantity

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < numberOfRecipients

  ID: 14
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _mintEditionTokens(recipient,editionId,quantity,editionMintedTotal)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: editionMintedTotal += quantity

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 18
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: EditionAirdrop(editionId,_stagesRegistry().viewLatestStageIndex(address(this),editionId),recipients,quantity,editionMintedTotal)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: onlyAirdropRoles()

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 20
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 14
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 13
  18 -> 19
  20 -> 21
  21 -> 1

Function: createEditions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _batchCreateEditionsWithStages(editions)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

Edges:
  0 -> 2
  2 -> 1

Function: deleteEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _editionMintedCount[editionId] > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionAlreadyMinted()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _deleteEdition(editionId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 1

Function: releaseEditionSignature
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _editions[editionId].signatureReleased

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionSignatureAlreadyReleased()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].signatureReleased = true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: EditionSignatureReleased(editionId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 7
  7 -> 1

Function: setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(receiver,royaltyFraction)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: setEditionMaxMintsPerWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].maxMintsPerWallet = maxMintsPerWallet

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionMaxMintsPerWallet(editionId,maxMintsPerWallet)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: setEditionMaxSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: maxSupply == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyCanOnlyBeReduced()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: maxSupply >= _editionMintLimit(_editions[editionId].maxSupply)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyCanOnlyBeReduced()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: maxSupply < _editionMintedCount[editionId]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanMintedCount()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (None,finalStage) = _stagesRegistry().viewFinalStage(address(this),editionId)

  ID: 12
  Type: NodeType.IF
  Expression: finalStage.startTime > 0 && (finalStage.endTime >= block.timestamp || finalStage.endTime == 0)

  ID: 13
  Type: NodeType.IF
  Expression: finalStage.phaseLimit == 0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanScheduledStagesPhaseLimit()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: maxSupply < finalStage.phaseLimit

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanScheduledStagesPhaseLimit()()

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].maxSupply = maxSupply

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: EditionMaxSupply(editionId,maxSupply)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 22
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 19
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  22 -> 23
  23 -> 1

Function: setEditionRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: delete _editionRoyalty[editionId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: EditionRoyalty(editionId,address(0),0)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _editionRoyalty[editionId] = Royalty(receiver,royaltyFraction)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: EditionRoyalty(editionId,receiver,royaltyFraction)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyValidRoyaltyFraction(royaltyFraction)

Edges:
  0 -> 8
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 10
  10 -> 1

Function: setEditionStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: stages.length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().cancelStages(address(this),editionId,fromIndex)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().setStages(address(this),editionId,fromIndex,stages,_editionMintedCount[editionId],_editions[editionId].maxSupply)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  5 -> 6
  6 -> 1

Function: setEditionURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setEditionURI(editionId,uri)

  ID: 2
  Type: NodeType.IF
  Expression: _editionMintedCount[editionId] > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _emitMetadataUpdateEvent(editionId,uri)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 6
  6 -> 1

Function: setEditionURIExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setEditionURIExtension(editionId,uriExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: setPrimarySaleReceiver
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: primarySaleReceiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _primarySaleReceiver = primarySaleReceiver

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: PrimarySaleReceiver(primarySaleReceiver)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: setMintingExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setMintingExtension(newMintingExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: setRoyaltyExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setRoyaltyExtension(newRoyaltyExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: address(_primarySaleReceiver).sendValue(address(this).balance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: grantDefaultAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(DEFAULT_ADMIN_ROLE,admin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: _batchCreateEditionsWithStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: editionsCount = _editionsCount

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < editions.length

  ID: 6
  Type: NodeType.IF
  Expression: editions[i].edition.maxSupply > MAX_EDITION_SIZE

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyTooLarge()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: editionsCount ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: edition = editions[i].edition

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _editions[editionsCount] = edition

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: EditionCreated(editionsCount,editions[i].externalId,edition)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _setEditionURI(editionsCount,editions[i].uri)

  ID: 14
  Type: NodeType.IF
  Expression: editions[i].mintStages.length > 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().setStages(address(this),editionsCount,0,editions[i].mintStages,0,edition.maxSupply)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _editionsCount = editionsCount

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 18
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 5

Function: _calculateAllowedMintQuantity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: quantity = requestedQuantity

  ID: 2
  Type: NodeType.IF
  Expression: signatureMaxMints > 0

  ID: 3
  Type: NodeType.IF
  Expression: recipientStageMints >= signatureMaxMints

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert RecipientAllowanceUsed()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: recipientRemainingMints = signatureMaxMints - recipientStageMints

  ID: 7
  Type: NodeType.IF
  Expression: quantity > recipientRemainingMints

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientRemainingMints

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: stage.mintsPerWallet > 0

  ID: 12
  Type: NodeType.IF
  Expression: recipientStageMints >= stage.mintsPerWallet

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert RecipientStageAllowanceUsed()()

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: recipientStageRemainingMints = stage.mintsPerWallet - recipientStageMints

  ID: 16
  Type: NodeType.IF
  Expression: quantity > recipientStageRemainingMints

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientStageRemainingMints

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: edition = getEdition(editionId)

  ID: 21
  Type: NodeType.IF
  Expression: edition.maxMintsPerWallet > 0

  ID: 22
  Type: NodeType.IF
  Expression: recipientEditionMints >= edition.maxMintsPerWallet

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: revert RecipientEditionAllowanceUsed()()

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.VARIABLE
  Expression: recipientEditionRemainingMints = edition.maxMintsPerWallet - recipientEditionMints

  ID: 26
  Type: NodeType.IF
  Expression: quantity > recipientEditionRemainingMints

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientEditionRemainingMints

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.VARIABLE
  Expression: stagePhaseLimit = stage.phaseLimit

  ID: 31
  Type: NodeType.IF
  Expression: stagePhaseLimit == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: stagePhaseLimit = MAX_EDITION_SIZE

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.IF
  Expression: editionMintedTotal >= stagePhaseLimit

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: revert StageSoldOut()()

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.VARIABLE
  Expression: stageRemainingMints = stagePhaseLimit - editionMintedTotal

  ID: 38
  Type: NodeType.IF
  Expression: quantity > stageRemainingMints

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: quantity = stageRemainingMints

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.RETURN
  Expression: quantity

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 10
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 19
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 29
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  32 -> 33
  33 -> 34
  34 -> 35
  34 -> 36
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  39 -> 40
  40 -> 41

Function: _checkMintSignature
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: signatureReleased || _editions[editionId].signatureReleased

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: nonce > block.number

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert InvalidSignatureNonce()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: nonce + SIGNATURE_VALID_BLOCKS < block.number

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert SignatureExpired()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: nonce <= _editionMinters[editionId][recipient].lastUsedNonce

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert SignatureAlreadyUsed()()

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: messageHash = _hashMintParams(editionId,recipient,quantity,nonce,maxMints)

  ID: 14
  Type: NodeType.IF
  Expression: messageHash.recover(signature) != fairxyzsigner

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert InvalidSignature()()

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16

Function: _verifyPayment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value != quantity * costPerToken

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert IncorrectEthValue()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _handleEditionMinting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: editionMinter = _editionMinters[editionId][recipient]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: recipientStageMints = _editionStageMints[editionId][stageIndex][recipient]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: editionMintedTotal = _editionMintedCount[editionId]

  ID: 4
  Type: NodeType.VARIABLE
  Expression: allowedQuantity = _calculateAllowedMintQuantity(quantity,editionId,editionMintedTotal,stage,editionMinter.mintedCount,recipientStageMints,signatureMaxMints)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _editionMinters[editionId][recipient] = EditionMinter(editionMinter.mintedCount + uint40(allowedQuantity),signatureNonce)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _editionStageMints[editionId][stageIndex][recipient] += allowedQuantity

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _editionMintedCount[editionId] += allowedQuantity

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _mintEditionTokens(recipient,editionId,allowedQuantity,editionMintedTotal)

  ID: 9
  Type: NodeType.RETURN
  Expression: EditionMintingHandler(allowedQuantity,editionMintedTotal)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: _handleEmissionAndTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: EditionStageMint(editionId,stageIndex,recipient,allowedQuantity,editionMintedTotal + allowedQuantity)

  ID: 2
  Type: NodeType.IF
  Expression: allowedQuantity < quantity

  ID: 3
  Type: NodeType.VARIABLE
  Expression: refundAmount = (quantity - allowedQuantity) * costPerToken

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: address(msg.sender).sendValue(refundAmount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _setMintingExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _mintingExtension = newMintingExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MintingExtension(newMintingExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _setRoyaltyExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _royaltyExtension = newRoyaltyExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RoyaltyExtension(newRoyaltyExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _deleteEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editionDeleted[editionId] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionDeleted(editionId)

Edges:
  0 -> 1
  1 -> 2

Function: _editionExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: editionId == 0 || editionId > _editionsCount || _editionDeleted[editionId]

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _editionMintLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: editionMaxSupply == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: limit = MAX_EDITION_SIZE

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: limit = editionMaxSupply

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: limit

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _hashMintParams
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: digest = _hashTypedDataV4(keccak256(bytes)(abi.encode(EIP712_EDITION_MINT_TYPE_HASH,editionId,recipient,quantity,nonce,maxMints)))

  ID: 2
  Type: NodeType.RETURN
  Expression: digest

Edges:
  0 -> 1
  1 -> 2

Function: _hashTypedDataV4
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: domainSeparator = keccak256(bytes)(abi.encode(EIP712_DOMAIN_TYPE_HASH,EIP712_NAME_HASH,EIP712_VERSION_HASH,block.chainid,address(this)))

  ID: 2
  Type: NodeType.RETURN
  Expression: ECDSAUpgradeable.toTypedDataHash(domainSeparator,structHash)

Edges:
  0 -> 1
  1 -> 2

Function: _maxRecipientsPerAirdrop
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: MAX_RECIPIENTS_PER_AIRDROP

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyalty

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: DefaultRoyalty(address(0),0)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyalty = Royalty(receiver,royaltyFraction)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: DefaultRoyalty(receiver,royaltyFraction)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyValidRoyaltyFraction(royaltyFraction)

Edges:
  0 -> 8
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  8 -> 1

Function: _setEditionURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: bytes(uri).length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidURI()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _editionURI[editionId] = uri

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: EditionURI(editionId,uri)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5

Function: _setEditionURIExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editionURIExtension[editionId] = uriExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionURIExtension(editionId,uriExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _stagesRegistry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IFairxyzMintStagesRegistry(FAIRXYZ_STAGES_REGISTRY)

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_ADMIN_ROLE = 0x00

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_NAME_HASH = keccak256(bytes)(Fair.xyz)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_VERSION_HASH = keccak256(bytes)(2.0.0)

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_DOMAIN_TYPE_HASH = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_EDITION_MINT_TYPE_HASH = keccak256(bytes)(EditionMint(uint256 editionId,address recipient,uint256 quantity,uint256 nonce,uint256 maxMints))

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CREATOR_ROLE = keccak256(bytes)(CREATOR_ROLE)

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EXTERNAL_MINTER_ROLE = keccak256(bytes)(EXTERNAL_MINTER_ROLE)

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ROYALTY_DENOMINATOR = 10000

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SIGNATURE_VALID_BLOCKS = 75

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8


Contract: Fairxyz721Editions
==================================================

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: MAX_MINTS_PER_TRANSACTION = maxMintsPerTransaction_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _disableInitializers()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: FairxyzEditionsUpgradeable(fairxyzStagesRegistry_,EDITION_RANGE_SIZE - 1,maxRecipientsPerAirdrop_)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: FairxyzOperatorFiltererUpgradeable(operatorFilterRegistry_,operatorFilterSubscription_)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: __FairxyzEditions_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __FairxyzEditions_init_unchained(owner_,defaultMintingExtension_,defaultRoyaltyExtension_)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __FairxyzEditions_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner_ == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _primarySaleReceiver = owner_

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(owner_)

  ID: 6
  Type: NodeType.IF
  Expression: defaultMintingExtension_ != address(0)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _setMintingExtension(defaultMintingExtension_)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: defaultRoyaltyExtension_ != address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _setRoyaltyExtension(defaultRoyaltyExtension_)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 12
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  12 -> 1

Function: mintEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: _mintingExtension != address(0)

  ID: 3
  Type: NodeType.IF
  Expression: msg.sender != _mintingExtension

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert SenderIsNotExtension()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: isExtension = true

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (fairxyzParameters,stageIndex,stage) = _stagesRegistry().viewActiveStage(address(this),editionId)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _checkMintSignature(editionId,recipient,quantity,signatureNonce,signatureMaxMints,stage.signatureReleased,signature,fairxyzParameters.fairxyzSigner)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: ! isExtension

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: costPerToken = stage.price + fairxyzParameters.fairxyzFee

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _verifyPayment(quantity,costPerToken)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: handler = _handleEditionMinting(editionId,recipient,quantity,signatureNonce,signatureMaxMints,stageIndex,stage)

  ID: 19
  Type: NodeType.IF
  Expression: ! isExtension

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: address(fairxyzParameters.fairxyzWithdrawAddress).sendValue(fairxyzParameters.fairxyzFee * handler.allowedQuantity)

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: _handleEmissionAndTransfers(editionId,stageIndex,recipient,handler.allowedQuantity,handler.editionMintedTotal,quantity,costPerToken)

  ID: 23
  Type: NodeType.RETURN
  Expression: handler

  ID: 24
  Type: NodeType.RETURN
  Expression: handler

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23

Function: editionTotalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _editionMintedCount[editionId] - _editionBurnedCount[editionId]

Edges:
  0 -> 1

Function: getEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _editions[editionId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 2
  2 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i <= _editionsCount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: supply += editionTotalSupply(i)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 7
  Type: NodeType.RETURN
  Expression: supply

Edges:
  0 -> 3
  1 -> 4
  2 -> 7
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4

Function: airdropEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numberOfRecipients = recipients.length

  ID: 2
  Type: NodeType.IF
  Expression: numberOfRecipients == 0 || numberOfRecipients > _maxRecipientsPerAirdrop()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InvalidNumberOfRecipients()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: totalQuantity = numberOfRecipients * quantity

  ID: 6
  Type: NodeType.VARIABLE
  Expression: editionMintedTotal = _editionMintedCount[editionId]

  ID: 7
  Type: NodeType.IF
  Expression: totalQuantity + editionMintedTotal > _editionMintLimit(_editions[editionId].maxSupply)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughSupplyRemaining()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _editionMintedCount[editionId] = editionMintedTotal + totalQuantity

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < numberOfRecipients

  ID: 14
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _mintEditionTokens(recipient,editionId,quantity,editionMintedTotal)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: editionMintedTotal += quantity

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 18
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: EditionAirdrop(editionId,_stagesRegistry().viewLatestStageIndex(address(this),editionId),recipients,quantity,editionMintedTotal)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: onlyAirdropRoles()

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 20
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 14
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 13
  18 -> 19
  20 -> 21
  21 -> 1

Function: createEditions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _batchCreateEditionsWithStages(editions)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

Edges:
  0 -> 2
  2 -> 1

Function: deleteEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _editionMintedCount[editionId] > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionAlreadyMinted()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _deleteEdition(editionId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 1

Function: releaseEditionSignature
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _editions[editionId].signatureReleased

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionSignatureAlreadyReleased()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].signatureReleased = true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: EditionSignatureReleased(editionId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 7
  7 -> 1

Function: setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(receiver,royaltyFraction)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: setEditionMaxMintsPerWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].maxMintsPerWallet = maxMintsPerWallet

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionMaxMintsPerWallet(editionId,maxMintsPerWallet)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: setEditionMaxSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: maxSupply == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyCanOnlyBeReduced()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: maxSupply >= _editionMintLimit(_editions[editionId].maxSupply)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyCanOnlyBeReduced()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: maxSupply < _editionMintedCount[editionId]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanMintedCount()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (None,finalStage) = _stagesRegistry().viewFinalStage(address(this),editionId)

  ID: 12
  Type: NodeType.IF
  Expression: finalStage.startTime > 0 && (finalStage.endTime >= block.timestamp || finalStage.endTime == 0)

  ID: 13
  Type: NodeType.IF
  Expression: finalStage.phaseLimit == 0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanScheduledStagesPhaseLimit()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: maxSupply < finalStage.phaseLimit

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyLessThanScheduledStagesPhaseLimit()()

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _editions[editionId].maxSupply = maxSupply

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: EditionMaxSupply(editionId,maxSupply)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 22
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 19
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  22 -> 23
  23 -> 1

Function: setEditionRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: delete _editionRoyalty[editionId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: EditionRoyalty(editionId,address(0),0)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _editionRoyalty[editionId] = Royalty(receiver,royaltyFraction)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: EditionRoyalty(editionId,receiver,royaltyFraction)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyValidRoyaltyFraction(royaltyFraction)

Edges:
  0 -> 8
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 10
  10 -> 1

Function: setEditionStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: stages.length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().cancelStages(address(this),editionId,fromIndex)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().setStages(address(this),editionId,fromIndex,stages,_editionMintedCount[editionId],_editions[editionId].maxSupply)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  5 -> 6
  6 -> 1

Function: setEditionURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setEditionURI(editionId,uri)

  ID: 2
  Type: NodeType.IF
  Expression: _editionMintedCount[editionId] > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _emitMetadataUpdateEvent(editionId,uri)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 6
  6 -> 1

Function: setEditionURIExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setEditionURIExtension(editionId,uriExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyExistingEdition(editionId)

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: setPrimarySaleReceiver
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: primarySaleReceiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _primarySaleReceiver = primarySaleReceiver

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: PrimarySaleReceiver(primarySaleReceiver)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: setMintingExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setMintingExtension(newMintingExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: setRoyaltyExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setRoyaltyExtension(newRoyaltyExtension)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: address(_primarySaleReceiver).sendValue(address(this).balance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDefaultAdmin()

Edges:
  0 -> 2
  2 -> 1

Function: grantDefaultAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(DEFAULT_ADMIN_ROLE,admin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: _batchCreateEditionsWithStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: editionsCount = _editionsCount

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < editions.length

  ID: 6
  Type: NodeType.IF
  Expression: editions[i].edition.maxSupply > MAX_EDITION_SIZE

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert EditionSupplyTooLarge()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: editionsCount ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: edition = editions[i].edition

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _editions[editionsCount] = edition

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: EditionCreated(editionsCount,editions[i].externalId,edition)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _setEditionURI(editionsCount,editions[i].uri)

  ID: 14
  Type: NodeType.IF
  Expression: editions[i].mintStages.length > 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _stagesRegistry().setStages(address(this),editionsCount,0,editions[i].mintStages,0,edition.maxSupply)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _editionsCount = editionsCount

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 18
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 5

Function: _calculateAllowedMintQuantity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: quantity = requestedQuantity

  ID: 2
  Type: NodeType.IF
  Expression: signatureMaxMints > 0

  ID: 3
  Type: NodeType.IF
  Expression: recipientStageMints >= signatureMaxMints

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert RecipientAllowanceUsed()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: recipientRemainingMints = signatureMaxMints - recipientStageMints

  ID: 7
  Type: NodeType.IF
  Expression: quantity > recipientRemainingMints

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientRemainingMints

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: stage.mintsPerWallet > 0

  ID: 12
  Type: NodeType.IF
  Expression: recipientStageMints >= stage.mintsPerWallet

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert RecipientStageAllowanceUsed()()

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: recipientStageRemainingMints = stage.mintsPerWallet - recipientStageMints

  ID: 16
  Type: NodeType.IF
  Expression: quantity > recipientStageRemainingMints

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientStageRemainingMints

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: edition = getEdition(editionId)

  ID: 21
  Type: NodeType.IF
  Expression: edition.maxMintsPerWallet > 0

  ID: 22
  Type: NodeType.IF
  Expression: recipientEditionMints >= edition.maxMintsPerWallet

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: revert RecipientEditionAllowanceUsed()()

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.VARIABLE
  Expression: recipientEditionRemainingMints = edition.maxMintsPerWallet - recipientEditionMints

  ID: 26
  Type: NodeType.IF
  Expression: quantity > recipientEditionRemainingMints

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: quantity = recipientEditionRemainingMints

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.VARIABLE
  Expression: stagePhaseLimit = stage.phaseLimit

  ID: 31
  Type: NodeType.IF
  Expression: stagePhaseLimit == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: stagePhaseLimit = MAX_EDITION_SIZE

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.IF
  Expression: editionMintedTotal >= stagePhaseLimit

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: revert StageSoldOut()()

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.VARIABLE
  Expression: stageRemainingMints = stagePhaseLimit - editionMintedTotal

  ID: 38
  Type: NodeType.IF
  Expression: quantity > stageRemainingMints

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: quantity = stageRemainingMints

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.RETURN
  Expression: quantity

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 10
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 19
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 29
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  32 -> 33
  33 -> 34
  34 -> 35
  34 -> 36
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  39 -> 40
  40 -> 41

Function: _checkMintSignature
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: signatureReleased || _editions[editionId].signatureReleased

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: nonce > block.number

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert InvalidSignatureNonce()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: nonce + SIGNATURE_VALID_BLOCKS < block.number

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert SignatureExpired()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: nonce <= _editionMinters[editionId][recipient].lastUsedNonce

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert SignatureAlreadyUsed()()

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: messageHash = _hashMintParams(editionId,recipient,quantity,nonce,maxMints)

  ID: 14
  Type: NodeType.IF
  Expression: messageHash.recover(signature) != fairxyzsigner

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert InvalidSignature()()

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16

Function: _verifyPayment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value != quantity * costPerToken

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert IncorrectEthValue()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _handleEditionMinting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: editionMinter = _editionMinters[editionId][recipient]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: recipientStageMints = _editionStageMints[editionId][stageIndex][recipient]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: editionMintedTotal = _editionMintedCount[editionId]

  ID: 4
  Type: NodeType.VARIABLE
  Expression: allowedQuantity = _calculateAllowedMintQuantity(quantity,editionId,editionMintedTotal,stage,editionMinter.mintedCount,recipientStageMints,signatureMaxMints)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _editionMinters[editionId][recipient] = EditionMinter(editionMinter.mintedCount + uint40(allowedQuantity),signatureNonce)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _editionStageMints[editionId][stageIndex][recipient] += allowedQuantity

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _editionMintedCount[editionId] += allowedQuantity

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _mintEditionTokens(recipient,editionId,allowedQuantity,editionMintedTotal)

  ID: 9
  Type: NodeType.RETURN
  Expression: EditionMintingHandler(allowedQuantity,editionMintedTotal)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: _handleEmissionAndTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: EditionStageMint(editionId,stageIndex,recipient,allowedQuantity,editionMintedTotal + allowedQuantity)

  ID: 2
  Type: NodeType.IF
  Expression: allowedQuantity < quantity

  ID: 3
  Type: NodeType.VARIABLE
  Expression: refundAmount = (quantity - allowedQuantity) * costPerToken

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: address(msg.sender).sendValue(refundAmount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _setMintingExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _mintingExtension = newMintingExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MintingExtension(newMintingExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _setRoyaltyExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _royaltyExtension = newRoyaltyExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RoyaltyExtension(newRoyaltyExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _deleteEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editionDeleted[editionId] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionDeleted(editionId)

Edges:
  0 -> 1
  1 -> 2

Function: _editionExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: editionId == 0 || editionId > _editionsCount || _editionDeleted[editionId]

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _editionMintLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: editionMaxSupply == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: limit = MAX_EDITION_SIZE

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: limit = editionMaxSupply

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: limit

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _hashMintParams
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: digest = _hashTypedDataV4(keccak256(bytes)(abi.encode(EIP712_EDITION_MINT_TYPE_HASH,editionId,recipient,quantity,nonce,maxMints)))

  ID: 2
  Type: NodeType.RETURN
  Expression: digest

Edges:
  0 -> 1
  1 -> 2

Function: _hashTypedDataV4
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: domainSeparator = keccak256(bytes)(abi.encode(EIP712_DOMAIN_TYPE_HASH,EIP712_NAME_HASH,EIP712_VERSION_HASH,block.chainid,address(this)))

  ID: 2
  Type: NodeType.RETURN
  Expression: ECDSAUpgradeable.toTypedDataHash(domainSeparator,structHash)

Edges:
  0 -> 1
  1 -> 2

Function: _maxRecipientsPerAirdrop
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: MAX_RECIPIENTS_PER_AIRDROP

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyalty

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: DefaultRoyalty(address(0),0)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyalty = Royalty(receiver,royaltyFraction)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: DefaultRoyalty(receiver,royaltyFraction)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyValidRoyaltyFraction(royaltyFraction)

Edges:
  0 -> 8
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  8 -> 1

Function: _setEditionURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: bytes(uri).length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidURI()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _editionURI[editionId] = uri

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: EditionURI(editionId,uri)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5

Function: _setEditionURIExtension
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _editionURIExtension[editionId] = uriExtension

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EditionURIExtension(editionId,uriExtension)

Edges:
  0 -> 1
  1 -> 2

Function: _stagesRegistry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IFairxyzMintStagesRegistry(FAIRXYZ_STAGES_REGISTRY)

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IFairxyz721Editions).interfaceId || Fairxyz721Upgradeable.supportsInterface(interfaceId) || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: _checkRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: __ReentrancyGuard_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ReentrancyGuard_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ReentrancyGuard_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __Ownable2Step_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable2Step_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: pendingOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _pendingOwner

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: __Multicall_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Multicall_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: multicall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: results = new bytes[](data.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < data.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: results[i] = AddressUpgradeable.functionDelegateCall(address(this),data[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: results

  ID: 9
  Type: NodeType.RETURN
  Expression: results

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: __AccessControl_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __AccessControl_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: hasRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].members[account]

Edges:
  0 -> 1

Function: getRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _roles[role].adminRole

Edges:
  0 -> 1

Function: grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyRole(getRoleAdmin(role))

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: renounceRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _revokeRole(role,account)

Edges:
  0 -> 1
  1 -> 2

Function: _setupRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _grantRole(role,account)

Edges:
  0 -> 1

Function: _setRoleAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: previousAdminRole = getRoleAdmin(role)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].adminRole = adminRole

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleAdminChanged(role,previousAdminRole,adminRole)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _grantRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleGranted(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: _revokeRole
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: hasRole(role,account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _roles[role].members[account] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: RoleRevoked(role,account,_msgSender())

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __FairxyzOperatorFilterer_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __FairxyzOperatorFilterer_init_unchained(enabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __FairxyzOperatorFilterer_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: enabled && REGISTRY_ADDRESS.code.length > 0 && DEFAULT_SUBSCRIPTION_ADDRESS != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: IOperatorFilterRegistry(REGISTRY_ADDRESS).registerAndSubscribe(address(this),DEFAULT_SUBSCRIPTION_ADDRESS)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: toggleOperatorFilterDisabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: disabled = ! operatorFilterDisabled

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = disabled

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OperatorFilterDisabled(disabled)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: __Fairxyz721_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Fairxyz721_init_unchained(name_,symbol_)

Edges:
  0 -> 1

Function: __Fairxyz721_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC721: address zero is not a valid owner)

  ID: 2
  Type: NodeType.RETURN
  Expression: _balances[owner]

Edges:
  0 -> 1
  1 -> 2

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _ownerOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC721: invalid token ID)

  ID: 3
  Type: NodeType.RETURN
  Expression: owner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: super.approve(to,tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperatorApproval(to)

Edges:
  0 -> 2
  2 -> 1

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_exists(tokenId),ERC721: invalid token ID)

  ID: 2
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId]

Edges:
  0 -> 1
  1 -> 2

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: super.setApprovalForAll(operator,approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperatorApproval(operator)

Edges:
  0 -> 2
  2 -> 1

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenId),ERC721: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,tokenId)

Edges:
  0 -> 1
  1 -> 2

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenId),ERC721: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeTransfer(from,to,tokenId,data)

Edges:
  0 -> 1
  1 -> 2

Function: _safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_checkOnERC721Received(from,to,tokenId,data),ERC721: transfer to non ERC721Receiver implementer)

Edges:
  0 -> 1
  1 -> 2

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _ownerOf(tokenId) != address(0)

Edges:
  0 -> 1

Function: _isApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.RETURN
  Expression: (spender == owner || isApprovedForAll(owner,spender) || _tokenApprovals[tokenId] == spender)

Edges:
  0 -> 1
  1 -> 2

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(owner,address(0),tokenId,1)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: delete _tokenApprovals[tokenId]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _balances[owner] -= 1

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: delete _owners[tokenId]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(owner,address(0),tokenId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(owner,address(0),tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ownerOf(tokenId) == from,ERC721: transfer from incorrect owner)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC721: transfer to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(from,to,tokenId,1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: delete _tokenApprovals[tokenId]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _balances[from] -= 1

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += 1

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _owners[tokenId] = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,tokenId)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId] = to

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(ownerOf(tokenId),to,tokenId)

Edges:
  0 -> 1
  1 -> 2

Function: _setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != operator,ERC721: approve to caller)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[owner][operator] = approved

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(owner,operator,approved)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _checkOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: retval = IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(),from,tokenId,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: retval == IERC721ReceiverUpgradeable.onERC721Received.selector

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC721: transfer to non ERC721Receiver implementer)

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: true

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 12
  2 -> 3
  2 -> 5
  2 -> 13
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 13

Function: _afterTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: __unsafe_increaseBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

Edges:
  0 -> 1

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Fairxyz721_init(name_,symbol_)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: __FairxyzEditions_init(owner_,defaultMintingExtension,defaultRoyaltyExtension)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: __FairxyzOperatorFilterer_init(operatorFilterEnabled_)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _batchCreateEditionsWithStages(editions_)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(treasury_,defaultRoyalty_)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: initializer()

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _isApprovedOrOwner(msg.sender,tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NotApprovedOrOwner()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: editionId = _tokenEditionId(tokenId)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _burn(tokenId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _tokenBurned[tokenId] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _editionBurnedCount[editionId] ++

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setTokenRoyalty(tokenId,receiver,royaltyFraction)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

Edges:
  0 -> 2
  2 -> 1

Function: setTokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _tokenURI[tokenId] = uri

  ID: 2
  Type: NodeType.IF
  Expression: _exists(tokenId)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MetadataUpdate(tokenId)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyCreator()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  5 -> 1

Function: _editionRangeStart
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: editionId * EDITION_RANGE_SIZE

Edges:
  0 -> 1

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: receiver == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: delete _tokenRoyalty[tokenId]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TokenRoyalty(tokenId,address(0),0)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _tokenRoyalty[tokenId] = Royalty(receiver,royaltyFraction)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: TokenRoyalty(tokenId,receiver,royaltyFraction)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyValidRoyaltyFraction(royaltyFraction)

Edges:
  0 -> 8
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  8 -> 1

Function: _tokenEditionId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenId < EDITION_RANGE_SIZE

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert TokenDoesNotExist()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: tokenId % EDITION_RANGE_SIZE == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert TokenDoesNotExist()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: tokenId / EDITION_RANGE_SIZE

  ID: 8
  Type: NodeType.RETURN
  Expression: editionId

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _royaltyExtension != address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: IERC2981Upgradeable(_royaltyExtension).royaltyInfo(tokenId,salePrice)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: royalty = _tokenRoyalty[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: royalty.receiver == address(0)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: editionId = _tokenEditionId(tokenId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: royalty = _editionRoyalty[editionId]

  ID: 8
  Type: NodeType.IF
  Expression: royalty.receiver == address(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: royalty = _defaultRoyalty

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: receiver = royalty.receiver

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: royaltyAmount = (salePrice * royalty.royaltyFraction) / ROYALTY_DENOMINATOR

  ID: 14
  Type: NodeType.RETURN
  Expression: (receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert TokenDoesNotExist()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: editionId = _tokenEditionId(tokenId)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: _editionURIExtension[editionId] != address(0)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: uri = ITokenURI(_editionURIExtension[editionId]).tokenURI(tokenId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: uri = _tokenURI[tokenId]

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: bytes(uri).length == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(_editionURI[editionId],(tokenId % EDITION_RANGE_SIZE).toString()))

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: uri

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13

Function: _beforeTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0) || to == address(0)

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: _editions[_tokenEditionId(firstTokenId)].soulbound

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert NotTransferable()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperator(msg.sender,from)

Edges:
  0 -> 7
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  7 -> 1

Function: _emitMetadataUpdateEvent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: mintedCount = _editionMintedCount[editionId]

  ID: 2
  Type: NodeType.IF
  Expression: mintedCount == 1

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MetadataUpdate(_editionRangeStart(editionId) + 1)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: _editionMintedCount[editionId] > 1

  ID: 6
  Type: NodeType.VARIABLE
  Expression: rangeStart = _editionRangeStart(editionId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: BatchMetadataUpdate(rangeStart + 1,rangeStart + mintedCount)

  ID: 8
  Type: NodeType.RETURN
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  7 -> 8

Function: _isOperatorFilterAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: sender == owner() || hasRole(DEFAULT_ADMIN_ROLE,sender)

Edges:
  0 -> 1

Function: _mintEditionTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: quantity == 0 || quantity > MAX_MINTS_PER_TRANSACTION

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidMintQuantity()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: firstTokenId = _editionRangeStart(editionId) + editionMintedCount + 1

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(address(0),recipient,firstTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _tokenMinter[firstTokenId] = recipient

  ID: 7
  Type: NodeType.VARIABLE
  Expression: tokenId = firstTokenId

  ID: 8
  Type: NodeType.VARIABLE
  Expression: stop = firstTokenId + quantity

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.IFLOOP
  Expression: tokenId < stop

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),recipient,tokenId)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ++ tokenId

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: recipient.isContract()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: tokenId = firstTokenId

  ID: 16
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 17
  Type: NodeType.IFLOOP
  Expression: tokenId < stop

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_checkOnERC721Received(address(0),recipient,tokenId,),ERC721: transfer to non ERC721Receiver implementer)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ++ tokenId

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: __unsafe_increaseBalance(recipient,quantity)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(address(0),recipient,firstTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 11
  10 -> 13
  11 -> 12
  12 -> 10
  13 -> 14
  14 -> 15
  14 -> 21
  15 -> 16
  16 -> 18
  17 -> 18
  17 -> 20
  18 -> 19
  19 -> 17
  20 -> 21
  21 -> 22
  22 -> 23

Function: _ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _tokenBurned[tokenId]

  ID: 2
  Type: NodeType.RETURN
  Expression: address(0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tokenOwner = _owners[tokenId]

  ID: 5
  Type: NodeType.IF
  Expression: tokenOwner != address(0)

  ID: 6
  Type: NodeType.RETURN
  Expression: tokenOwner

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: editionId = _tokenEditionId(tokenId)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: editionRangeStart = _editionRangeStart(editionId)

  ID: 10
  Type: NodeType.IF
  Expression: tokenId > editionRangeStart + _editionMintedCount[editionId]

  ID: 11
  Type: NodeType.RETURN
  Expression: address(0)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: tokenOwner == address(0) && tokenId > editionRangeStart

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: tokenOwner = _tokenMinter[tokenId]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: -- tokenId

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: tokenOwner

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DEFAULT_ADMIN_ROLE = 0x00

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_NAME_HASH = keccak256(bytes)(Fair.xyz)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_VERSION_HASH = keccak256(bytes)(2.0.0)

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_DOMAIN_TYPE_HASH = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EIP712_EDITION_MINT_TYPE_HASH = keccak256(bytes)(EditionMint(uint256 editionId,address recipient,uint256 quantity,uint256 nonce,uint256 maxMints))

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CREATOR_ROLE = keccak256(bytes)(CREATOR_ROLE)

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EXTERNAL_MINTER_ROLE = keccak256(bytes)(EXTERNAL_MINTER_ROLE)

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ROYALTY_DENOMINATOR = 10000

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SIGNATURE_VALID_BLOCKS = 75

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: EDITION_RANGE_SIZE = 1_000_000_000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9


