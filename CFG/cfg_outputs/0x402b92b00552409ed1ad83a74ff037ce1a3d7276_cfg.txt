Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(a == 0 || c / a == b)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 2
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Ownable
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1


Contract: ERC20Basic
==================================================


Contract: ERC20
==================================================


Contract: BasicToken
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[msg.sender] && ! locks[_to])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: setLock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: locks[_toLock] = _setTo

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: lockOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: locks[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: lock

Edges:
  0 -> 1


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[msg.sender] && ! locks[_to])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: setLock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: locks[_toLock] = _setTo

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: lockOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: locks[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: lock

Edges:
  0 -> 1

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[_from] && ! locks[_to])

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: increaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 3
  Type: NodeType.RETURN
  Expression: true

  ID: 4
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldValue = allowed[msg.sender][_spender]

  ID: 2
  Type: NodeType.IF
  Expression: _subtractedValue > oldValue

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 7
  Type: NodeType.RETURN
  Expression: true

  ID: 8
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7


Contract: MintableToken
==================================================

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[_from] && ! locks[_to])

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: increaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 3
  Type: NodeType.RETURN
  Expression: true

  ID: 4
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldValue = allowed[msg.sender][_spender]

  ID: 2
  Type: NodeType.IF
  Expression: _subtractedValue > oldValue

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 7
  Type: NodeType.RETURN
  Expression: true

  ID: 8
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[msg.sender] && ! locks[_to])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: setLock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: locks[_toLock] = _setTo

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: lockOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: locks[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: lock

Edges:
  0 -> 1

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! locks[_to])

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.add(_amount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_amount)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Mint(_to,_amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(0x0,_to,_amount)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: canMint()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 1

Function: finishMinting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: mintingFinished = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MintFinished()

  ID: 3
  Type: NodeType.RETURN
  Expression: true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: mintingFinished = false

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = CryptoTask

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = CTF

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

Edges:
  0 -> 1
  1 -> 2


Contract: Crowdsale
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: Crowdsale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: contractDeployedTime = now

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: vault1 = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: token = new MintableToken()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! token.lockOf(msg.sender) && ! crowdsaleClosed && stage < 2 && msg.value >= 1 * (1000000000000000000) / 10)

  ID: 2
  Type: NodeType.IF
  Expression: stage == 1 && (now < presaleEndTime.add(countdownDuration) || amountRaisedPreSale + amountRaisedICO + msg.value > hardCap)

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: amount = msg.value

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] += amount

  ID: 7
  Type: NodeType.IF
  Expression: stage == 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: amountRaisedPreSale += amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: token.mint(msg.sender,amount.mul(2) * price)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: amountRaisedICO += amount

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: token.mint(msg.sender,amount * price)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: FundTransfer(msg.sender,amount,true)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 12
  10 -> 11
  11 -> 12
  12 -> 13

Function: forward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: vault1.transfer(amount.mul(67) / 100)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: vault2.transfer(amount.sub(amount.mul(67) / 100))

Edges:
  0 -> 1
  1 -> 2

Function: checkGoalReached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(stage == 1 && ! crowdsaleClosed)

  ID: 2
  Type: NodeType.IF
  Expression: amountRaisedPreSale + amountRaisedICO >= fundingGoal

  ID: 3
  Type: NodeType.VARIABLE
  Expression: amount = amountRaisedICO / 3

  ID: 4
  Type: NodeType.IF
  Expression: ! icoSuccess

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: amount += amountRaisedPreSale / 3

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: amountToken1 = token.totalSupply().mul(67) / (100 * 4)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: amountToken2 = token.totalSupply().mul(33) / (100 * 4)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: forward(amount)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: icoSuccess = true

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: token.mint(vault1,amountToken1)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: token.mint(vault2,amountToken2)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: stage = 2

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: lastVoteTime = now

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: GoalReached(amountRaisedPreSale + amountRaisedICO)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: crowdsaleClosed = true

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: token.finishMinting()

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: afterDeadline()

Edges:
  0 -> 19
  1 -> 2
  2 -> 3
  2 -> 16
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  19 -> 1

Function: closePresale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((msg.sender == owner || now.sub(contractDeployedTime) > presaleDuration) && stage == 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: stage = 1

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: presaleEndTime = now

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: deadline = now.add(icoDuration.add(countdownDuration))

  ID: 5
  Type: NodeType.IF
  Expression: amountRaisedPreSale.mul(5) > 10000 * 1000000000000000000

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: hardCap = amountRaisedPreSale.mul(5)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: hardCap = 10000 * 1000000000000000000

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: amountRaisedPreSale >= fundingGoal

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amountRaisedPreSale / 3

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: forward(amount)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: icoSuccess = true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: GoalReached(amountRaisedPreSale)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 14
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: safeWithdrawal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(crowdsaleClosed && ! icoSuccess)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: stage == 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: amount = balanceOf[msg.sender]

  ID: 5
  Type: NodeType.IF
  Expression: stage == 2

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: amount = balanceOf[msg.sender].mul(2) / 3

  ID: 7
  Type: NodeType.IF
  Expression: stage == 3

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: amount = balanceOf[msg.sender] / 3

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] = 0

  ID: 13
  Type: NodeType.IF
  Expression: amount > 0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(amount)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: FundTransfer(msg.sender,amount,false)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 11
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 16
  14 -> 15
  15 -> 16

Function: voteAgainst
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((stage == 2 || stage == 3) && ! token.lockOf(msg.sender))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: token.setLock(msg.sender,true)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: voteWeight = token.balanceOf(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: against = against.add(voteWeight)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: voteRelease
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((stage == 2 || stage == 3 || stage == 4) && token.lockOf(msg.sender))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: token.setLock(msg.sender,false)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: voteWeight = token.balanceOf(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: against = against.sub(voteWeight)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: countVotes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(icoSuccess && (stage == 2 || stage == 3) && now.sub(lastVoteTime) > minVoteTime)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: lastVoteTime = now

  ID: 3
  Type: NodeType.IF
  Expression: against > token.totalSupply() / 2

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: icoSuccess = false

  ID: 5
  Type: NodeType.VARIABLE
  Expression: amount = amountRaisedICO / 3 + amountRaisedPreSale / 3

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: forward(amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: stage ++

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: fundingGoal = 1000 * 1000000000000000000

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: amountRaisedPreSale = 0

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: amountRaisedICO = 0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: presaleDuration = 30 * 86400

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: countdownDuration = 45 * 86400

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: icoDuration = 20 * 86400

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: price = 1000

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: icoSuccess = false

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: crowdsaleClosed = false

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: vault2 = 0xC0776D495f9Ed916C87c8C48f34f08E2B9506342

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: stage = 0

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: against = 0

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minVoteTime = 180 * 86400

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12


