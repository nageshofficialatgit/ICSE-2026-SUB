Contract: MainnetLiquityV2Addresses
==================================================

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BOLD_ADDR = 0xb01dd87B29d187F3E3a4Bf6cdAebfb97F3D9aB98

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MULTI_TROVE_GETTER_ADDR = 0xA4a99F8332527A799AC46F616942dBD0d270fC41

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_MARKET_ADDR = 0x38e1F07b954cFaB7239D7acab49997FBaAD96476

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WSTETH_MARKET_ADDR = 0x2D4ef56cb626E9a4C90c156018BA9CE269573c61

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RETH_MARKET_ADDR = 0x3b48169809DD827F22C9e0F2d71ff12Ea7A94a2F

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: LiquityV2Helper
==================================================

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BOLD_ADDR = 0xb01dd87B29d187F3E3a4Bf6cdAebfb97F3D9aB98

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MULTI_TROVE_GETTER_ADDR = 0xA4a99F8332527A799AC46F616942dBD0d270fC41

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_MARKET_ADDR = 0x38e1F07b954cFaB7239D7acab49997FBaAD96476

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WSTETH_MARKET_ADDR = 0x2D4ef56cb626E9a4C90c156018BA9CE269573c61

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RETH_MARKET_ADDR = 0x3b48169809DD827F22C9e0F2d71ff12Ea7A94a2F

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ETH_GAS_COMPENSATION = 37500000000000000

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_DEBT = 2000e18

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_COLL_INDEX = 0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WSTETH_COLL_INDEX = 1

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RETH_COLL_INDEX = 2

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9


Contract: IERC20
==================================================


Contract: IWETH
==================================================


Contract: Address
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: codehash = extcodehash(uint256)(account)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (codehash != accountHash && codehash != 0x0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balance = address(this).balance

  ID: 2
  Type: NodeType.IF
  Expression: balance < amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientBalance(uint256,uint256)(balance,amount)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 7
  Type: NodeType.IF
  Expression: ! (success)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert SendingValueFail()()

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balance = address(this).balance

  ID: 2
  Type: NodeType.IF
  Expression: balance < value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientBalanceForCall(uint256,uint256)(balance,value)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: _functionCallWithValue(target,data,value,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: _functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! (isContract(target))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NonContractCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: weiValue}(data)

  ID: 7
  Type: NodeType.IF
  Expression: success

  ID: 8
  Type: NodeType.RETURN
  Expression: returndata

  ID: 9
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: returndata_size__functionCallWithValue_asm_0 = mload(uint256)(returndata)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__functionCallWithValue_asm_0)

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  9 -> 15
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 16
  15 -> 16
  16 -> 17


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value))

Edges:
  0 -> 1

Function: safeApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: approvalCall = abi.encodeWithSelector(token.approve.selector,spender,value)

  ID: 2
  Type: NodeType.IF
  Expression: ! _callOptionalReturnBool(token,approvalCall)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,0))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,approvalCall)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _callOptionalReturn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: returndata = address(token).functionCall(data,SafeERC20: low-level call failed)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(returndata.length == 0 || abi.decode(returndata,(bool)),SafeERC20: ERC20 operation did not succeed)

Edges:
  0 -> 1
  1 -> 2

Function: _callOptionalReturnBool
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = address(token).call(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: success && (returndata.length == 0 || abi.decode(returndata,(bool))) && address(token).code.length > 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: TokenUtils
==================================================

Function: approveToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _tokenAddr == ETH_ADDR

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: IERC20(_tokenAddr).allowance(address(this),_to) < _amount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IERC20(_tokenAddr).safeApprove(_to,_amount)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6

Function: pullTokensIfNeeded
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _amount == type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _amount = getBalance(_token,_from)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: _from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IERC20(_token).safeTransferFrom(_from,address(this),_amount)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: _amount

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: withdrawTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _amount == type()(uint256).max

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _amount = getBalance(_token,address(this))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: _to != address(0) && _to != address(this) && _amount != 0

  ID: 5
  Type: NodeType.IF
  Expression: _token != ETH_ADDR

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: IERC20(_token).safeTransfer(_to,_amount)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (success,None) = _to.call{value: _amount}()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Eth send fail)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: _amount

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 11
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: depositWeth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH_ADDR).deposit{value: _amount}()

Edges:
  0 -> 1

Function: withdrawWeth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH_ADDR).withdraw(_amount)

Edges:
  0 -> 1

Function: getBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _tokenAddr == ETH_ADDR

  ID: 2
  Type: NodeType.RETURN
  Expression: _acc.balance

  ID: 3
  Type: NodeType.RETURN
  Expression: IERC20(_tokenAddr).balanceOf(_acc)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3

Function: getTokenDecimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _token == ETH_ADDR

  ID: 2
  Type: NodeType.RETURN
  Expression: 18

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: IERC20(_token).decimals()

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE

Edges:
  0 -> 1


Contract: IAddressesRegistry
==================================================


Contract: IBorrowerOperations
==================================================


Contract: IHintHelpers
==================================================


Contract: IMultiTroveGetter
==================================================


Contract: IPriceFeed
==================================================


Contract: ISortedTroves
==================================================


Contract: IStabilityPool
==================================================


Contract: ITroveManager
==================================================


Contract: ITroveNFT
==================================================


Contract: LiquityV2View
==================================================

Function: isShutDown
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.RETURN
  Expression: troveManager.shutdownTime() != 0

Edges:
  0 -> 1
  1 -> 2

Function: getApproxHint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: hintHelpers = IHintHelpers(IAddressesRegistry(_market).hintHelpers())

  ID: 2
  Type: NodeType.RETURN
  Expression: hintHelpers.getApproxHint(_collIndex,_interestRate,_numTrials,_inputRandomSeed)

  ID: 3
  Type: NodeType.RETURN
  Expression: (hintId,diff,latestRandomSeed)

Edges:
  0 -> 1
  1 -> 2

Function: findInsertPosition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 2
  Type: NodeType.RETURN
  Expression: sortedTroves.findInsertPosition(_interestRate,_prevId,_nextId)

  ID: 3
  Type: NodeType.RETURN
  Expression: (prevId,nextId)

Edges:
  0 -> 1
  1 -> 2

Function: getInsertPosition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (hintId,None,None) = getApproxHint(_market,_collIndex,_interestRate,_numTrials,_inputRandomSeed)

  ID: 3
  Type: NodeType.RETURN
  Expression: findInsertPosition(_market,_interestRate,hintId,hintId)

  ID: 4
  Type: NodeType.RETURN
  Expression: (prevId,nextId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getTrovePosition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: troveInterestRate = troveManager.getTroveAnnualInterestRate(_troveId)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (hintId,None,None) = getApproxHint(_market,_collIndex,troveInterestRate,_numTrials,_inputRandomSeed)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (prevId,nextId) = sortedTroves.findInsertPosition(troveInterestRate,hintId,hintId)

  ID: 7
  Type: NodeType.IF
  Expression: prevId == _troveId

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: prevId = sortedTroves.getPrev(_troveId)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: nextId == _troveId

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: nextId = sortedTroves.getNext(_troveId)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: (prevId,nextId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: getTroveInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: priceFeed = IPriceFeed(IAddressesRegistry(_market).priceFeed())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: latestTroveData = troveManager.getLatestTroveData(_troveId)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: troveNFT = ITroveNFT(IAddressesRegistry(_market).troveNFT())

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (None,None,None,trove.status,None,None,None,None,trove.interestBatchManager,trove.batchDebtShares) = troveManager.Troves(_troveId)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: trove.troveId = _troveId

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: trove.annualInterestRate = latestTroveData.annualInterestRate

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: trove.collAmount = latestTroveData.entireColl

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: trove.debtAmount = latestTroveData.entireDebt

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (trove.collPrice,None) = priceFeed.fetchPrice()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: trove.TCRatio = troveManager.getCurrentICR(_troveId,trove.collPrice)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: trove.collToken = IAddressesRegistry(_market).collToken()

  ID: 13
  Type: NodeType.TRY
  Expression: owner = troveNFT.ownerOf(_troveId)

  ID: 14
  Type: NodeType.CATCH
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: trove.owner = owner

  ID: 16
  Type: NodeType.CATCH
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: trove.owner = address(0)

  ID: 18
  Type: NodeType.RETURN
  Expression: trove

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 16
  14 -> 15
  15 -> 18
  16 -> 17
  17 -> 18

Function: getUserTroves
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nextFreeTroveIndex = - 1

  ID: 2
  Type: NodeType.VARIABLE
  Expression: market = IAddressesRegistry(_market)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(market.troveManager())

  ID: 4
  Type: NodeType.VARIABLE
  Expression: troveNFT = ITroveNFT(market.troveNFT())

  ID: 5
  Type: NodeType.VARIABLE
  Expression: numTroves = _endIndex - _startIndex

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: troves = new LiquityV2View.ExistingTrove[](numTroves)

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = _startIndex

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < _endIndex

  ID: 11
  Type: NodeType.VARIABLE
  Expression: troveId = uint256(keccak256(bytes)(abi.encode(_user,i)))

  ID: 12
  Type: NodeType.VARIABLE
  Expression: status = troveManager.getTroveStatus(troveId)

  ID: 13
  Type: NodeType.IF
  Expression: status == ITroveManager.Status.active || status == ITroveManager.Status.zombie

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: troves[i - _startIndex] = ExistingTrove({troveId:troveId,ownedByUser:troveNFT.ownerOf(troveId) == _user})

  ID: 15
  Type: NodeType.IF
  Expression: nextFreeTroveIndex == - 1

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: nextFreeTroveIndex = int256(i)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 20
  Type: NodeType.RETURN
  Expression: (troves,nextFreeTroveIndex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 20
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 18
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 10

Function: getMarketData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = IAddressesRegistry(_market)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: borrowerOperations = registry.borrowerOperations()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (collPrice,None) = IPriceFeed(registry.priceFeed()).fetchPrice()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: data = MarketData({market:_market,CCR:registry.CCR(),MCR:registry.MCR(),SCR:registry.SCR(),LIQUIDATION_PENALTY_SP:registry.LIQUIDATION_PENALTY_SP(),LIQUIDATION_PENALTY_REDISTRIBUTION:registry.LIQUIDATION_PENALTY_REDISTRIBUTION(),entireSystemColl:IBorrowerOperations(borrowerOperations).getEntireSystemColl(),entireSystemDebt:IBorrowerOperations(borrowerOperations).getEntireSystemDebt(),collToken:registry.collToken(),troveNFT:registry.troveNFT(),borrowerOperations:borrowerOperations,troveManager:registry.troveManager(),stabilityPool:registry.stabilityPool(),sortedTroves:registry.sortedTroves(),collSurplusPool:registry.collSurplusPool(),activePool:registry.activePool(),hintHelpers:registry.hintHelpers(),priceFeed:registry.priceFeed(),collPrice:collPrice,isShutDown:isShutDown(_market),boldDepositInSp:IStabilityPool(registry.stabilityPool()).getTotalBoldDeposits()})

  ID: 6
  Type: NodeType.RETURN
  Expression: data

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: getDepositorInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: stabilityPool = IStabilityPool(IAddressesRegistry(_market).stabilityPool())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: compoundedBOLD = stabilityPool.getCompoundedBoldDeposit(_depositor)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: collGain = stabilityPool.getDepositorCollGain(_depositor) + stabilityPool.stashedColl(_depositor)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: boldGain = stabilityPool.getDepositorYieldGain(_depositor)

  ID: 5
  Type: NodeType.RETURN
  Expression: (compoundedBOLD,collGain,boldGain)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: getDebtInFront
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: next = _troveId

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: debt = _acc

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < _iterations

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: next = sortedTroves.getNext(next)

  ID: 10
  Type: NodeType.IF
  Expression: next == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: (next,debt)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: debt += _getTroveDebt(troveManager,next)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 15
  Type: NodeType.RETURN
  Expression: (next,debt)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 15
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  14 -> 8

Function: getDebtInFrontByInterestRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: debt = _acc

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < _iterations && next != 0

  ID: 9
  Type: NodeType.IF
  Expression: troveManager.getTroveAnnualInterestRate(next) >= _targetIR

  ID: 10
  Type: NodeType.RETURN
  Expression: (0,debt)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: debt += _getTroveDebt(troveManager,next)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: next = ISortedTroves(sortedTroves).getPrev(next)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 15
  Type: NodeType.IF
  Expression: _troveId == 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: next = sortedTroves.getLast()

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: next = _troveId

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: (next,debt)

Edges:
  0 -> 1
  1 -> 2
  2 -> 15
  4 -> 7
  5 -> 8
  6 -> 19
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  9 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 8
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 4

Function: getDebtInFrontByTroveNum
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: next = sortedTroves.getLast()

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < _numTroves

  ID: 8
  Type: NodeType.IF
  Expression: next == 0

  ID: 9
  Type: NodeType.RETURN
  Expression: debt

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: debt += _getTroveDebt(troveManager,next)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: next = sortedTroves.getPrev(next)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: debt

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 14
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 7

Function: getNumOfTrovesInFrontOfTrove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sortedTroves = ISortedTroves(IAddressesRegistry(_market).sortedTroves())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: next = _troveId

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < _iterations

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: next = sortedTroves.getNext(next)

  ID: 8
  Type: NodeType.IF
  Expression: next == 0

  ID: 9
  Type: NodeType.RETURN
  Expression: (next,numTroves)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: numTroves ++

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.RETURN
  Expression: (next,numTroves)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 13
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  12 -> 6

Function: predictAdjustTroveUpfrontFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: market = IAddressesRegistry(_market)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: hintHelpers = IHintHelpers(market.hintHelpers())

  ID: 3
  Type: NodeType.RETURN
  Expression: hintHelpers.predictAdjustTroveUpfrontFee(_collIndex,_troveId,_debtIncrease)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _getTroveDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (debt,None,None,None,None,None,None,None,None,None) = _troveManager.Troves(_troveId)

  ID: 2
  Type: NodeType.RETURN
  Expression: debt

Edges:
  0 -> 1
  1 -> 2

Function: getMultipleSortedTroves
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: collIndex = _getCollIndexFromMarket(_market)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: troves = IMultiTroveGetter(MULTI_TROVE_GETTER_ADDR).getMultipleSortedTroves(collIndex,_startIdx,_count)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < troves.length

  ID: 8
  Type: NodeType.VARIABLE
  Expression: latestTroveData = troveManager.getLatestTroveData(troves[i].id)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: troves[i].debt = latestTroveData.entireDebt

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: troves[i].coll = latestTroveData.entireColl

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: troves[i].annualInterestRate = latestTroveData.annualInterestRate

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: troves[i].lastInterestRateAdjTime = latestTroveData.lastInterestRateAdjTime

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.RETURN
  Expression: troves

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 14
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 7

Function: getBatchManagerInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: borrowOps = IBorrowerOperations(IAddressesRegistry(_market).borrowerOperations())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: troveManager = ITroveManager(IAddressesRegistry(_market).troveManager())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: managerData = borrowOps.getInterestBatchManager(_manager)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: batchData = troveManager.getLatestBatchData(_manager)

  ID: 5
  Type: NodeType.RETURN
  Expression: (managerData,batchData)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _getCollIndexFromMarket
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _market == WETH_MARKET_ADDR

  ID: 2
  Type: NodeType.RETURN
  Expression: WETH_COLL_INDEX

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: _market == WSTETH_MARKET_ADDR

  ID: 5
  Type: NodeType.RETURN
  Expression: WSTETH_COLL_INDEX

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: _market == RETH_MARKET_ADDR

  ID: 8
  Type: NodeType.RETURN
  Expression: RETH_COLL_INDEX

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert InvalidMarketAddress()()

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BOLD_ADDR = 0xb01dd87B29d187F3E3a4Bf6cdAebfb97F3D9aB98

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MULTI_TROVE_GETTER_ADDR = 0xA4a99F8332527A799AC46F616942dBD0d270fC41

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_MARKET_ADDR = 0x38e1F07b954cFaB7239D7acab49997FBaAD96476

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WSTETH_MARKET_ADDR = 0x2D4ef56cb626E9a4C90c156018BA9CE269573c61

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RETH_MARKET_ADDR = 0x3b48169809DD827F22C9e0F2d71ff12Ea7A94a2F

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ETH_GAS_COMPENSATION = 37500000000000000

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_DEBT = 2000e18

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_COLL_INDEX = 0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WSTETH_COLL_INDEX = 1

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RETH_COLL_INDEX = 2

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9


