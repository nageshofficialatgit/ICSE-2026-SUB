Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2


Contract: IERC20
==================================================


Contract: IERC20Metadata
==================================================


Contract: ERC20
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,amount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,amount)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: increaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - subtractedValue)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - amount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += amount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),account,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - amount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: msgSender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = msgSender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(address(0),msgSender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1


Contract: Address
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: account.code.length > 0

Edges:
  0 -> 1

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: returndata

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 7

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: IPriceFeed
==================================================


Contract: ILpPair
==================================================


Contract: IWETH
==================================================


Contract: IDexRouter
==================================================


Contract: IDexFactory
==================================================


Contract: UNCXLocker
==================================================


Contract: IVault
==================================================


Contract: Vault
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: parentToken = _parentToken

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: incubatorAddress = _incubatorAddress

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: overrideAddress = _overrideAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: approveTaxesFullyForTeam
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! incubatorRejected,Taxes rejected)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: incubatorFullApproved = true

  ID: 3
  Type: NodeType.IF
  Expression: address(this).balance > 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ethRelease(address(this).balance)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: IERC20(parentToken).balanceOf(address(this)) > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tokenRelease(IERC20(parentToken).balanceOf(address(this)))

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyIncubator()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  9 -> 1

Function: tokenRelease
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: teamWallet = SparkStarterToken(address(parentToken)).teamTokenAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: IERC20(parentToken).transfer(teamWallet,tokenAmount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: tokensDispersed += tokenAmount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyIncubator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: ethRelease
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: token = SparkStarterToken(address(parentToken))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ethAmount <= address(this).balance,Not enough ETH)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: taxAddress1Split = token.taxAddress1Split()

  ID: 4
  Type: NodeType.VARIABLE
  Expression: taxAddress1 = token.taxAddress1()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: taxAddress2 = token.taxAddress2()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: taxAddress1Split == 10000

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: ethAmount}()

  ID: 9
  Type: NodeType.VARIABLE
  Expression: taxAddress1Portion = ethAmount * taxAddress1Split / FEE_DIVISOR

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: taxAddress1Portion}()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress2.call{value: ethAmount - taxAddress1Portion}()

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ethDispersed += ethAmount

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onlyIncubator()

Edges:
  0 -> 14
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 12
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  14 -> 1

Function: forceBuyBack
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! incubatorFullApproved,Taxes already approved)

  ID: 2
  Type: NodeType.IF
  Expression: ! incubatorRejected

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: incubatorRejected = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SparkStarterToken(address(parentToken)).buyBackAndBurn{value: ethAmount}(minOutput)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: tokenBalance = IERC20(parentToken).balanceOf(address(this))

  ID: 7
  Type: NodeType.IF
  Expression: tokenBalance > 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: IERC20(parentToken).transfer(address(0xdead),tokenBalance)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyIncubator()

Edges:
  0 -> 10
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  10 -> 1

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ethReceived += msg.value

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FEE_DIVISOR = 10000

Edges:


Contract: IVaultFactory
==================================================


Contract: VaultFactory
==================================================

Function: createVault
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: vault = address(new Vault(_incubatorAddress,_overrideAddress,_parentToken))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: VaultCreated(vault,_parentToken)

  ID: 3
  Type: NodeType.RETURN
  Expression: vault

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: SparkStarterToken
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: vaultAddress = IVaultFactory(_vaultFactory).createVault(_tokenInfo._incubatorWallet,_platformAddress,address(this))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._teamTokenPercent <= 9999)

  ID: 3
  Type: NodeType.IF
  Expression: _tokenInfo._vestTeamTokens

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _mint(address(vaultAddress),_tokenInfo._supply * 1e18 * _tokenInfo._teamTokenPercent / 10000)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _mint(address(this),_tokenInfo._supply * 1e18 - balanceOf(vaultAddress))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _mint(_tokenInfo._teamTokensWallet,_tokenInfo._supply * 1e18 * _tokenInfo._teamTokenPercent / 10000)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _mint(address(this),_tokenInfo._supply * 1e18 - balanceOf(_tokenInfo._teamTokensWallet))

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tokenInfo = _tokenInfo

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: dynamicTaxOn = true

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: whitelistActive = _tokenInfo._isWhitelistLaunch

  ID: 15
  Type: NodeType.IF
  Expression: block.chainid == 1

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD] = true

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x000000fee13a103A10D593b9AE06b3e05F2E7E1c] = true

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af] = true

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _tokenLocker = 0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419

  ID: 22
  Type: NodeType.IF
  Expression: block.chainid == 11155111

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0xa3D89E5B9C7a863BF4535F349Bc5619ABe72fb09

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x694AA1769357215DE4FAC081bf1f309aDC325306

  ID: 25
  Type: NodeType.IF
  Expression: block.chainid == 8453

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: _v2Router = 0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD] = true

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x5d64D14D2CF4fe5fe4e65B1c7E3D11e18D493091] = true

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[0x6fF5693b99212Da76ad316178A184AB56D299b43] = true

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _tokenLocker = 0xc4E637D37113192F4F1F060DaEbD7758De7F4131

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _priceFeed = 0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Chain not configured)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: priceFeed = IPriceFeed(_priceFeed)

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: dexRouter = IDexRouter(_v2Router)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: tokenLocker = _tokenLocker

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: swapTokensAtAmt = totalSupply() * 25 / 100000

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: taxAddress1 = _tokenInfo._taxWallet1

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: taxAddress2 = _tokenInfo._taxWallet2

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: incubatorAddress = _tokenInfo._incubatorWallet

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: platformAddress = _platformAddress

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: teamTokenAddress = _tokenInfo._teamTokensWallet

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: buyTax = _tokenInfo._buyTaxes[0]

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._buyTaxes.length == 5)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._buyTaxes[1] >= _tokenInfo._buyTaxes[2] && _tokenInfo._buyTaxes[2] >= _tokenInfo._buyTaxes[3] && _tokenInfo._buyTaxes[3] >= _tokenInfo._buyTaxes[4],Cannot increase buy tax over time)

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: sellTax = _tokenInfo._sellTaxes[0]

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._sellTaxes.length == 5)

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._sellTaxes[1] >= _tokenInfo._sellTaxes[2] && _tokenInfo._sellTaxes[2] >= _tokenInfo._sellTaxes[3] && _tokenInfo._sellTaxes[3] >= _tokenInfo._sellTaxes[4],Cannot increase sell tax over time)

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * _tokenInfo._maxWallets[0] / 10000)

  ID: 52
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenInfo._maxWallets.length == 5)

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_tokenInfo._maxWallets[1] <= _tokenInfo._maxWallets[2] && _tokenInfo._maxWallets[2] <= _tokenInfo._maxWallets[3] && _tokenInfo._maxWallets[3] <= _tokenInfo._maxWallets[4],Cannot decrease max wallet over time)

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: taxAddress1Split = _tokenInfo._taxWallet1Split

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(taxAddress1Split <= 10000,Cannot exceed 100%)

  ID: 56
  Type: NodeType.IF
  Expression: taxAddress2 == address(0)

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: taxAddress1Split = 10000

  ID: 58
  Type: NodeType.ENDIF
  Expression: 

  ID: 59
  Type: NodeType.EXPRESSION
  Expression: WETH = dexRouter.WETH()

  ID: 60
  Type: NodeType.EXPRESSION
  Expression: lpPair = IDexFactory(dexRouter.factory()).createPair(address(this),WETH)

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: isAMMPair[lpPair] = true

  ID: 62
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[lpPair] = true

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[msg.sender] = true

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[address(this)] = true

  ID: 65
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[address(0xdead)] = true

  ID: 66
  Type: NodeType.EXPRESSION
  Expression: exemptFromLimits[address(vaultAddress)] = true

  ID: 67
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[msg.sender] = true

  ID: 68
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(this)] = true

  ID: 69
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(dexRouter)] = true

  ID: 70
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(0xdead)] = true

  ID: 71
  Type: NodeType.EXPRESSION
  Expression: exemptFromFees[address(vaultAddress)] = true

  ID: 72
  Type: NodeType.EXPRESSION
  Expression: _approve(address(this),address(dexRouter),type()(uint256).max)

  ID: 73
  Type: NodeType.EXPRESSION
  Expression: _approve(address(msg.sender),address(dexRouter),totalSupply())

  ID: 74
  Type: NodeType.EXPRESSION
  Expression: ERC20(_tokenInfo._name,_tokenInfo._symbol)

Edges:
  0 -> 74
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 22
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 35
  22 -> 23
  22 -> 25
  23 -> 24
  24 -> 34
  25 -> 26
  25 -> 32
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 33
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 50
  50 -> 51
  51 -> 52
  52 -> 53
  53 -> 54
  54 -> 55
  55 -> 56
  56 -> 57
  56 -> 58
  57 -> 58
  58 -> 59
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64
  64 -> 65
  65 -> 66
  66 -> 67
  67 -> 68
  68 -> 69
  69 -> 70
  70 -> 71
  71 -> 72
  72 -> 73
  74 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,amount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,amount)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: increaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - subtractedValue)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! exemptFromFees[from] && ! exemptFromFees[to]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tradingAllowed,Trading not active)

  ID: 3
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 4
  Type: NodeType.IF
  Expression: whitelistStartTime + 300 <= block.timestamp

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: whitelistActive = false

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[1]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[1]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[1] / FEE_DIVISOR)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: amount -= handleTax(from,to,amount)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: checkLimits(from,to,amount)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: super._transfer(from,to,amount)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (currentMcap,None) = computeMcap()

  ID: 17
  Type: NodeType.IF
  Expression: currentMcap > athMcap

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: athMcap = currentMcap

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 13
  2 -> 3
  3 -> 4
  3 -> 10
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[account] += amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),account,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - amount)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: checkLimits
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: limited

  ID: 2
  Type: NodeType.VARIABLE
  Expression: exFromLimitsTo = exemptFromLimits[to]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: balanceOfTo = balanceOf(to)

  ID: 4
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 5
  Type: NodeType.IF
  Expression: isAMMPair[from] && ! exFromLimitsTo

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[to],Not whitelisted)

  ID: 7
  Type: NodeType.IF
  Expression: isAMMPair[to] && ! exemptFromLimits[from]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[from],Not whitelisted)

  ID: 9
  Type: NodeType.IF
  Expression: ! exFromLimitsTo

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelistedAddress[to] && whitelistedAddress[from],Not whitelisted)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: isAMMPair[from] && ! exFromLimitsTo

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount + balanceOfTo <= maxWallet,Max Wallet)

  ID: 17
  Type: NodeType.IF
  Expression: ! exFromLimitsTo

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount + balanceOfTo <= maxWallet,Max Wallet)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 21
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 14
  5 -> 6
  5 -> 7
  6 -> 13
  7 -> 8
  7 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21

Function: handleTax
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: balanceOf(address(this)) >= swapTokensAtAmt && ! isAMMPair[from] && lastSwapBackBlock + 1 <= block.number

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: convertTaxes()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: dynamicTaxOn && ! whitelistActive

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: setInternalTaxes()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: tax = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: isAMMPair[to]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: taxes = sellTax

  ID: 11
  Type: NodeType.IF
  Expression: isAMMPair[from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: taxes = buyTax

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: taxes > 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tax = uint128(amount * taxes / FEE_DIVISOR)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: super._transfer(from,address(this),tax)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: tax

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 14
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 18
  16 -> 17
  17 -> 18
  18 -> 19

Function: swapTokensForETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: path[0] = address(this)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path[1] = WETH

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmt,0,path,address(this),block.timestamp)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: buyBackAndBurn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: path[0] = WETH

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path[1] = address(this)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(minOutput,path,address(0xdead),block.timestamp + 360)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: convertTaxes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: vault = IVault(vaultAddress)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: contractBalance = balanceOf(address(this))

  ID: 3
  Type: NodeType.IF
  Expression: contractBalance == 0

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: lastSwapBackBlock = block.number

  ID: 7
  Type: NodeType.IF
  Expression: contractBalance > swapTokensAtAmt * 10

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: contractBalance = swapTokensAtAmt * 10

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: contractBalance > 0

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: swapTokensForETH(contractBalance)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: ethBalance = address(this).balance

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: block.timestamp <= launchTimestamp + 2592000

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (success,None) = incubatorAddress.call{value: ethBalance * 2000 / FEE_DIVISOR}()

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (success,None) = platformAddress.call{value: ethBalance * 500 / FEE_DIVISOR}()

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ethBalance = address(this).balance

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: ! vault.incubatorRejected()

  ID: 20
  Type: NodeType.IF
  Expression: ! vaultUnlocked

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: vaultUnlocked = vault.incubatorFullApproved()

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.IF
  Expression: vaultUnlocked

  ID: 24
  Type: NodeType.IF
  Expression: taxAddress1Split == 10000

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: ethBalance}()

  ID: 26
  Type: NodeType.VARIABLE
  Expression: taxAddress1Portion = ethBalance * taxAddress1Split / FEE_DIVISOR

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress1.call{value: taxAddress1Portion}()

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: (success,None) = taxAddress2.call{value: ethBalance - taxAddress1Portion}()

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: (success,None) = address(vault).call{value: ethBalance}()

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: this.buyBackAndBurn{value: ethBalance}(1)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 34
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 18
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 32
  20 -> 21
  20 -> 22
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 30
  24 -> 25
  24 -> 26
  25 -> 29
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 31
  30 -> 31
  31 -> 33
  32 -> 33
  33 -> 34

Function: enableTrading
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! tradingAllowed,Trading already enabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tradingAllowed = true

  ID: 3
  Type: NodeType.IF
  Expression: whitelistActive

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whitelistStartTime = block.timestamp

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: launchTimestamp = whitelistStartTime + 300

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: launchTimestamp = block.timestamp

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[1]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[1]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[1] / FEE_DIVISOR)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: renounceOwnership()

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 10
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 1

Function: whitelistWallets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < wallets.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: whitelistedAddress[wallets[i]] = _whitelist

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4
  7 -> 3

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: setInternalTaxes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentTimestamp = block.timestamp

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: currentTimestamp >= launchTimestamp

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: timeSinceLaunch = currentTimestamp - launchTimestamp

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 900

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: dynamicTaxOn = false

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[4]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[4]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: limited = false

  ID: 12
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 600

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[3]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[3]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[3] / FEE_DIVISOR)

  ID: 16
  Type: NodeType.IF
  Expression: timeSinceLaunch >= 300

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: buyTax = tokenInfo._buyTaxes[2]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: sellTax = tokenInfo._sellTaxes[2]

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: maxWallet = uint128(totalSupply() * tokenInfo._maxWallets[2] / FEE_DIVISOR)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 22
  12 -> 13
  12 -> 16
  13 -> 14
  14 -> 15
  15 -> 21
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: addLp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(address(this).balance > 0 && balanceOf(address(this)) > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: pair = lpPair

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: super._transfer(address(this),address(pair),balanceOf(address(this)))

  ID: 4
  Type: NodeType.IF
  Expression: tokenInfo.lpLockDurationInMonths == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: address(this).balance}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: IERC20(address(WETH)).transfer(address(pair),IERC20(address(WETH)).balanceOf(address(this)))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ILpPair(pair).mint(address(to))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: feeStruct = UNCXLocker(tokenLocker).gFees()

  ID: 9
  Type: NodeType.VARIABLE
  Expression: ethFee = feeStruct.ethFee

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: address(this).balance - ethFee}()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: IERC20(address(WETH)).transfer(address(pair),IERC20(address(WETH)).balanceOf(address(this)))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ILpPair(pair).mint(address(this))

  ID: 13
  Type: NodeType.VARIABLE
  Expression: pairBalance = IERC20(pair).balanceOf(address(this))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: IERC20(pair).approve(tokenLocker,pairBalance)

  ID: 15
  Type: NodeType.IF
  Expression: block.chainid == 8453

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UNCXLocker(tokenLocker).lockLPToken{value: ethFee}(pair,pairBalance,block.timestamp + (tokenInfo.lpLockDurationInMonths * 2592000),address(address(0)),true,address(to),0)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: UNCXLocker(tokenLocker).lockLPToken{value: ethFee}(pair,pairBalance,block.timestamp + (tokenInfo.lpLockDurationInMonths * 2592000),address(address(0)),true,address(to))

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: (startingMcap,None) = computeMcap()

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 21
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 19
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  21 -> 1

Function: computeMcap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalLiquidityInEth = IERC20(address(WETH)).balanceOf(lpPair)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokensRemainingInPool = balanceOf(lpPair)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: totalSupply = totalSupply()

  ID: 4
  Type: NodeType.IF
  Expression: tokensRemainingInPool > 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mcapInEth = totalLiquidityInEth * totalSupply / tokensRemainingInPool

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mcapInUSD = mcapInEth * uint256(priceFeed.latestAnswer()) / 1e26

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (mcapInUSD,mcapInEth)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: limited = true

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FEE_DIVISOR = 10000

Edges:


Contract: SparkStarterTokenFactory
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: platformAddress = _platformAddress

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: authorizedChecker = AuthorizedChecker(_authorizedChecker)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: vaultFactory = _vaultFactory

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: generateToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(authorizedChecker.deployerAddress(msg.sender),invalid deployer)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: newToken = new SparkStarterToken(params,platformAddress,vaultFactory)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: newToken.addLp{value: msg.value}(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: NewTokenCreated(address(newToken))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: newToken.transferOwnership(msg.sender)

  ID: 6
  Type: NodeType.RETURN
  Expression: address(newToken)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: IERCBurn
==================================================


Contract: StructsLibrary
==================================================


Contract: AuthorizedChecker
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: incubatorAddress[_owner] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: deployerAddress[_owner] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: transferOwnership(_owner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(_owner,newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: this

  ID: 2
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1
  1 -> 2

Function: updateIncubator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: incubatorAddress[_address] = _isAuthorized

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: updateDeployerAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: deployersIncubatorAddress[_address] == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: deployersIncubatorAddress[_address] = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(deployersIncubatorAddress[_address] == msg.sender)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: deployerAddress[_address] = _isAuthorized

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyAuthorized()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 1


