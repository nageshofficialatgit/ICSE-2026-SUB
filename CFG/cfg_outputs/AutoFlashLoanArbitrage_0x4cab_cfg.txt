Contract: IERC20
==================================================


Contract: ILinkToken
==================================================


Contract: AggregatorV3Interface
==================================================


Contract: KeeperCompatibleInterface
==================================================


Contract: IProfitOracle
==================================================


Contract: IAavePoolAddressesProvider
==================================================


Contract: IAavePool
==================================================


Contract: IUniswapV3SwapRouter
==================================================


Contract: ISushiV2Router
==================================================


Contract: ICurvePool
==================================================


Contract: IBalancerVault
==================================================


Contract: ReentrancyGuard
==================================================


Contract: Pausable
==================================================

Function: isPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: paused

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = true

Edges:
  0 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = false

Edges:
  0 -> 1


Contract: AutoFlashLoanArbitrage
==================================================

Function: isPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: paused

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = true

Edges:
  0 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = false

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: poolAddressesProvider = IAavePoolAddressesProvider(AAVE_POOL_ADDRESSES_PROVIDER)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: alertReceiver = msg.sender

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: supportedTokens.push(WETH)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: supportedTokens.push(DAI)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: supportedTokens.push(USDC)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: dexRouters.push(UNISWAP_V3_ROUTER)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: dexRouters.push(SUSHISWAP_ROUTER)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: dexRouters.push(CURVE_3POOL)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: dexRouters.push(BALANCER_VAULT)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: isDexSupported[UNISWAP_V3_ROUTER] = true

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: isDexSupported[SUSHISWAP_ROUTER] = true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: isDexSupported[CURVE_3POOL] = true

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: isDexSupported[BALANCER_VAULT] = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: checkUpkeep
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: block.timestamp < lastCheckTimestamp + checkInterval || isPaused() || emergencyMode

  ID: 2
  Type: NodeType.RETURN
  Expression: (false,bytes(Paused or emergency mode))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: ILinkToken(LINK).balanceOf(address(this)) < minLinkBalance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: requestLink(minLinkBalance - ILinkToken(LINK).balanceOf(address(this)))

  ID: 6
  Type: NodeType.RETURN
  Expression: (false,bytes(Insufficient LINK))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: adjustGasLimitDynamically()

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenLength = supportedTokens.length

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < tokenLength

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 17
  Type: NodeType.IFLOOP
  Expression: j < tokenLength

  ID: 18
  Type: NodeType.IF
  Expression: i != j

  ID: 19
  Type: NodeType.VARIABLE
  Expression: tokenIn = supportedTokens[i]

  ID: 20
  Type: NodeType.VARIABLE
  Expression: tokenOut = supportedTokens[j]

  ID: 21
  Type: NodeType.VARIABLE
  Expression: amount = calculateOptimalLoanAmount(tokenIn)

  ID: 22
  Type: NodeType.VARIABLE
  Expression: 

  ID: 23
  Type: NodeType.VARIABLE
  Expression: 

  ID: 24
  Type: NodeType.VARIABLE
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: (profitable,profit,bestDex) = checkArbitrageProfit(tokenIn,tokenOut,amount)

  ID: 26
  Type: NodeType.IF
  Expression: profitable && profit >= minProfitThreshold

  ID: 27
  Type: NodeType.VARIABLE
  Expression: key = keccak256(bytes)(abi.encodePacked(tokenIn,tokenOut,amount,bestDex))

  ID: 28
  Type: NodeType.IF
  Expression: block.timestamp >= lastExecution[key] + timelock

  ID: 29
  Type: NodeType.RETURN
  Expression: (true,abi.encode(tokenIn,tokenOut,amount,bestDex,block.timestamp))

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 35
  Type: NodeType.RETURN
  Expression: (false,bytes(No profitable opportunity))

  ID: 36
  Type: NodeType.RETURN
  Expression: (upkeepNeeded,performData)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 35
  12 -> 10
  13 -> 16
  13 -> 11
  14 -> 17
  15 -> 34
  16 -> 14
  17 -> 18
  17 -> 15
  18 -> 19
  18 -> 32
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  26 -> 31
  27 -> 28
  28 -> 29
  28 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 17
  34 -> 13

Function: performUpkeep
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! emergencyMode,Emergency mode active)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: lastCheckTimestamp = block.timestamp

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (tokenIn,tokenOut,amount,bestDex,None) = abi.decode(performData,(address,address,uint256,address,uint256))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: key = keccak256(bytes)(abi.encodePacked(tokenIn,tokenOut,amount,bestDex))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp >= lastExecution[key] + timelock,Timelock active)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: lastExecution[key] = block.timestamp

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: (None,gasPrice,None,None,None) = fastGasFeed.latestRoundData()

  ID: 13
  Type: NodeType.VARIABLE
  Expression: totalFee = uint256(gasPrice) + (uint256(gasPrice) / 10)

  ID: 14
  Type: NodeType.IF
  Expression: totalFee > maxFeePerGas

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: totalFee = maxFeePerGas

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= gasLimitPerTx * totalFee,Insufficient ETH for gas)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: gasBefore = gasleft()()

  ID: 19
  Type: NodeType.TRY
  Expression: this.startFlashLoan{gas: gasLimitPerTx}(tokenIn,amount,bestDex)

  ID: 20
  Type: NodeType.CATCH
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: UpkeepPerformed(tokenIn,amount,gasBefore - gasleft()())

  ID: 22
  Type: NodeType.CATCH
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: _pause()

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: emergencyMode = true

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: emergencyLogs.push(EmergencyLog(string(reason),block.timestamp))

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: EmergencyPause(string(reason))

  ID: 27
  Type: NodeType.IF
  Expression: alertReceiver != address(0)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: AlertSent(alertReceiver,string(abi.encodePacked(Emergency: ,reason)))

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 30
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 22
  20 -> 21
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  27 -> 29
  28 -> 29
  30 -> 31
  31 -> 1

Function: startFlashLoan
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == address(this) || msg.sender == owner,Only contract or owner)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: pool = IAavePool(poolAddressesProvider.getPool())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: params = abi.encode(token,dex)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: pool.flashLoanSimple(address(this),token,amount,params,0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: executeOperation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == poolAddressesProvider.getPool(),Caller must be Aave Pool)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(initiator == address(this),Initiator must be this contract)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (tokenIn,dex) = abi.decode(params,(address,address))

  ID: 6
  Type: NodeType.VARIABLE
  Expression: amountOwing = amount + premium

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).balanceOf(address(this)) >= amount,Insufficient token balance)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (profit,tokenOut) = executeArbitrage(tokenIn,amount,amountOwing,dex)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).approve(address(poolAddressesProvider.getPool()),amountOwing),Approval failed)

  ID: 12
  Type: NodeType.IF
  Expression: profit > 0

  ID: 13
  Type: NodeType.IF
  Expression: tokenOut == address(0)

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = owner.call{value: profit}()

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,ETH profit transfer failed)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenOut).transfer(owner,profit),Token profit transfer failed)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ArbitrageExecuted(tokenIn,tokenOut,amount,profit,dex)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: true

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 22
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 20
  13 -> 14
  13 -> 17
  14 -> 15
  15 -> 16
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  22 -> 1

Function: executeArbitrage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).balanceOf(address(this)) >= amount,Insufficient token balance)

  ID: 2
  Type: NodeType.IF
  Expression: dex == UNISWAP_V3_ROUTER

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (profit,tokenOut) = tryExecuteDirectUni(tokenIn,amount,amountOwing)

  ID: 4
  Type: NodeType.IF
  Expression: dex == SUSHISWAP_ROUTER

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (profit,tokenOut) = tryExecuteDirectSushi(tokenIn,amount,amountOwing)

  ID: 6
  Type: NodeType.IF
  Expression: dex == CURVE_3POOL

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (profit,tokenOut) = tryExecuteCurve(tokenIn,amount,amountOwing)

  ID: 8
  Type: NodeType.IF
  Expression: dex == BALANCER_VAULT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (profit,tokenOut) = tryExecuteBalancer(tokenIn,amount,amountOwing)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Unsupported DEX)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: (profit,tokenOut)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 14
  4 -> 5
  4 -> 6
  5 -> 13
  6 -> 7
  6 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15

Function: tryExecuteDirectUni
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenLength = supportedTokens.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: uniRouter = IUniswapV3SwapRouter(UNISWAP_V3_ROUTER)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).approve(UNISWAP_V3_ROUTER,amount),Uniswap approval failed)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < tokenLength

  ID: 8
  Type: NodeType.IF
  Expression: supportedTokens[i] != tokenIn

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenOut = supportedTokens[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.TRY
  Expression: out = uniRouter.quoteExactInputSingle(tokenIn,tokenOut,3000,amount,0)

  ID: 12
  Type: NodeType.CATCH
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: expectedOut = out

  ID: 14
  Type: NodeType.CATCH
  Expression: 

  ID: 15
  Type: NodeType.CONTINUE
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: minAmountOut = expectedOut * (10000 - maxSlippage) / 10000

  ID: 18
  Type: NodeType.CATCH
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: amountOut > amountOwing

  ID: 20
  Type: NodeType.RETURN
  Expression: (amountOut - amountOwing,tokenOut)

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.CATCH
  Expression: 

  ID: 23
  Type: NodeType.CONTINUE
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 26
  Type: NodeType.RETURN
  Expression: (0,address(0))

  ID: 27
  Type: NodeType.IF
  Expression: minAmountOut > amountOwing

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: amountOut = uniRouter.exactInputSingle(IUniswapV3SwapRouter.ExactInputSingleParams({tokenIn:tokenIn,tokenOut:tokenOut,fee:3000,recipient:address(this),deadline:block.timestamp + 300,amountIn:amount,amountOutMinimum:minAmountOut,sqrtPriceLimitX96:0}))

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: amountOut = uniRouter.exactInputSingle(IUniswapV3SwapRouter.ExactInputSingleParams({tokenIn:tokenIn,tokenOut:tokenOut,fee:3000,recipient:address(this),deadline:block.timestamp + 300,amountIn:amount,amountOutMinimum:amountOwing,sqrtPriceLimitX96:0}))

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 26
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 24
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 14
  11 -> 16
  12 -> 13
  13 -> 16
  14 -> 15
  15 -> 25
  16 -> 27
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 24
  22 -> 23
  23 -> 25
  24 -> 25
  25 -> 7
  27 -> 28
  27 -> 29
  28 -> 30
  29 -> 30
  30 -> 18
  30 -> 22
  30 -> 24

Function: tryExecuteDirectSushi
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenLength = supportedTokens.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sushiRouter = ISushiV2Router(SUSHISWAP_ROUTER)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).approve(SUSHISWAP_ROUTER,amount),Sushi approval failed)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < tokenLength

  ID: 8
  Type: NodeType.IF
  Expression: supportedTokens[i] != tokenIn

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenOut = supportedTokens[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: path[0] = tokenIn

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: path[1] = tokenOut

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.TRY
  Expression: out = sushiRouter.getAmountsOut(amount,path)

  ID: 15
  Type: NodeType.CATCH
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: amounts = out

  ID: 17
  Type: NodeType.CATCH
  Expression: 

  ID: 18
  Type: NodeType.CONTINUE
  Expression: 

  ID: 19
  Type: NodeType.VARIABLE
  Expression: minAmountOut = amounts[1] * (10000 - maxSlippage) / 10000

  ID: 21
  Type: NodeType.CATCH
  Expression: 

  ID: 22
  Type: NodeType.IF
  Expression: swapAmounts[1] > amountOwing

  ID: 23
  Type: NodeType.RETURN
  Expression: (swapAmounts[1] - amountOwing,tokenOut)

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.CATCH
  Expression: 

  ID: 26
  Type: NodeType.CONTINUE
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 29
  Type: NodeType.RETURN
  Expression: (0,address(0))

  ID: 30
  Type: NodeType.IF
  Expression: minAmountOut > amountOwing

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: swapAmounts = sushiRouter.swapExactTokensForTokens(amount,minAmountOut,path,address(this),block.timestamp + 300)

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: swapAmounts = sushiRouter.swapExactTokensForTokens(amount,amountOwing,path,address(this),block.timestamp + 300)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 29
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 27
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  14 -> 19
  15 -> 16
  16 -> 19
  17 -> 18
  18 -> 28
  19 -> 30
  21 -> 22
  22 -> 23
  22 -> 24
  24 -> 27
  25 -> 26
  26 -> 28
  27 -> 28
  28 -> 7
  30 -> 31
  30 -> 32
  31 -> 33
  32 -> 33
  33 -> 21
  33 -> 25
  33 -> 27

Function: tryExecuteCurve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenLength = supportedTokens.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: curvePool = ICurvePool(CURVE_3POOL)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).approve(CURVE_3POOL,amount),Curve approval failed)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < tokenLength

  ID: 8
  Type: NodeType.IF
  Expression: supportedTokens[i] != tokenIn

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenOut = supportedTokens[i]

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.TRY
  Expression: dy = curvePool.get_dy(inIndex,outIndex,amount)

  ID: 14
  Type: NodeType.CATCH
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: expectedOut = dy

  ID: 16
  Type: NodeType.CATCH
  Expression: 

  ID: 17
  Type: NodeType.CONTINUE
  Expression: 

  ID: 18
  Type: NodeType.VARIABLE
  Expression: minAmountOut = expectedOut * (10000 - maxSlippage) / 10000

  ID: 20
  Type: NodeType.CATCH
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: amountOut > amountOwing

  ID: 22
  Type: NodeType.RETURN
  Expression: (amountOut - amountOwing,tokenOut)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.CATCH
  Expression: 

  ID: 25
  Type: NodeType.CONTINUE
  Expression: 

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 28
  Type: NodeType.RETURN
  Expression: (0,address(0))

  ID: 29
  Type: NodeType.IF
  Expression: tokenIn == DAI

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: inIndex = int128(0)

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.IF
  Expression: tokenOut == DAI

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: outIndex = int128(0)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: minAmountOut > amountOwing

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: amountOut = curvePool.exchange(inIndex,outIndex,amount,minAmountOut)

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: amountOut = curvePool.exchange(inIndex,outIndex,amount,amountOwing)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.IF
  Expression: tokenIn == USDC

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: inIndex = int128(1)

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: inIndex = int128(2)

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.IF
  Expression: tokenOut == USDC

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: outIndex = int128(1)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: outIndex = int128(2)

  ID: 48
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 28
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 26
  9 -> 29
  12 -> 13
  13 -> 14
  13 -> 16
  13 -> 18
  14 -> 15
  15 -> 18
  16 -> 17
  17 -> 27
  18 -> 37
  20 -> 21
  21 -> 22
  21 -> 23
  23 -> 26
  24 -> 25
  25 -> 27
  26 -> 27
  27 -> 7
  29 -> 30
  29 -> 41
  30 -> 32
  32 -> 33
  33 -> 34
  33 -> 45
  34 -> 36
  36 -> 12
  37 -> 38
  37 -> 39
  38 -> 40
  39 -> 40
  40 -> 20
  40 -> 24
  40 -> 26
  41 -> 42
  41 -> 43
  42 -> 44
  43 -> 44
  44 -> 32
  45 -> 46
  45 -> 47
  46 -> 48
  47 -> 48
  48 -> 36

Function: tryExecuteBalancer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenLength = supportedTokens.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: balancerVault = IBalancerVault(BALANCER_VAULT)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(tokenIn).approve(BALANCER_VAULT,amount),Balancer approval failed)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < tokenLength

  ID: 8
  Type: NodeType.IF
  Expression: supportedTokens[i] != tokenIn

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenOut = supportedTokens[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: singleSwap = IBalancerVault.SingleSwap({poolId:BALANCER_POOL_ID,kind:0,assetIn:tokenIn,assetOut:tokenOut,amount:amount,userData:0x})

  ID: 11
  Type: NodeType.VARIABLE
  Expression: funds = IBalancerVault.FundManagement({sender:address(this),fromInternalBalance:false,recipient:address(address(this)),toInternalBalance:false})

  ID: 12
  Type: NodeType.VARIABLE
  Expression: expectedOut = getBalancerQuote(tokenIn,tokenOut,amount)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: minAmountOut = expectedOut * (10000 - maxSlippage) / 10000

  ID: 15
  Type: NodeType.CATCH
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: amountOut > amountOwing

  ID: 17
  Type: NodeType.RETURN
  Expression: (amountOut - amountOwing,tokenOut)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.CATCH
  Expression: 

  ID: 20
  Type: NodeType.CONTINUE
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.RETURN
  Expression: (0,address(0))

  ID: 24
  Type: NodeType.IF
  Expression: minAmountOut > amountOwing

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: amountOut = balancerVault.swap(singleSwap,funds,minAmountOut,block.timestamp + 300)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: amountOut = balancerVault.swap(singleSwap,funds,amountOwing,block.timestamp + 300)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 23
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 21
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 24
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 21
  19 -> 20
  20 -> 22
  21 -> 22
  22 -> 7
  24 -> 25
  24 -> 26
  25 -> 27
  26 -> 27
  27 -> 15
  27 -> 19
  27 -> 21

Function: checkArbitrageProfit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: amountOwing = amount + (amount * 9 / 10000)

  ID: 2
  Type: NodeType.IF
  Expression: address(profitOracle) != address(0)

  ID: 3
  Type: NodeType.TRY
  Expression: oracleProfit = profitOracle.getExpectedProfit(tokenIn,tokenOut,amount)

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: oracleProfit > minProfitThreshold

  ID: 6
  Type: NodeType.RETURN
  Expression: (true,oracleProfit,UNISWAP_V3_ROUTER)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.CATCH
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: (None,gasPrice,None,None,None) = fastGasFeed.latestRoundData()

  ID: 12
  Type: NodeType.VARIABLE
  Expression: totalFee = uint256(gasPrice) + (uint256(gasPrice) / 10)

  ID: 13
  Type: NodeType.IF
  Expression: totalFee > maxFeePerGas

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: totalFee = maxFeePerGas

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: gasCost = gasLimitPerTx * totalFee

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: bestProfit = 0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: bestDex = address(0)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: dexLength = dexRouters.length

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < dexLength

  ID: 24
  Type: NodeType.VARIABLE
  Expression: amountOut = getAmountOut(dexRouters[i],tokenIn,tokenOut,amount)

  ID: 25
  Type: NodeType.IF
  Expression: amountOut > amountOwing + gasCost

  ID: 26
  Type: NodeType.VARIABLE
  Expression: profit = amountOut - amountOwing - gasCost

  ID: 27
  Type: NodeType.IF
  Expression: profit > bestProfit

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: bestProfit = profit

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: bestDex = dexRouters[i]

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: profitable = bestProfit > minProfitThreshold

  ID: 34
  Type: NodeType.RETURN
  Expression: (profitable,bestProfit,bestDex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 9
  3 -> 4
  3 -> 8
  3 -> 9
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 22
  20 -> 23
  21 -> 33
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 26
  25 -> 31
  26 -> 27
  27 -> 28
  27 -> 30
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 23
  33 -> 34

Function: getAmountOut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: dex == UNISWAP_V3_ROUTER

  ID: 2
  Type: NodeType.TRY
  Expression: out = IUniswapV3SwapRouter(UNISWAP_V3_ROUTER).quoteExactInputSingle(tokenIn,tokenOut,3000,amount,0)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: out

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: 0

  ID: 7
  Type: NodeType.IF
  Expression: dex == SUSHISWAP_ROUTER

  ID: 8
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: path[0] = tokenIn

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: path[1] = tokenOut

  ID: 11
  Type: NodeType.TRY
  Expression: amounts = ISushiV2Router(SUSHISWAP_ROUTER).getAmountsOut(amount,path)

  ID: 12
  Type: NodeType.CATCH
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: amounts[1]

  ID: 14
  Type: NodeType.CATCH
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: 0

  ID: 16
  Type: NodeType.IF
  Expression: dex == CURVE_3POOL && (tokenIn == DAI || tokenOut == DAI || tokenIn == USDC || tokenOut == USDC)

  ID: 19
  Type: NodeType.TRY
  Expression: dy = ICurvePool(CURVE_3POOL).get_dy(tokenInIndex,tokenOutIndex,amount)

  ID: 20
  Type: NodeType.CATCH
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: dy

  ID: 22
  Type: NodeType.CATCH
  Expression: 

  ID: 23
  Type: NodeType.RETURN
  Expression: 0

  ID: 24
  Type: NodeType.IF
  Expression: dex == BALANCER_VAULT

  ID: 25
  Type: NodeType.RETURN
  Expression: getBalancerQuote(tokenIn,tokenOut,amount)

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.RETURN
  Expression: 0

  ID: 31
  Type: NodeType.IF
  Expression: tokenIn == DAI

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: tokenInIndex = int128(0)

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: tokenOut == DAI

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: tokenOutIndex = int128(0)

  ID: 38
  Type: NodeType.ENDIF
  Expression: 

  ID: 39
  Type: NodeType.IF
  Expression: tokenIn == USDC

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: tokenInIndex = int128(1)

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: tokenInIndex = int128(2)

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.IF
  Expression: tokenOut == USDC

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: tokenOutIndex = int128(1)

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: tokenOutIndex = int128(2)

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  2 -> 5
  2 -> 29
  3 -> 4
  5 -> 6
  7 -> 8
  7 -> 16
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 14
  11 -> 28
  12 -> 13
  14 -> 15
  16 -> 31
  16 -> 24
  19 -> 20
  19 -> 22
  19 -> 27
  20 -> 21
  22 -> 23
  24 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  31 -> 32
  31 -> 39
  32 -> 34
  34 -> 35
  35 -> 36
  35 -> 43
  36 -> 38
  38 -> 19
  39 -> 40
  39 -> 41
  40 -> 42
  41 -> 42
  42 -> 34
  43 -> 44
  43 -> 45
  44 -> 46
  45 -> 46
  46 -> 38

Function: calculateOptimalLoanAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balance = IERC20(token).balanceOf(poolAddressesProvider.getPool())

  ID: 2
  Type: NodeType.VARIABLE
  Expression: optimalAmount = balance / 10

  ID: 4
  Type: NodeType.IF
  Expression: optimalAmount > maxLoanAmount

  ID: 5
  Type: NodeType.RETURN
  Expression: maxLoanAmount

  ID: 6
  Type: NodeType.RETURN
  Expression: optimalAmount

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  4 -> 5
  4 -> 6

Function: getBalancerQuote
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: singleSwap = IBalancerVault.SingleSwap({poolId:BALANCER_POOL_ID,kind:0,assetIn:tokenIn,assetOut:tokenOut,amount:amount,userData:0x})

  ID: 2
  Type: NodeType.VARIABLE
  Expression: funds = IBalancerVault.FundManagement({sender:address(this),fromInternalBalance:false,recipient:address(address(this)),toInternalBalance:false})

  ID: 3
  Type: NodeType.TRY
  Expression: amountOut = this.simulateBalancerSwap(singleSwap,funds)

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: amountOut

  ID: 6
  Type: NodeType.CATCH
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  6 -> 7

Function: simulateBalancerSwap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = address(BALANCER_VAULT).staticcall(abi.encodeWithSelector(IBalancerVault.swap.selector,singleSwap,funds,0,block.timestamp + 300))

  ID: 5
  Type: NodeType.IF
  Expression: success

  ID: 6
  Type: NodeType.RETURN
  Expression: abi.decode(data,(uint256))

  ID: 7
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  5 -> 6
  5 -> 7

Function: requestLink
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: LinkRequested(amount)

  ID: 2
  Type: NodeType.TRY
  Expression: success = ILinkToken(LINK).transferFrom(owner,address(this),amount)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _pause()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: emergencyMode = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: emergencyLogs.push(EmergencyLog(LINK request failed,block.timestamp))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: EmergencyPause(LINK request failed)

  ID: 9
  Type: NodeType.IF
  Expression: alertReceiver != address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: AlertSent(alertReceiver,Emergency: LINK request failed)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.CATCH
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _pause()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: emergencyMode = true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: emergencyLogs.push(EmergencyLog(LINK request reverted,block.timestamp))

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: EmergencyPause(LINK request reverted)

  ID: 18
  Type: NodeType.IF
  Expression: alertReceiver != address(0)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: AlertSent(alertReceiver,Emergency: LINK request reverted)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  4 -> 5
  4 -> 12
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 20

Function: adjustGasLimitDynamically
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (None,gasPrice,None,updatedAt,None) = fastGasFeed.latestRoundData()

  ID: 4
  Type: NodeType.IF
  Expression: updatedAt < block.timestamp - 3600

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: gasLimitPerTx = 300_000

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: GasLimitAdjusted(gasLimitPerTx)

  ID: 7
  Type: NodeType.RETURN
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: estimatedGasPrice = uint256(gasPrice) / 1000000000

  ID: 11
  Type: NodeType.IF
  Expression: newGasLimit != gasLimitPerTx

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: gasLimitPerTx = newGasLimit

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: GasLimitAdjusted(newGasLimit)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: (estimatedGasPrice < 50)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: newGasLimit = 400_000

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: (estimatedGasPrice < 100)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: newGasLimit = 300_000

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: newGasLimit = 200_000

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 15
  11 -> 12
  11 -> 14
  12 -> 13
  13 -> 14
  15 -> 16
  15 -> 19
  16 -> 18
  18 -> 11
  19 -> 20
  19 -> 21
  20 -> 22
  21 -> 22
  22 -> 18

Function: checkEmergencyStatus
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: isEmergency = emergencyMode || isPaused()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EmergencyStatusChecked(isEmergency,emergencyLogs.length)

  ID: 3
  Type: NodeType.IF
  Expression: isEmergency && alertReceiver != address(0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: AlertSent(alertReceiver,Contract in emergency or paused state)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: isEmergency

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: setAlertReceiver
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_receiver != address(0),Invalid receiver address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: alertReceiver = _receiver

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: getEmergencyLogs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(index < emergencyLogs.length,Invalid index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: log = emergencyLogs[index]

  ID: 3
  Type: NodeType.RETURN
  Expression: (log.reason,log.timestamp)

  ID: 4
  Type: NodeType.RETURN
  Expression: (reason,timestamp)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: emergencyWithdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(emergencyMode,Emergency mode not active)

  ID: 2
  Type: NodeType.IF
  Expression: token == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Insufficient ETH)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = owner.call{value: amount}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,ETH withdrawal failed)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(token).balanceOf(address(this)) >= amount,Insufficient token balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(token).transfer(owner,amount),Token withdrawal failed)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: emergencyLogs.push(EmergencyLog(Funds withdrawn in emergency,block.timestamp))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: EmergencyWithdraw(token,amount)

  ID: 12
  Type: NodeType.IF
  Expression: alertReceiver != address(0)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: AlertSent(alertReceiver,Emergency withdrawal executed)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  15 -> 1

Function: withdrawETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),Invalid recipient address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Insufficient ETH balance)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = to.call{value: amount}()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,ETH withdrawal failed)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ETHWithdrawn(to,amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 1

Function: addToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token != address(0),Invalid token address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: supportedTokens.push(token)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TokenAdded(token)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: addDex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(dex != address(0),Invalid DEX address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dexRouters.push(dex)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: isDexSupported[dex] = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: DexAdded(dex)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateParameters
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: minProfitThreshold = _minProfitThreshold

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: checkInterval = _checkInterval

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: gasLimitPerTx = _gasLimit

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: minLinkBalance = _minLinkBalance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: maxLoanAmount = _maxLoanAmount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: maxSlippage = _maxSlippage

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: timelock = _timelock

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: GasLimitAdjusted(_gasLimit)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: setProfitOracle
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_profitOracle != address(0),Invalid oracle address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: profitOracle = IProfitOracle(_profitOracle)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: AAVE_POOL_ADDRESSES_PROVIDER = 0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SUSHISWAP_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: fastGasFeed = AggregatorV3Interface(FAST_GAS_FEED_ADDRESS)

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minProfitThreshold = 10000000000000000

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: checkInterval = 60

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: gasLimitPerTx = 300_000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minLinkBalance = 1000000000000000000

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxLoanAmount = 10000000000000000000000

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxSlippage = 50

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxFeePerGas = 100000000000

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: timelock = 60

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FAST_GAS_FEED_ADDRESS = 0x169e633A2d1E6c10dd912952d37268d6368d37F8

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BALANCER_POOL_ID = 0x0b09dea16768f0799065c475be02919403cb2a3500020000000000000000001a

Edges:
  0 -> 1


