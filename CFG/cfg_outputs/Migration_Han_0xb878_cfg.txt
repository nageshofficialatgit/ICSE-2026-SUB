Contract: Owned
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_owner != address(0),Owner address cannot be 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(address(0),_owner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1


Contract: BaseMigration
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

Edges:
  0 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: returnOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: payload = abi.encodeWithSignature(nominateNewOwner(address),owner)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = forContract.call(payload)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.VARIABLE
  Expression: legacyPayload = abi.encodeWithSignature(nominateOwner(address),owner)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (legacySuccess,None) = forContract.call(legacyPayload)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(legacySuccess,Legacy nomination failed)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9


Contract: IAddressResolver
==================================================


Contract: ISynth
==================================================


Contract: IIssuer
==================================================


Contract: MixinResolver
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: resolver = AddressResolver(_resolver)

Edges:
  0 -> 1

Function: combineArrays
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: combination = new bytes32[](first.length + second.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < first.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: combination[i] = first[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: j < second.length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: combination[first.length + j] = second[j]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 14
  Type: NodeType.RETURN
  Expression: combination

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11

Function: resolverAddressesRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1

Function: rebuildCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = resolver.requireAndGetAddress(name,string(abi.encodePacked(Resolver missing target: ,name)))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressCache[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: CacheUpdated(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: isResolverCached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.IF
  Expression: resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = addressCache[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),string(abi.encodePacked(Missing address: ,name)))

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: AddressResolver
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

Edges:
  0 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: importAddresses
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(names.length == destinations.length,Input lengths must match)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < names.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = names[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = destinations[i]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: repository[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: AddressImported(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5
  11 -> 1

Function: rebuildCaches
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < destinations.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: destinations[i].rebuildCache()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 3
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4

Function: areAddressesImported
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < names.length

  ID: 5
  Type: NodeType.IF
  Expression: repository[names[i]] != destinations[i]

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: getAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: repository[name]

Edges:
  0 -> 1

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = repository[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),reason)

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: issuer = IIssuer(repository[Issuer])

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(issuer) != address(0),Cannot find Issuer address)

  ID: 3
  Type: NodeType.RETURN
  Expression: address(issuer.synths(key))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: ISystemStatus
==================================================


Contract: SystemStatus
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

Edges:
  0 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: requireSystemActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

Edges:
  0 -> 1

Function: systemSuspended
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: systemSuspension.suspended

Edges:
  0 -> 1

Function: requireIssuanceActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireIssuanceActive()

Edges:
  0 -> 1
  1 -> 2

Function: requireExchangeActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireExchangeActive()

Edges:
  0 -> 1
  1 -> 2

Function: requireSynthExchangeActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthExchangeActive(currencyKey)

Edges:
  0 -> 1
  1 -> 2

Function: requireFuturesActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireExchangeActive()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalRequireFuturesActive()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: requireFuturesMarketActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireExchangeActive()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalRequireFuturesActive()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _internalRequireFuturesMarketActive(marketKey)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: synthSuspended
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: systemSuspension.suspended || synthSuspension[currencyKey].suspended

Edges:
  0 -> 1

Function: requireSynthActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthActive(currencyKey)

Edges:
  0 -> 1
  1 -> 2

Function: requireSynthsActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthActive(sourceCurrencyKey)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthActive(destinationCurrencyKey)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: requireExchangeBetweenSynthsAllowed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSystemActive()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _internalRequireExchangeActive()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthExchangeActive(sourceCurrencyKey)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthExchangeActive(destinationCurrencyKey)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthActive(sourceCurrencyKey)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _internalRequireSynthActive(destinationCurrencyKey)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: isSystemUpgrading
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE

Edges:
  0 -> 1

Function: getSynthExchangeSuspensions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspensions = new bool[](synths.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: reasons = new uint256[](synths.length)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < synths.length

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: reasons[i] = synthExchangeSuspension[synths[i]].reason

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: (exchangeSuspensions,reasons)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 10
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 6

Function: getSynthSuspensions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: suspensions = new bool[](synths.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: reasons = new uint256[](synths.length)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < synths.length

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: suspensions[i] = synthSuspension[synths[i]].suspended

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: reasons[i] = synthSuspension[synths[i]].reason

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: (suspensions,reasons)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 10
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 6

Function: getFuturesMarketSuspensions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: suspensions = new bool[](marketKeys.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: reasons = new uint256[](marketKeys.length)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < marketKeys.length

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: reasons[i] = futuresMarketSuspension[marketKeys[i]].reason

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: (suspensions,reasons)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 10
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 6

Function: updateAccessControl
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalUpdateAccessControl(section,account,canSuspend,canResume)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: updateAccessControls
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sections.length == accounts.length && accounts.length == canSuspends.length && canSuspends.length == canResumes.length,Input array lengths must match)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < sections.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _internalUpdateAccessControl(sections[i],accounts[i],canSuspends[i],canResumes[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 1

Function: suspendSystem
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_SYSTEM)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: systemSuspension.suspended = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: systemSuspension.reason = uint248(reason)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: SystemSuspended(systemSuspension.reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: resumeSystem
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_SYSTEM)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: systemSuspension.suspended = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: SystemResumed(uint256(systemSuspension.reason))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: systemSuspension.reason = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: suspendIssuance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_ISSUANCE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: issuanceSuspension.suspended = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: issuanceSuspension.reason = uint248(reason)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: IssuanceSuspended(reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: resumeIssuance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_ISSUANCE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: issuanceSuspension.suspended = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IssuanceResumed(uint256(issuanceSuspension.reason))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: issuanceSuspension.reason = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: suspendExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_EXCHANGE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspension.suspended = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspension.reason = uint248(reason)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ExchangeSuspended(reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: resumeExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_EXCHANGE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspension.suspended = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ExchangeResumed(uint256(exchangeSuspension.reason))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: exchangeSuspension.reason = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: suspendFutures
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_FUTURES)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: futuresSuspension.suspended = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: futuresSuspension.reason = uint248(reason)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: FuturesSuspended(reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: resumeFutures
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_FUTURES)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: futuresSuspension.suspended = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: FuturesResumed(uint256(futuresSuspension.reason))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: futuresSuspension.reason = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: suspendFuturesMarket
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: marketKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: marketKeys[0] = marketKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendFuturesMarkets(marketKeys,reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: suspendFuturesMarkets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendFuturesMarkets(marketKeys,reason)

Edges:
  0 -> 1

Function: resumeFuturesMarket
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: marketKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: marketKeys[0] = marketKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalResumeFuturesMarkets(marketKeys)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: resumeFuturesMarkets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalResumeFuturesMarkets(marketKeys)

Edges:
  0 -> 1

Function: suspendSynthExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[0] = currencyKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendSynthExchange(currencyKeys,reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: suspendSynthsExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendSynthExchange(currencyKeys,reason)

Edges:
  0 -> 1

Function: resumeSynthExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[0] = currencyKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalResumeSynthsExchange(currencyKeys)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: resumeSynthsExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalResumeSynthsExchange(currencyKeys)

Edges:
  0 -> 1

Function: suspendSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[0] = currencyKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendSynths(currencyKeys,reason)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: suspendSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalSuspendSynths(currencyKeys,reason)

Edges:
  0 -> 1

Function: resumeSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKeys = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[0] = currencyKey

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _internalResumeSynths(currencyKeys)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: resumeSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _internalResumeSynths(currencyKeys)

Edges:
  0 -> 1

Function: _requireAccessToSuspend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(accessControl[section][msg.sender].canSuspend,Restricted to access control list)

Edges:
  0 -> 1

Function: _requireAccessToResume
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(accessControl[section][msg.sender].canResume,Restricted to access control list)

Edges:
  0 -> 1

Function: _internalRequireSystemActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: systemSuspension.reason == SUSPENSION_REASON_UPGRADE

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! systemSuspension.suspended,Synthetix is suspended, upgrade in progress... please stand by)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! systemSuspension.suspended,Synthetix is suspended. Operation prohibited)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5

Function: _internalRequireIssuanceActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! issuanceSuspension.suspended,Issuance is suspended. Operation prohibited)

Edges:
  0 -> 1

Function: _internalRequireExchangeActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! exchangeSuspension.suspended,Exchange is suspended. Operation prohibited)

Edges:
  0 -> 1

Function: _internalRequireFuturesActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! futuresSuspension.suspended,Futures markets are suspended. Operation prohibited)

Edges:
  0 -> 1

Function: _internalRequireSynthExchangeActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! synthExchangeSuspension[currencyKey].suspended,Synth exchange suspended. Operation prohibited)

Edges:
  0 -> 1

Function: _internalRequireSynthActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! synthSuspension[currencyKey].suspended,Synth is suspended. Operation prohibited)

Edges:
  0 -> 1

Function: _internalRequireFuturesMarketActive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! futuresMarketSuspension[marketKey].suspended,Market suspended)

Edges:
  0 -> 1

Function: _internalSuspendSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_SYNTH)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < currencyKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: currencyKey = currencyKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: synthSuspension[currencyKey].suspended = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: synthSuspension[currencyKey].reason = uint248(reason)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: SynthSuspended(currencyKey,reason)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: _internalResumeSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_SYNTH)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < currencyKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: currencyKey = currencyKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: SynthResumed(currencyKey,uint256(synthSuspension[currencyKey].reason))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: delete synthSuspension[currencyKey]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 5

Function: _internalSuspendSynthExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < currencyKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: currencyKey = currencyKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: synthExchangeSuspension[currencyKey].suspended = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: synthExchangeSuspension[currencyKey].reason = uint248(reason)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: SynthExchangeSuspended(currencyKey,reason)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: _internalResumeSynthsExchange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_SYNTH_EXCHANGE)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < currencyKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: currencyKey = currencyKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: SynthExchangeResumed(currencyKey,uint256(synthExchangeSuspension[currencyKey].reason))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: delete synthExchangeSuspension[currencyKey]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 5

Function: _internalSuspendFuturesMarkets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToSuspend(SECTION_FUTURES)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < marketKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: marketKey = marketKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: futuresMarketSuspension[marketKey].suspended = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: futuresMarketSuspension[marketKey].reason = uint248(reason)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: FuturesMarketSuspended(marketKey,reason)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: _internalResumeFuturesMarkets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireAccessToResume(SECTION_FUTURES)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < marketKeys.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: marketKey = marketKeys[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: FuturesMarketResumed(marketKey,uint256(futuresMarketSuspension[marketKey].reason))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: delete futuresMarketSuspension[marketKey]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 5

Function: _internalUpdateAccessControl
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(section == SECTION_SYSTEM || section == SECTION_ISSUANCE || section == SECTION_EXCHANGE || section == SECTION_FUTURES || section == SECTION_SYNTH_EXCHANGE || section == SECTION_SYNTH,Invalid section supplied)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: accessControl[section][account].canSuspend = canSuspend

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: accessControl[section][account].canResume = canResume

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: AccessControlUpdated(section,account,canSuspend,canResume)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SUSPENSION_REASON_UPGRADE = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_SYSTEM = System

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_ISSUANCE = Issuance

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_EXCHANGE = Exchange

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_FUTURES = Futures

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_SYNTH_EXCHANGE = SynthExchange

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECTION_SYNTH = Synth

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_NAME = SystemStatus

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7


Contract: IFlexibleStorage
==================================================


Contract: MixinSystemSettings
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: MixinResolver(_resolver)

Edges:
  0 -> 1

Function: combineArrays
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: combination = new bytes32[](first.length + second.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < first.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: combination[i] = first[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: j < second.length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: combination[first.length + j] = second[j]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 14
  Type: NodeType.RETURN
  Expression: combination

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11

Function: resolverAddressesRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: addresses = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: addresses[0] = CONTRACT_FLEXIBLESTORAGE

  ID: 3
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: rebuildCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = resolver.requireAndGetAddress(name,string(abi.encodePacked(Resolver missing target: ,name)))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressCache[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: CacheUpdated(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: isResolverCached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.IF
  Expression: resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = addressCache[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),string(abi.encodePacked(Missing address: ,name)))

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: flexibleStorage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE))

Edges:
  0 -> 1

Function: _getGasLimitSetting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Deposit

  ID: 2
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT

  ID: 3
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Escrow

  ID: 4
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT

  ID: 5
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Reward

  ID: 6
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT

  ID: 7
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Withdrawal

  ID: 8
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT

  ID: 9
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Relay

  ID: 10
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT

  ID: 11
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod

  ID: 12
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Unknown gas limit type)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: getCrossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,_getGasLimitSetting(gasLimitType))

Edges:
  0 -> 1

Function: getTradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,SETTING_TRADING_REWARDS_ENABLED)

Edges:
  0 -> 1

Function: getWaitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_WAITING_PERIOD_SECS)

Edges:
  0 -> 1

Function: getPriceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR)

Edges:
  0 -> 1

Function: getIssuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ISSUANCE_RATIO)

Edges:
  0 -> 1

Function: getFeePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FEE_PERIOD_DURATION)

Edges:
  0 -> 1

Function: getTargetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_TARGET_THRESHOLD)

Edges:
  0 -> 1

Function: getLiquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_DELAY)

Edges:
  0 -> 1

Function: getLiquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_RATIO)

Edges:
  0 -> 1

Function: getLiquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_ESCROW_DURATION)

Edges:
  0 -> 1

Function: getLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSnxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SNX_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSelfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SELF_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getFlagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FLAG_REWARD)

Edges:
  0 -> 1

Function: getLiquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATE_REWARD)

Edges:
  0 -> 1

Function: getRateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_RATE_STALE_PERIOD)

Edges:
  0 -> 1

Function: getExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeDynamicFeeConfig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: keys = new bytes32[](4)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE

  ID: 6
  Type: NodeType.VARIABLE
  Expression: values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME,keys)

  ID: 7
  Type: NodeType.RETURN
  Expression: DynamicFeeConfig({threshold:values[0],weightDecay:values[1],rounds:values[2],maxFee:values[3]})

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: getMinimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_MINIMUM_STAKE_TIME)

Edges:
  0 -> 1

Function: getAggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,SETTING_AGGREGATOR_WARNING_FLAGS)

Edges:
  0 -> 1

Function: getDebtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_DEBT_SNAPSHOT_STALE_TIME)

Edges:
  0 -> 1

Function: getEtherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MAX_ETH)

Edges:
  0 -> 1

Function: getEtherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MINT_FEE_RATE)

Edges:
  0 -> 1

Function: getEtherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_BURN_FEE_RATE)

Edges:
  0 -> 1

Function: getWrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT,wrapper)))

Edges:
  0 -> 1

Function: getWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getInteractionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_INTERACTION_DELAY,collateral)))

Edges:
  0 -> 1

Function: getCollapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE,collateral)))

Edges:
  0 -> 1

Function: getAtomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK)

Edges:
  0 -> 1

Function: getAtomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_TWAP_WINDOW)

Edges:
  0 -> 1

Function: getAtomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,currencyKey)))

Edges:
  0 -> 1

Function: getPureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getCrossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_MAX_DYNAMIC_FEE)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeRounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeWeightDecay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY)

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CONTRACT_NAME = SystemSettings

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WAITING_PERIOD_SECS = waitingPeriodSecs

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = priceDeviationThresholdFactor

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ISSUANCE_RATIO = issuanceRatio

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FEE_PERIOD_DURATION = feePeriodDuration

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TARGET_THRESHOLD = targetThreshold

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_DELAY = liquidationDelay

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_RATIO = liquidationRatio

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_ESCROW_DURATION = liquidationEscrowDuration

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_PENALTY = liquidationPenalty

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SNX_LIQUIDATION_PENALTY = snxLiquidationPenalty

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SELF_LIQUIDATION_PENALTY = selfLiquidationPenalty

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FLAG_REWARD = flagReward

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATE_REWARD = liquidateReward

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_RATE_STALE_PERIOD = rateStalePeriod

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_FEE_RATE = exchangeFeeRate

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = exchangeDynamicFeeThreshold

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = exchangeDynamicFeeWeightDecay

  ID: 18
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = exchangeDynamicFeeRounds

  ID: 19
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_MAX_DYNAMIC_FEE = exchangeMaxDynamicFee

  ID: 20
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_MINIMUM_STAKE_TIME = minimumStakeTime

  ID: 21
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_AGGREGATOR_WARNING_FLAGS = aggregatorWarningFlags

  ID: 22
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TRADING_REWARDS_ENABLED = tradingRewardsEnabled

  ID: 23
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_DEBT_SNAPSHOT_STALE_TIME = debtSnapshotStaleTime

  ID: 24
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = crossDomainDepositGasLimit

  ID: 25
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = crossDomainEscrowGasLimit

  ID: 26
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = crossDomainRewardGasLimit

  ID: 27
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = crossDomainWithdrawalGasLimit

  ID: 28
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = crossDomainCloseGasLimit

  ID: 29
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = crossDomainRelayGasLimit

  ID: 30
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MAX_ETH = etherWrapperMaxETH

  ID: 31
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MINT_FEE_RATE = etherWrapperMintFeeRate

  ID: 32
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_BURN_FEE_RATE = etherWrapperBurnFeeRate

  ID: 33
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MAX_TOKEN_AMOUNT = wrapperMaxTokens

  ID: 34
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MINT_FEE_RATE = wrapperMintFeeRate

  ID: 35
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_BURN_FEE_RATE = wrapperBurnFeeRate

  ID: 36
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_INTERACTION_DELAY = interactionDelay

  ID: 37
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_COLLAPSE_FEE_RATE = collapseFeeRate

  ID: 38
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = atomicMaxVolumePerBlock

  ID: 39
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_TWAP_WINDOW = atomicTwapWindow

  ID: 40
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = atomicEquivalentForDexPricing

  ID: 41
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EXCHANGE_FEE_RATE = atomicExchangeFeeRate

  ID: 42
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = atomicVolConsiderationWindow

  ID: 43
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = atomicVolUpdateThreshold

  ID: 44
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED = pureChainlinkForAtomicsEnabled

  ID: 45
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_SYNTH_TRANSFER_ENABLED = crossChainSynthTransferEnabled

  ID: 46
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_FLEXIBLESTORAGE = FlexibleStorage

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46


Contract: SafeCast
==================================================

Function: toUint128
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 128,SafeCast: value doesn't fit in 128 bits)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint128(value)

Edges:
  0 -> 1
  1 -> 2

Function: toUint64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 64,SafeCast: value doesn't fit in 64 bits)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint64(value)

Edges:
  0 -> 1
  1 -> 2

Function: toUint32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 32,SafeCast: value doesn't fit in 32 bits)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint32(value)

Edges:
  0 -> 1
  1 -> 2

Function: toUint16
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 16,SafeCast: value doesn't fit in 16 bits)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint16(value)

Edges:
  0 -> 1
  1 -> 2

Function: toUint8
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 8,SafeCast: value doesn't fit in 8 bits)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint8(value)

Edges:
  0 -> 1
  1 -> 2

Function: toUint256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value >= 0,SafeCast: value must be positive)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(value)

Edges:
  0 -> 1
  1 -> 2

Function: toInt256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(value < 2 ** 255,SafeCast: value doesn't fit in an int256)

  ID: 2
  Type: NodeType.RETURN
  Expression: int256(value)

Edges:
  0 -> 1
  1 -> 2


Contract: SafeMath
==================================================

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(c >= a,SafeMath: addition overflow)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b <= a,SafeMath: subtraction overflow)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: c = a - b

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(c / a == b,SafeMath: multiplication overflow)

  ID: 6
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b > 0,SafeMath: division by zero)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: mod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b != 0,SafeMath: modulo by zero)

  ID: 2
  Type: NodeType.RETURN
  Expression: a % b

Edges:
  0 -> 1
  1 -> 2


Contract: SafeDecimalMath
==================================================

Function: unit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: UNIT

Edges:
  0 -> 1

Function: preciseUnit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PRECISE_UNIT

Edges:
  0 -> 1

Function: multiplyDecimal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: x.mul(y) / UNIT

Edges:
  0 -> 1

Function: _multiplyDecimalRound
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: quotientTimesTen = x.mul(y) / (precisionUnit / 10)

  ID: 2
  Type: NodeType.IF
  Expression: quotientTimesTen % 10 >= 5

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: quotientTimesTen += 10

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: quotientTimesTen / 10

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: multiplyDecimalRoundPrecise
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _multiplyDecimalRound(x,y,PRECISE_UNIT)

Edges:
  0 -> 1

Function: multiplyDecimalRound
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _multiplyDecimalRound(x,y,UNIT)

Edges:
  0 -> 1

Function: divideDecimal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: x.mul(UNIT).div(y)

Edges:
  0 -> 1

Function: _divideDecimalRound
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: resultTimesTen = x.mul(precisionUnit * 10).div(y)

  ID: 2
  Type: NodeType.IF
  Expression: resultTimesTen % 10 >= 5

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: resultTimesTen += 10

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: resultTimesTen / 10

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: divideDecimalRound
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _divideDecimalRound(x,y,UNIT)

Edges:
  0 -> 1

Function: divideDecimalRoundPrecise
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _divideDecimalRound(x,y,PRECISE_UNIT)

Edges:
  0 -> 1

Function: decimalToPreciseDecimal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR)

Edges:
  0 -> 1

Function: preciseDecimalToDecimal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10)

  ID: 2
  Type: NodeType.IF
  Expression: quotientTimesTen % 10 >= 5

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: quotientTimesTen += 10

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: quotientTimesTen / 10

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: floorsub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: b >= a

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: signedAbs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: x < 0

  ID: 3
  Type: NodeType.RETURN
  Expression: - x

  ID: 4
  Type: NodeType.RETURN
  Expression: x

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: abs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(signedAbs(x))

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: highPrecisionDecimals = 27

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: UNIT = 10 ** uint256(decimals)

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PRECISE_UNIT = 10 ** uint256(highPrecisionDecimals)

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10 ** uint256(highPrecisionDecimals - decimals)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: ISynthetixDebtShare
==================================================


Contract: IVirtualSynth
==================================================


Contract: IExchanger
==================================================


Contract: ISynthetixInternal
==================================================


Contract: IExchangerInternalDebtCache
==================================================


Contract: IDelegateApprovals
==================================================


Contract: IDirectIntegrationManager
==================================================


Contract: IExchangeRates
==================================================


Contract: ICircuitBreaker
==================================================


Contract: IHasBalance
==================================================


Contract: IERC20
==================================================


Contract: ILiquidator
==================================================


Contract: ILiquidatorRewards
==================================================


Contract: ISynthRedeemer
==================================================


Contract: Proxy
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

Edges:
  0 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: setTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: target = _target

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TargetUpdated(_target)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _emit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: size = callData.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _callData = callData

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyTarget()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: target.setMessageSender(msg.sender)

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Proxyable
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),Owner must be set)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: proxy = Proxy(_proxy)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ProxyUpdated(_proxy)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: setProxy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: proxy = Proxy(_proxy)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ProxyUpdated(_proxy)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setMessageSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: messageSender = sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyProxy()

Edges:
  0 -> 2
  2 -> 1

Function: _onlyProxy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(Proxy(msg.sender) == proxy,Only the proxy can call)

Edges:
  0 -> 1

Function: _optionalProxy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: Proxy(msg.sender) != proxy && messageSender != msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: messageSender = msg.sender

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _optionalProxy_onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: Proxy(msg.sender) != proxy && messageSender != msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: messageSender = msg.sender

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(messageSender == owner,Owner only function)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4


Contract: AggregatorInterface
==================================================


Contract: AggregatorV3Interface
==================================================


Contract: AggregatorV2V3Interface
==================================================


Contract: IProxy
==================================================


Contract: IIssuerInternalDebtCache
==================================================


Contract: Issuer
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MixinSystemSettings(_resolver)

Edges:
  0 -> 1
  1 -> 2

Function: resolverAddressesRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: existingAddresses = MixinSystemSettings.resolverAddressesRequired()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: newAddresses = new bytes32[](15)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: newAddresses[0] = CONTRACT_SYNTHETIX

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: newAddresses[1] = CONTRACT_EXCHANGER

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: newAddresses[2] = CONTRACT_EXRATES

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: newAddresses[3] = CONTRACT_CIRCUIT_BREAKER

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: newAddresses[4] = CONTRACT_SYNTHETIXDEBTSHARE

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: newAddresses[5] = CONTRACT_FEEPOOL

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: newAddresses[6] = CONTRACT_DELEGATEAPPROVALS

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: newAddresses[7] = CONTRACT_REWARDESCROW_V2

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: newAddresses[8] = CONTRACT_LIQUIDATOR

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: newAddresses[9] = CONTRACT_LIQUIDATOR_REWARDS

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: newAddresses[10] = CONTRACT_DEBTCACHE

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: newAddresses[11] = CONTRACT_SYNTHREDEEMER

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: newAddresses[12] = CONTRACT_DYNAMICSYNTHREDEEMER

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: newAddresses[13] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: newAddresses[14] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO

  ID: 18
  Type: NodeType.RETURN
  Expression: combineArrays(existingAddresses,newAddresses)

  ID: 19
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18

Function: flexibleStorage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE))

Edges:
  0 -> 1

Function: _getGasLimitSetting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Deposit

  ID: 2
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT

  ID: 3
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Escrow

  ID: 4
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT

  ID: 5
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Reward

  ID: 6
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT

  ID: 7
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Withdrawal

  ID: 8
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT

  ID: 9
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Relay

  ID: 10
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT

  ID: 11
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod

  ID: 12
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Unknown gas limit type)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: getCrossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,_getGasLimitSetting(gasLimitType))

Edges:
  0 -> 1

Function: getTradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,SETTING_TRADING_REWARDS_ENABLED)

Edges:
  0 -> 1

Function: getWaitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_WAITING_PERIOD_SECS)

Edges:
  0 -> 1

Function: getPriceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR)

Edges:
  0 -> 1

Function: getIssuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ISSUANCE_RATIO)

Edges:
  0 -> 1

Function: getFeePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FEE_PERIOD_DURATION)

Edges:
  0 -> 1

Function: getTargetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_TARGET_THRESHOLD)

Edges:
  0 -> 1

Function: getLiquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_DELAY)

Edges:
  0 -> 1

Function: getLiquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_RATIO)

Edges:
  0 -> 1

Function: getLiquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_ESCROW_DURATION)

Edges:
  0 -> 1

Function: getLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSnxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SNX_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSelfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SELF_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getFlagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FLAG_REWARD)

Edges:
  0 -> 1

Function: getLiquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATE_REWARD)

Edges:
  0 -> 1

Function: getRateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_RATE_STALE_PERIOD)

Edges:
  0 -> 1

Function: getExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeDynamicFeeConfig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: keys = new bytes32[](4)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE

  ID: 6
  Type: NodeType.VARIABLE
  Expression: values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME,keys)

  ID: 7
  Type: NodeType.RETURN
  Expression: DynamicFeeConfig({threshold:values[0],weightDecay:values[1],rounds:values[2],maxFee:values[3]})

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: getMinimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_MINIMUM_STAKE_TIME)

Edges:
  0 -> 1

Function: getAggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,SETTING_AGGREGATOR_WARNING_FLAGS)

Edges:
  0 -> 1

Function: getDebtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_DEBT_SNAPSHOT_STALE_TIME)

Edges:
  0 -> 1

Function: getEtherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MAX_ETH)

Edges:
  0 -> 1

Function: getEtherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MINT_FEE_RATE)

Edges:
  0 -> 1

Function: getEtherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_BURN_FEE_RATE)

Edges:
  0 -> 1

Function: getWrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT,wrapper)))

Edges:
  0 -> 1

Function: getWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getInteractionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_INTERACTION_DELAY,collateral)))

Edges:
  0 -> 1

Function: getCollapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE,collateral)))

Edges:
  0 -> 1

Function: getAtomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK)

Edges:
  0 -> 1

Function: getAtomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_TWAP_WINDOW)

Edges:
  0 -> 1

Function: getAtomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,currencyKey)))

Edges:
  0 -> 1

Function: getPureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getCrossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_MAX_DYNAMIC_FEE)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeRounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeWeightDecay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY)

Edges:
  0 -> 1

Function: combineArrays
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: combination = new bytes32[](first.length + second.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < first.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: combination[i] = first[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: j < second.length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: combination[first.length + j] = second[j]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 14
  Type: NodeType.RETURN
  Expression: combination

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11

Function: rebuildCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = resolver.requireAndGetAddress(name,string(abi.encodePacked(Resolver missing target: ,name)))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressCache[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: CacheUpdated(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: isResolverCached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.IF
  Expression: resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = addressCache[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),string(abi.encodePacked(Missing address: ,name)))

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: synthetixERC20
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX))

Edges:
  0 -> 1

Function: exchanger
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER))

Edges:
  0 -> 1

Function: exchangeRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES))

Edges:
  0 -> 1

Function: circuitBreaker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ICircuitBreaker(requireAndGetAddress(CONTRACT_CIRCUIT_BREAKER))

Edges:
  0 -> 1

Function: synthetixDebtShare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE))

Edges:
  0 -> 1

Function: liquidator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ILiquidator(requireAndGetAddress(CONTRACT_LIQUIDATOR))

Edges:
  0 -> 1

Function: liquidatorRewards
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ILiquidatorRewards(requireAndGetAddress(CONTRACT_LIQUIDATOR_REWARDS))

Edges:
  0 -> 1

Function: delegateApprovals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS))

Edges:
  0 -> 1

Function: rewardEscrowV2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IHasBalance(requireAndGetAddress(CONTRACT_REWARDESCROW_V2))

Edges:
  0 -> 1

Function: debtCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE))

Edges:
  0 -> 1

Function: synthRedeemer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER))

Edges:
  0 -> 1

Function: allNetworksDebtInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (None,rawIssuedSynths,None,issuedSynthsUpdatedAt,None) = _latestRoundData(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS))

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (rawRatio,ratioUpdatedAt) = _rawDebtRatioAndUpdatedAt()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: debt = uint256(rawIssuedSynths)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: stalePeriod = getRateStalePeriod()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: isStale = stalePeriod < block.timestamp && (block.timestamp - stalePeriod > issuedSynthsUpdatedAt || block.timestamp - stalePeriod > ratioUpdatedAt)

  ID: 11
  Type: NodeType.IF
  Expression: rawRatio == 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: sharesSupply = 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: sharesSupply = debt.divideDecimalRoundPrecise(uint256(rawRatio))

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: (debt,sharesSupply,isStale)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 11
  9 -> 10
  10 -> 15
  11 -> 12
  11 -> 13
  12 -> 14
  13 -> 14
  14 -> 9

Function: issuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getIssuanceRatio()

Edges:
  0 -> 1

Function: _rateAndInvalid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: exchangeRates().rateAndInvalid(currencyKey)

Edges:
  0 -> 1

Function: _latestRoundData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AggregatorV2V3Interface(aggregator).latestRoundData()

Edges:
  0 -> 1

Function: _rawDebtRatioAndUpdatedAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (None,rawRatioInt,None,ratioUpdatedAt,None) = _latestRoundData(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO))

  ID: 4
  Type: NodeType.RETURN
  Expression: (uint256(rawRatioInt),ratioUpdatedAt)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _sharesForDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (rawRatio,None) = _rawDebtRatioAndUpdatedAt()

  ID: 4
  Type: NodeType.IF
  Expression: rawRatio == 0

  ID: 5
  Type: NodeType.RETURN
  Expression: 0

  ID: 6
  Type: NodeType.RETURN
  Expression: debtAmount.divideDecimalRoundPrecise(rawRatio)

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  4 -> 5
  4 -> 6

Function: _debtForShares
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (rawRatio,None) = _rawDebtRatioAndUpdatedAt()

  ID: 3
  Type: NodeType.RETURN
  Expression: sharesAmount.multiplyDecimalRoundPrecise(rawRatio)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _debtShareBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: synthetixDebtShare().balanceOf(account)

Edges:
  0 -> 1

Function: _snxBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: synthetixERC20().balanceOf(account)

Edges:
  0 -> 1

Function: _rewardEscrowBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: rewardEscrowV2().balanceOf(account)

Edges:
  0 -> 1

Function: _availableCurrencyKeysWithOptionalSNX
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < availableSynths.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[i] = synthsByAddress[address(availableSynths[i])]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.IF
  Expression: withSNX

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: currencyKeys[availableSynths.length] = SNX

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: currencyKeys

  ID: 12
  Type: NodeType.IF
  Expression: withSNX

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: currencyKeys = new bytes32[](availableSynths.length + 1)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: currencyKeys = new bytes32[](availableSynths.length + 0)

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 12
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  12 -> 13
  12 -> 14
  13 -> 15
  14 -> 15
  15 -> 4

Function: _totalIssuedSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (debt,None,cacheIsInvalid,cacheIsStale) = debtCache().cacheInfo()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = cacheIsInvalid || cacheIsStale

  ID: 6
  Type: NodeType.IF
  Expression: ! excludeCollateral

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (nonSnxDebt,invalid) = debtCache().totalNonSnxBackedDebt()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: debt = debt.add(nonSnxDebt)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = anyRateIsInvalid || invalid

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: currencyKey == sUSD

  ID: 14
  Type: NodeType.RETURN
  Expression: (debt,anyRateIsInvalid)

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: (currencyRate,currencyRateInvalid) = _rateAndInvalid(currencyKey)

  ID: 19
  Type: NodeType.RETURN
  Expression: (debt.divideDecimalRound(currencyRate),anyRateIsInvalid || currencyRateInvalid)

  ID: 20
  Type: NodeType.RETURN
  Expression: (totalIssued,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: _debtBalanceOfAndTotalDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (snxBackedAmount,None,debtInfoStale) = allNetworksDebtInfo()

  ID: 4
  Type: NodeType.IF
  Expression: debtShareBalance == 0

  ID: 5
  Type: NodeType.RETURN
  Expression: (0,snxBackedAmount,debtInfoStale)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (currencyRate,currencyRateInvalid) = _rateAndInvalid(currencyKey)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: debtBalance = _debtForShares(debtShareBalance).divideDecimalRound(currencyRate)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: totalSystemValue = snxBackedAmount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = currencyRateInvalid || debtInfoStale

  ID: 13
  Type: NodeType.RETURN
  Expression: (debtBalance,totalSystemValue,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13

Function: _canBurnSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: now >= _lastIssueEvent(account).add(getMinimumStakeTime())

Edges:
  0 -> 1

Function: _lastIssueEvent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(LAST_ISSUE_EVENT,account)))

Edges:
  0 -> 1

Function: _remainingIssuableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (alreadyIssued,totalSystemDebt,anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_debtShareBalanceOf(_issuer),sUSD)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (issuable,isInvalid) = _maxIssuableSynths(_issuer)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: maxIssuable = issuable

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = anyRateIsInvalid || isInvalid

  ID: 7
  Type: NodeType.IF
  Expression: alreadyIssued >= maxIssuable

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: maxIssuable = 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: maxIssuable = maxIssuable.sub(alreadyIssued)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: (maxIssuable,alreadyIssued,totalSystemDebt,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11

Function: _snxToUSD
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: amount.multiplyDecimalRound(snxRate)

Edges:
  0 -> 1

Function: _usdToSnx
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: amount.divideDecimalRound(snxRate)

Edges:
  0 -> 1

Function: _maxIssuableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _issuer == resolver.getAddress(CONTRACT_V3_LEGACYMARKET)

  ID: 2
  Type: NodeType.RETURN
  Expression: (uint256(- 1),false)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (snxRate,isInvalid) = _rateAndInvalid(SNX)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destinationValue = _snxToUSD(_collateral(_issuer),snxRate)

  ID: 8
  Type: NodeType.RETURN
  Expression: (destinationValue.multiplyDecimal(getIssuanceRatio()),isInvalid)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: _collateralisationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalOwnedSynthetix = _collateral(_issuer)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (debtBalance,None,anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_debtShareBalanceOf(_issuer),SNX)

  ID: 5
  Type: NodeType.IF
  Expression: totalOwnedSynthetix == 0

  ID: 6
  Type: NodeType.RETURN
  Expression: (0,anyRateIsInvalid)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (debtBalance.divideDecimalRound(totalOwnedSynthetix),anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: _collateral
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _snxBalanceOf(account).add(_rewardEscrowBalanceOf(account)).add(liquidatorRewards().earned(account))

Edges:
  0 -> 1

Function: minimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getMinimumStakeTime()

Edges:
  0 -> 1

Function: canBurnSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _canBurnSynths(account)

Edges:
  0 -> 1

Function: availableCurrencyKeys
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _availableCurrencyKeysWithOptionalSNX(false)

Edges:
  0 -> 1

Function: availableSynthCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: availableSynths.length

Edges:
  0 -> 1

Function: anySynthOrSNXRateIsInvalid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (None,anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true))

  ID: 2
  Type: NodeType.RETURN
  Expression: anyRateInvalid

Edges:
  0 -> 1
  1 -> 2

Function: totalIssuedSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (totalIssued,None) = _totalIssuedSynths(currencyKey,excludeOtherCollateral)

  ID: 2
  Type: NodeType.RETURN
  Expression: totalIssued

Edges:
  0 -> 1
  1 -> 2

Function: lastIssueEvent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _lastIssueEvent(account)

Edges:
  0 -> 1

Function: collateralisationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (cratio,None) = _collateralisationRatio(_issuer)

  ID: 2
  Type: NodeType.RETURN
  Expression: cratio

Edges:
  0 -> 1
  1 -> 2

Function: collateralisationRatioAndAnyRatesInvalid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _collateralisationRatio(_issuer)

  ID: 2
  Type: NodeType.RETURN
  Expression: (cratio,anyRateIsInvalid)

Edges:
  0 -> 1

Function: collateral
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _collateral(account)

Edges:
  0 -> 1

Function: debtBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: debtShareBalance = _debtShareBalanceOf(_issuer)

  ID: 2
  Type: NodeType.IF
  Expression: debtShareBalance == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (debtBalance,None,None) = _debtBalanceOfAndTotalDebt(debtShareBalance,currencyKey)

  ID: 6
  Type: NodeType.RETURN
  Expression: debtBalance

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6

Function: remainingIssuableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (maxIssuable,alreadyIssued,totalSystemDebt,None) = _remainingIssuableSynths(_issuer)

  ID: 2
  Type: NodeType.RETURN
  Expression: (maxIssuable,alreadyIssued,totalSystemDebt)

Edges:
  0 -> 1
  1 -> 2

Function: maxIssuableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (maxIssuable,None) = _maxIssuableSynths(_issuer)

  ID: 3
  Type: NodeType.RETURN
  Expression: maxIssuable

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferableSynthetixAndAnyRateIsInvalid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (debtBalance,None,anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_debtShareBalanceOf(account),SNX)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio())

  ID: 4
  Type: NodeType.IF
  Expression: lockedSynthetixValue >= balance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: transferable = 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: transferable = balance.sub(lockedSynthetixValue)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (transferable,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 7
  6 -> 7
  7 -> 8

Function: getSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numKeys = currencyKeys.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: addresses = new ISynth[](numKeys)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < numKeys

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: addresses[i] = synths[currencyKeys[i]]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: liquidationAmounts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _liquidationAmounts(account,isSelfLiquidation)

  ID: 2
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtToRemove,escrowToLiquidate,initialDebtBalance)

Edges:
  0 -> 1

Function: _addSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKey = synth.currencyKey()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synths[currencyKey] == ISynth(0),Synth exists)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synthsByAddress[address(synth)] == bytes32(0),Synth address already exists)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: availableSynths.push(synth)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: synths[currencyKey] = synth

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: synthsByAddress[address(synth)] = currencyKey

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: SynthAdded(currencyKey,address(synth))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: addSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _addSynth(synth)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateDebtCacheValidity(true)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: addSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numSynths = synthsToAdd.length

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < numSynths

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _addSynth(synthsToAdd[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateDebtCacheValidity(true)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  9 -> 1

Function: _removeSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: synthToRemove = address(synths[currencyKey])

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synthToRemove != address(0),Synth does not exist)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(currencyKey != sUSD,Cannot remove synth)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: synthSupply = IERC20(synthToRemove).totalSupply()

  ID: 5
  Type: NodeType.IF
  Expression: synthSupply > 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (amountOfsUSD,rateToRedeem,None) = exchangeRates().effectiveValueAndRates(currencyKey,synthSupply,sUSD)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(rateToRedeem > 0,Cannot remove without rate)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: _synthRedeemer = synthRedeemer()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: synths[sUSD].issue(address(_synthRedeemer),amountOfsUSD)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD))

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _synthRedeemer.deprecate(IERC20(address(Proxyable(synthToRemove).proxy())),rateToRedeem)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 18
  Type: NodeType.IFLOOP
  Expression: i < availableSynths.length

  ID: 19
  Type: NodeType.IF
  Expression: address(availableSynths[i]) == synthToRemove

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: delete availableSynths[i]

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: availableSynths[i] = availableSynths[availableSynths.length - 1]

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: availableSynths.length --

  ID: 23
  Type: NodeType.BREAK
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: delete synthsByAddress[synthToRemove]

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: delete synths[currencyKey]

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: SynthRemoved(currencyKey,synthToRemove)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 14
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 17
  15 -> 18
  16 -> 26
  17 -> 15
  18 -> 19
  18 -> 16
  19 -> 20
  19 -> 24
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 16
  24 -> 25
  25 -> 18
  26 -> 27
  27 -> 28

Function: removeSynth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: cache = debtCache()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: cache.updateCachedSynthDebtWithRate(currencyKey,0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: cache.updateDebtCacheValidity(true)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _removeSynth(currencyKey)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: removeSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numKeys = currencyKeys.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: cache = debtCache()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: zeroRates = new uint256[](numKeys)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: cache.updateCachedSynthDebtsWithRates(currencyKeys,zeroRates)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: cache.updateDebtCacheValidity(true)

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < numKeys

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _removeSynth(currencyKeys[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 9
  12 -> 1

Function: issueSynthsWithoutDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(synths[currencyKey]) != address(0),synth doesn't exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,cannot issue 0 synths)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _setLastIssueEvent(to)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: synths[currencyKey].issue(to,amount)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (rate,rateInvalid_scope_0) = _rateAndInvalid(currencyKey)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount.multiplyDecimal(rate)))

  ID: 9
  Type: NodeType.RETURN
  Expression: rateInvalid_scope_0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyTrustedMinters()

  ID: 11
  Type: NodeType.RETURN
  Expression: rateInvalid

Edges:
  0 -> 10
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  10 -> 1

Function: burnSynthsWithoutDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(synths[currencyKey]) != address(0),synth doesn't exist)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,cannot issue 0 synths)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: exchanger().settle(from,currencyKey)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: synths[currencyKey].burn(from,amount)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (rate,rateInvalid_scope_0) = _rateAndInvalid(currencyKey)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateCachedsUSDDebt(- SafeCast.toInt256(amount.multiplyDecimal(rate)))

  ID: 9
  Type: NodeType.RETURN
  Expression: rateInvalid_scope_0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyTrustedMinters()

  ID: 11
  Type: NodeType.RETURN
  Expression: rateInvalid

Edges:
  0 -> 10
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  10 -> 1

Function: burnAndIssueSynthsWithoutDebtCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: exchanger().settle(account,currencyKey)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: synths[currencyKey].burn(account,amountOfSynth)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _setLastIssueEvent(account)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: synths[sUSD].issue(account,amountInsUSD)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlySynthRedeemer()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: modifyDebtSharesForMigration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: sds = synthetixDebtShare()

  ID: 2
  Type: NodeType.IF
  Expression: msg.sender == resolver.getAddress(CONTRACT_DEBT_MIGRATOR_ON_ETHEREUM)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: sds.burnShare(account,amount)

  ID: 4
  Type: NodeType.IF
  Expression: msg.sender == resolver.getAddress(CONTRACT_DEBT_MIGRATOR_ON_OPTIMISM)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sds.mintShare(account,amount)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyTrustedMigrators()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 7
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  8 -> 1

Function: issueSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,cannot issue 0 synths)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _issueSynths(from,amount,false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: issueMaxSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _issueSynths(from,0,true)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 2
  2 -> 1

Function: issueSynthsOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCanIssueOnBehalf(issueForAddress,from)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _issueSynths(issueForAddress,amount,false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: issueMaxSynthsOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCanIssueOnBehalf(issueForAddress,from)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _issueSynths(issueForAddress,0,true)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: burnSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _voluntaryBurnSynths(from,amount,false)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 2
  2 -> 1

Function: burnSynthsOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCanBurnOnBehalf(burnForAddress,from)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _voluntaryBurnSynths(burnForAddress,amount,false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: burnSynthsToTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _voluntaryBurnSynths(from,0,true)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 2
  2 -> 1

Function: burnSynthsToTargetOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _requireCanBurnOnBehalf(burnForAddress,from)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _voluntaryBurnSynths(burnForAddress,0,true)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: burnForRedemption
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ISynth(IProxy(deprecatedSynthProxy).target()).burn(account,balance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlySynthRedeemer()

Edges:
  0 -> 2
  2 -> 1

Function: liquidateAccount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(liquidator().isLiquidationOpen(account,isSelfLiquidation),Not open for liquidation)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (totalRedeemed,debtRemoved,escrowToLiquidate,initialDebtBalance) = _liquidationAmounts(account,isSelfLiquidation)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _removeFromDebtRegister(account,debtRemoved,initialDebtBalance)

  ID: 5
  Type: NodeType.IF
  Expression: ! isSelfLiquidation

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: liquidator().removeAccountInLiquidation(account)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlySynthetix()

  ID: 9
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtRemoved,escrowToLiquidate)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 9
  8 -> 1

Function: _liquidationAmounts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (debtBalance,None,anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_debtShareBalanceOf(account),sUSD)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (snxRate,snxRateInvalid) = _rateAndInvalid(SNX)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: isSelfLiquidation

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: penalty = getSelfLiquidationPenalty()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: debtToRemove = liquidator().calculateAmountToFixCollateral(debtBalance,_snxToUSD(_collateral(account),snxRate),penalty)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: totalRedeemed = _getMinValue(_usdToSnx(debtToRemove,snxRate).multiplyDecimal(SafeDecimalMath.unit().add(penalty)),_snxBalanceOf(account))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: debtToRemove = _getMinValue(_snxToUSD(totalRedeemed,snxRate).divideDecimal(SafeDecimalMath.unit().add(penalty)),debtToRemove)

  ID: 13
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtToRemove,0,debtBalance)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: penalty = getSnxLiquidationPenalty()

  ID: 15
  Type: NodeType.VARIABLE
  Expression: rewardsSum = getLiquidateReward().add(getFlagReward())

  ID: 16
  Type: NodeType.VARIABLE
  Expression: collateralForAccountUSD = _snxToUSD(_collateral(account).sub(rewardsSum),snxRate)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: debtToRemove = liquidator().calculateAmountToFixCollateral(debtBalance,collateralForAccountUSD,penalty)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: redeemTarget = _usdToSnx(debtToRemove,snxRate).multiplyDecimal(SafeDecimalMath.unit().add(penalty))

  ID: 19
  Type: NodeType.IF
  Expression: redeemTarget.add(rewardsSum) >= _collateral(account)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: debtToRemove = debtBalance

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: totalRedeemed = _collateral(account).sub(rewardsSum)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: escrowToLiquidate = _rewardEscrowBalanceOf(account)

  ID: 23
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtToRemove,escrowToLiquidate,debtBalance)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: (totalRedeemed,escrowToLiquidate) = _redeemableCollateralForTarget(account,redeemTarget,rewardsSum)

  ID: 25
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtToRemove,escrowToLiquidate,debtBalance)

  ID: 28
  Type: NodeType.RETURN
  Expression: (totalRedeemed,debtToRemove,escrowToLiquidate,debtBalance)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 14
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 24
  20 -> 21
  21 -> 22
  22 -> 23
  24 -> 25

Function: _redeemableCollateralForTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: transferable = _snxBalanceOf(account)

  ID: 2
  Type: NodeType.IF
  Expression: redeemTarget.add(rewardsSum) <= transferable

  ID: 3
  Type: NodeType.RETURN
  Expression: (redeemTarget,0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: escrowToLiquidate = redeemTarget.add(rewardsSum).sub(transferable)

  ID: 5
  Type: NodeType.RETURN
  Expression: (redeemTarget,escrowToLiquidate)

  ID: 7
  Type: NodeType.RETURN
  Expression: (totalRedeemed,escrowToLiquidate)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5

Function: _getMinValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: x < y

  ID: 3
  Type: NodeType.RETURN
  Expression: x

  ID: 4
  Type: NodeType.RETURN
  Expression: y

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: setCurrentPeriodId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == requireAndGetAddress(CONTRACT_FEEPOOL),Must be fee pool)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sds = synthetixDebtShare()

  ID: 3
  Type: NodeType.IF
  Expression: sds.currentPeriodId() < periodId

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: sds.takeSnapshot(periodId)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5

Function: _requireRatesNotInvalid
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! anyRateIsInvalid,A synth or SNX rate is invalid)

Edges:
  0 -> 1

Function: _requireCanIssueOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(delegateApprovals().canIssueFor(issueForAddress,from),Not approved to act on behalf)

Edges:
  0 -> 1

Function: _requireCanBurnOnBehalf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(delegateApprovals().canBurnFor(burnForAddress,from),Not approved to act on behalf)

Edges:
  0 -> 1

Function: _issueSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _verifyCircuitBreakers()

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (maxIssuable,None,None,anyRateIsInvalid) = _remainingIssuableSynths(from)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _requireRatesNotInvalid(anyRateIsInvalid)

  ID: 8
  Type: NodeType.IF
  Expression: ! issueMax

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount <= maxIssuable,Amount too large)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: amount = maxIssuable

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _addToDebtRegister(from,amount)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _setLastIssueEvent(from)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: synths[sUSD].issue(from,amount)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount))

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15

Function: _burnSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _verifyCircuitBreakers()

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _removeFromDebtRegister(debtAccount,amountBurnt,existingDebt)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: synths[sUSD].burn(burnAccount,amountBurnt)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: debtCache().updateCachedsUSDDebt(- SafeCast.toInt256(amountBurnt))

  ID: 8
  Type: NodeType.IF
  Expression: existingDebt < amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: amountBurnt = existingDebt

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: amountBurnt = amount

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: amountBurnt

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 8
  5 -> 6
  6 -> 7
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 5

Function: _voluntaryBurnSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _verifyCircuitBreakers()

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: ! burnToTarget

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_canBurnSynths(from),Minimum stake time not reached)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (None,refunded,numEntriesSettled) = exchanger().settle(from,sUSD)

  ID: 9
  Type: NodeType.IF
  Expression: numEntriesSettled > 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: amount = exchanger().calculateAmountAfterSettlement(from,sUSD,amount,refunded)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (existingDebt,None,anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_debtShareBalanceOf(from),sUSD)

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: (maxIssuableSynthsForAccount,snxRateInvalid) = _maxIssuableSynths(from)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(existingDebt > 0,No debt to forgive)

  ID: 21
  Type: NodeType.IF
  Expression: burnToTarget

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: amount = existingDebt.sub(maxIssuableSynthsForAccount)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.VARIABLE
  Expression: amountBurnt = _burnSynths(from,from,amount,existingDebt)

  ID: 25
  Type: NodeType.IF
  Expression: existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: liquidator().removeAccountInLiquidation(from)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 12
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  26 -> 27

Function: _setLastIssueEvent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(LAST_ISSUE_EVENT,account)),block.timestamp)

Edges:
  0 -> 1

Function: _addToDebtRegister
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: liquidatorRewards().updateEntry(from)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sds = synthetixDebtShare()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: debtShares = _sharesForDebt(amount)

  ID: 4
  Type: NodeType.IF
  Expression: debtShares == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sds.mintShare(from,amount)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: sds.mintShare(from,debtShares)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 7
  6 -> 7

Function: _removeFromDebtRegister
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: liquidatorRewards().updateEntry(from)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sds = synthetixDebtShare()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: currentDebtShare = _debtShareBalanceOf(from)

  ID: 4
  Type: NodeType.IF
  Expression: debtToRemove == existingDebt

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sds.burnShare(from,currentDebtShare)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: sharesToRemove = _sharesForDebt(debtToRemove)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: sharesToRemove < currentDebtShare

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sds.burnShare(from,sharesToRemove)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: sds.burnShare(from,currentDebtShare)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 8
  6 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 8

Function: _verifyCircuitBreakers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: debtRatioAggregator = requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (None,rawRatio,None,None,None) = AggregatorV2V3Interface(debtRatioAggregator).latestRoundData()

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (None,broken,None) = exchangeRates().rateWithSafetyChecks(SNX)

  ID: 6
  Type: NodeType.RETURN
  Expression: circuitBreaker().probeCircuitBreaker(debtRatioAggregator,uint256(rawRatio)) || broken

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _onlySynthRedeemer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == address(synthRedeemer()) || msg.sender == resolver.getAddress(CONTRACT_DYNAMICSYNTHREDEEMER),Only SynthRedeemer)

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CONTRACT_NAME = SystemSettings

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WAITING_PERIOD_SECS = waitingPeriodSecs

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = priceDeviationThresholdFactor

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ISSUANCE_RATIO = issuanceRatio

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FEE_PERIOD_DURATION = feePeriodDuration

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TARGET_THRESHOLD = targetThreshold

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_DELAY = liquidationDelay

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_RATIO = liquidationRatio

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_ESCROW_DURATION = liquidationEscrowDuration

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_PENALTY = liquidationPenalty

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SNX_LIQUIDATION_PENALTY = snxLiquidationPenalty

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SELF_LIQUIDATION_PENALTY = selfLiquidationPenalty

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FLAG_REWARD = flagReward

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATE_REWARD = liquidateReward

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_RATE_STALE_PERIOD = rateStalePeriod

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_FEE_RATE = exchangeFeeRate

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = exchangeDynamicFeeThreshold

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = exchangeDynamicFeeWeightDecay

  ID: 18
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = exchangeDynamicFeeRounds

  ID: 19
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_MAX_DYNAMIC_FEE = exchangeMaxDynamicFee

  ID: 20
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_MINIMUM_STAKE_TIME = minimumStakeTime

  ID: 21
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_AGGREGATOR_WARNING_FLAGS = aggregatorWarningFlags

  ID: 22
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TRADING_REWARDS_ENABLED = tradingRewardsEnabled

  ID: 23
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_DEBT_SNAPSHOT_STALE_TIME = debtSnapshotStaleTime

  ID: 24
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = crossDomainDepositGasLimit

  ID: 25
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = crossDomainEscrowGasLimit

  ID: 26
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = crossDomainRewardGasLimit

  ID: 27
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = crossDomainWithdrawalGasLimit

  ID: 28
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = crossDomainCloseGasLimit

  ID: 29
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = crossDomainRelayGasLimit

  ID: 30
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MAX_ETH = etherWrapperMaxETH

  ID: 31
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MINT_FEE_RATE = etherWrapperMintFeeRate

  ID: 32
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_BURN_FEE_RATE = etherWrapperBurnFeeRate

  ID: 33
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MAX_TOKEN_AMOUNT = wrapperMaxTokens

  ID: 34
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MINT_FEE_RATE = wrapperMintFeeRate

  ID: 35
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_BURN_FEE_RATE = wrapperBurnFeeRate

  ID: 36
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_INTERACTION_DELAY = interactionDelay

  ID: 37
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_COLLAPSE_FEE_RATE = collapseFeeRate

  ID: 38
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = atomicMaxVolumePerBlock

  ID: 39
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_TWAP_WINDOW = atomicTwapWindow

  ID: 40
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = atomicEquivalentForDexPricing

  ID: 41
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EXCHANGE_FEE_RATE = atomicExchangeFeeRate

  ID: 42
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = atomicVolConsiderationWindow

  ID: 43
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = atomicVolUpdateThreshold

  ID: 44
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED = pureChainlinkForAtomicsEnabled

  ID: 45
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_SYNTH_TRANSFER_ENABLED = crossChainSynthTransferEnabled

  ID: 46
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_FLEXIBLESTORAGE = FlexibleStorage

  ID: 47
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_NAME = Issuer

  ID: 48
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: sUSD = sUSD

  ID: 49
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SNX = SNX

  ID: 50
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: LAST_ISSUE_EVENT = lastIssueEvent

  ID: 51
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_SYNTHETIX = Synthetix

  ID: 52
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_EXCHANGER = Exchanger

  ID: 53
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_EXRATES = ExchangeRates

  ID: 54
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_CIRCUIT_BREAKER = CircuitBreaker

  ID: 55
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_SYNTHETIXDEBTSHARE = SynthetixDebtShare

  ID: 56
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_FEEPOOL = FeePool

  ID: 57
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_DELEGATEAPPROVALS = DelegateApprovals

  ID: 58
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_REWARDESCROW_V2 = RewardEscrowV2

  ID: 59
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_LIQUIDATOR = Liquidator

  ID: 60
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_LIQUIDATOR_REWARDS = LiquidatorRewards

  ID: 61
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_DEBTCACHE = DebtCache

  ID: 62
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_DYNAMICSYNTHREDEEMER = DynamicSynthRedeemer

  ID: 63
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_SYNTHREDEEMER = SynthRedeemer

  ID: 64
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_SYNTHETIXBRIDGETOOPTIMISM = SynthetixBridgeToOptimism

  ID: 65
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_SYNTHETIXBRIDGETOBASE = SynthetixBridgeToBase

  ID: 66
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_DEBT_MIGRATOR_ON_ETHEREUM = DebtMigratorOnEthereum

  ID: 67
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_DEBT_MIGRATOR_ON_OPTIMISM = DebtMigratorOnOptimism

  ID: 68
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_V3_LEGACYMARKET = LegacyMarket

  ID: 69
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS = ext:AggregatorIssuedSynths

  ID: 70
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_EXT_AGGREGATOR_DEBT_RATIO = ext:AggregatorDebtRatio

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 50
  50 -> 51
  51 -> 52
  52 -> 53
  53 -> 54
  54 -> 55
  55 -> 56
  56 -> 57
  57 -> 58
  58 -> 59
  59 -> 60
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64
  64 -> 65
  65 -> 66
  66 -> 67
  67 -> 68
  68 -> 69
  69 -> 70


Contract: ISystemSettings
==================================================


Contract: SystemSettingsLib
==================================================

Function: contractName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: SETTINGS_CONTRACT_NAME

Edges:
  0 -> 1

Function: setCrossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(crossDomainMessageGasLimit >= MIN_CROSS_DOMAIN_GAS_LIMIT && crossDomainMessageGasLimit <= MAX_CROSS_DOMAIN_GAS_LIMIT,Out of range xDomain gasLimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,gasLimitSettings,crossDomainMessageGasLimit)

Edges:
  0 -> 1
  1 -> 2

Function: setIssuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ratio <= MAX_ISSUANCE_RATIO,New issuance ratio cannot exceed MAX_ISSUANCE_RATIO)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,ratio)

Edges:
  0 -> 1
  1 -> 2

Function: setTradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setBoolValue(SETTINGS_CONTRACT_NAME,settingName,_tradingRewardsEnabled)

Edges:
  0 -> 1

Function: setWaitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_waitingPeriodSecs)

Edges:
  0 -> 1

Function: setPriceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_priceDeviationThresholdFactor)

Edges:
  0 -> 1

Function: setFeePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_feePeriodDuration >= MIN_FEE_PERIOD_DURATION,value < MIN_FEE_PERIOD_DURATION)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_feePeriodDuration <= MAX_FEE_PERIOD_DURATION,value > MAX_FEE_PERIOD_DURATION)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_feePeriodDuration)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setTargetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(percent <= MAX_TARGET_THRESHOLD,Threshold too high)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: threshold = percent.mul(SafeDecimalMath.unit()).div(100)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,threshold)

  ID: 4
  Type: NodeType.RETURN
  Expression: threshold

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setLiquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(time <= MAX_LIQUIDATION_DELAY,Must be less than MAX_LIQUIDATION_DELAY)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(time >= MIN_LIQUIDATION_DELAY,Must be greater than MIN_LIQUIDATION_DELAY)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,time)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setLiquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_liquidationRatio <= MAX_LIQUIDATION_RATIO.divideDecimal(SafeDecimalMath.unit().add(getSnxLiquidationPenalty)),liquidationRatio > MAX_LIQUIDATION_RATIO / (1 + penalty))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: MIN_LIQUIDATION_RATIO = getIssuanceRatio.multiplyDecimal(RATIO_FROM_TARGET_BUFFER)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_liquidationRatio >= MIN_LIQUIDATION_RATIO,liquidationRatio < MIN_LIQUIDATION_RATIO)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_liquidationRatio)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setLiquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,duration)

Edges:
  0 -> 1

Function: setSnxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(penalty <= MAX_LIQUIDATION_PENALTY,penalty > MAX_LIQUIDATION_PENALTY)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,penalty)

Edges:
  0 -> 1
  1 -> 2

Function: setSelfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(penalty <= MAX_LIQUIDATION_PENALTY,penalty > MAX_LIQUIDATION_PENALTY)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,penalty)

Edges:
  0 -> 1
  1 -> 2

Function: setLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(penalty <= MAX_LIQUIDATION_PENALTY,penalty > MAX_LIQUIDATION_PENALTY)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,penalty)

Edges:
  0 -> 1
  1 -> 2

Function: setFlagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,reward)

Edges:
  0 -> 1

Function: setLiquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,reward)

Edges:
  0 -> 1

Function: setRateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,period)

Edges:
  0 -> 1

Function: setExchangeFeeRateForSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synthKeys.length == exchangeFeeRates.length,Array lengths dont match)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < synthKeys.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(exchangeFeeRates[i] <= MAX_EXCHANGE_FEE_RATE,MAX_EXCHANGE_FEE_RATE exceeded)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingExchangeFeeRate,synthKeys[i])),exchangeFeeRates[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 5

Function: setMinimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_seconds <= MAX_MINIMUM_STAKE_TIME,stake time exceed maximum 1 week)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_seconds)

Edges:
  0 -> 1
  1 -> 2

Function: setDebtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_seconds)

Edges:
  0 -> 1

Function: setAggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_flags != address(0),Valid address must be given)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setAddressValue(SETTINGS_CONTRACT_NAME,settingName,_flags)

Edges:
  0 -> 1
  1 -> 2

Function: setEtherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_maxETH)

Edges:
  0 -> 1

Function: setEtherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate <= uint256(MAX_WRAPPER_MINT_FEE_RATE),rate > MAX_WRAPPER_MINT_FEE_RATE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_rate)

Edges:
  0 -> 1
  1 -> 2

Function: setEtherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate <= uint256(MAX_WRAPPER_BURN_FEE_RATE),rate > MAX_WRAPPER_BURN_FEE_RATE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_rate)

Edges:
  0 -> 1
  1 -> 2

Function: setWrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_wrapper)),_maxTokenAmount)

Edges:
  0 -> 1

Function: setWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate <= MAX_WRAPPER_MINT_FEE_RATE,rate > MAX_WRAPPER_MINT_FEE_RATE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate >= - MAX_WRAPPER_MINT_FEE_RATE,rate < -MAX_WRAPPER_MINT_FEE_RATE)

  ID: 3
  Type: NodeType.IF
  Expression: _rate < 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(- _rate <= getWrapperBurnFeeRate,-rate > wrapperBurnFeeRate)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_wrapper)),_rate)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: setWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate <= MAX_WRAPPER_BURN_FEE_RATE,rate > MAX_WRAPPER_BURN_FEE_RATE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rate >= - MAX_WRAPPER_BURN_FEE_RATE,rate < -MAX_WRAPPER_BURN_FEE_RATE)

  ID: 3
  Type: NodeType.IF
  Expression: _rate < 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(- _rate <= getWrapperMintFeeRate,-rate > wrapperMintFeeRate)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_wrapper)),_rate)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: setInteractionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_interactionDelay <= SafeDecimalMath.unit() * 3600,Max 1 hour)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_collateral)),_interactionDelay)

Edges:
  0 -> 1
  1 -> 2

Function: setCollapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_collateral)),_collapseFeeRate)

Edges:
  0 -> 1

Function: setAtomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_maxVolume <= MAX_ATOMIC_VOLUME_PER_BLOCK,Atomic max volume exceed maximum uint192)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_maxVolume)

Edges:
  0 -> 1
  1 -> 2

Function: setAtomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_window >= MIN_ATOMIC_TWAP_WINDOW,Atomic twap window under minimum 1 min)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_window <= MAX_ATOMIC_TWAP_WINDOW,Atomic twap window exceed maximum 1 day)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,_window)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setAtomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_equivalent != address(0),Atomic equivalent is 0 address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setAddressValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_equivalent)

Edges:
  0 -> 1
  1 -> 2

Function: setAtomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE,MAX_EXCHANGE_FEE_RATE exceeded)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_exchangeFeeRate)

Edges:
  0 -> 1
  1 -> 2

Function: setAtomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _window != 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_window >= MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,Atomic volatility consideration window under minimum 1 min)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_window <= MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,Atomic volatility consideration window exceed maximum 1 day)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_window)

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4
  4 -> 5

Function: setAtomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_threshold)

Edges:
  0 -> 1

Function: setPureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setBoolValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_enabled)

Edges:
  0 -> 1

Function: setCrossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(settingName,_currencyKey)),_value)

Edges:
  0 -> 1

Function: setExchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(maxFee != 0,Max dynamic fee cannot be 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(maxFee <= MAX_EXCHANGE_FEE_RATE,MAX_EXCHANGE_FEE_RATE exceeded)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME,settingName,maxFee)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTINGS_CONTRACT_NAME = SystemSettings

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_ISSUANCE_RATIO = 1e18

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_FEE_PERIOD_DURATION = 86400

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_FEE_PERIOD_DURATION = 5184000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_TARGET_THRESHOLD = 50

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_LIQUIDATION_RATIO = 1e18

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: RATIO_FROM_TARGET_BUFFER = 2e18

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_LIQUIDATION_PENALTY = 9e18 / 10

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_LIQUIDATION_DELAY = 259200

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_LIQUIDATION_DELAY = 300

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_EXCHANGE_FEE_RATE = 1e18 / 10

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_MINIMUM_STAKE_TIME = 604800

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_CROSS_DOMAIN_GAS_LIMIT = 12e6

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_CROSS_DOMAIN_GAS_LIMIT = 3e6

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_WRAPPER_MINT_FEE_RATE = 1e18

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_WRAPPER_BURN_FEE_RATE = 1e18

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_ATOMIC_VOLUME_PER_BLOCK = uint192(- 1)

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_ATOMIC_TWAP_WINDOW = 60

  ID: 18
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_ATOMIC_TWAP_WINDOW = 86400

  ID: 19
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 60

  ID: 20
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 86400

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20


Contract: SystemSettings
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(SETTING_CONTRACT_NAME == SystemSettingsLib.contractName(),read and write keys not equal)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MixinSystemSettings(_resolver)

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: resolverAddressesRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1

Function: flexibleStorage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE))

Edges:
  0 -> 1

Function: _getGasLimitSetting
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Deposit

  ID: 2
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT

  ID: 3
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Escrow

  ID: 4
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT

  ID: 5
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Reward

  ID: 6
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT

  ID: 7
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Withdrawal

  ID: 8
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT

  ID: 9
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.Relay

  ID: 10
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT

  ID: 11
  Type: NodeType.IF
  Expression: gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod

  ID: 12
  Type: NodeType.RETURN
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Unknown gas limit type)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  9 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: getCrossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,_getGasLimitSetting(gasLimitType))

Edges:
  0 -> 1

Function: getTradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,SETTING_TRADING_REWARDS_ENABLED)

Edges:
  0 -> 1

Function: getWaitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_WAITING_PERIOD_SECS)

Edges:
  0 -> 1

Function: getPriceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR)

Edges:
  0 -> 1

Function: getIssuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ISSUANCE_RATIO)

Edges:
  0 -> 1

Function: getFeePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FEE_PERIOD_DURATION)

Edges:
  0 -> 1

Function: getTargetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_TARGET_THRESHOLD)

Edges:
  0 -> 1

Function: getLiquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_DELAY)

Edges:
  0 -> 1

Function: getLiquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_RATIO)

Edges:
  0 -> 1

Function: getLiquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_ESCROW_DURATION)

Edges:
  0 -> 1

Function: getLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSnxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SNX_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getSelfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_SELF_LIQUIDATION_PENALTY)

Edges:
  0 -> 1

Function: getFlagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_FLAG_REWARD)

Edges:
  0 -> 1

Function: getLiquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATE_REWARD)

Edges:
  0 -> 1

Function: getRateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_RATE_STALE_PERIOD)

Edges:
  0 -> 1

Function: getExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeDynamicFeeConfig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: keys = new bytes32[](4)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE

  ID: 6
  Type: NodeType.VARIABLE
  Expression: values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME,keys)

  ID: 7
  Type: NodeType.RETURN
  Expression: DynamicFeeConfig({threshold:values[0],weightDecay:values[1],rounds:values[2],maxFee:values[3]})

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: getMinimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_MINIMUM_STAKE_TIME)

Edges:
  0 -> 1

Function: getAggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,SETTING_AGGREGATOR_WARNING_FLAGS)

Edges:
  0 -> 1

Function: getDebtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_DEBT_SNAPSHOT_STALE_TIME)

Edges:
  0 -> 1

Function: getEtherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MAX_ETH)

Edges:
  0 -> 1

Function: getEtherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_MINT_FEE_RATE)

Edges:
  0 -> 1

Function: getEtherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ETHER_WRAPPER_BURN_FEE_RATE)

Edges:
  0 -> 1

Function: getWrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT,wrapper)))

Edges:
  0 -> 1

Function: getWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE,wrapper)))

Edges:
  0 -> 1

Function: getInteractionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_INTERACTION_DELAY,collateral)))

Edges:
  0 -> 1

Function: getCollapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE,collateral)))

Edges:
  0 -> 1

Function: getAtomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK)

Edges:
  0 -> 1

Function: getAtomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_ATOMIC_TWAP_WINDOW)

Edges:
  0 -> 1

Function: getAtomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,currencyKey)))

Edges:
  0 -> 1

Function: getAtomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,currencyKey)))

Edges:
  0 -> 1

Function: getPureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getCrossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,keccak256(bytes)(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED,currencyKey)))

Edges:
  0 -> 1

Function: getExchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_MAX_DYNAMIC_FEE)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeRounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD)

Edges:
  0 -> 1

Function: getExchangeDynamicFeeWeightDecay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY)

Edges:
  0 -> 1

Function: combineArrays
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: combination = new bytes32[](first.length + second.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < first.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: combination[i] = first[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: j < second.length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: combination[first.length + j] = second[j]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 14
  Type: NodeType.RETURN
  Expression: combination

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11

Function: rebuildCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = resolver.requireAndGetAddress(name,string(abi.encodePacked(Resolver missing target: ,name)))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressCache[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: CacheUpdated(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: isResolverCached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.IF
  Expression: resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = addressCache[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),string(abi.encodePacked(Missing address: ,name)))

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: CONTRACT_NAME
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: SystemSettingsLib.contractName()

Edges:
  0 -> 1

Function: waitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getWaitingPeriodSecs()

Edges:
  0 -> 1

Function: priceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getPriceDeviationThresholdFactor()

Edges:
  0 -> 1

Function: issuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getIssuanceRatio()

Edges:
  0 -> 1

Function: feePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getFeePeriodDuration()

Edges:
  0 -> 1

Function: targetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getTargetThreshold()

Edges:
  0 -> 1

Function: liquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getLiquidationDelay()

Edges:
  0 -> 1

Function: liquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getLiquidationRatio()

Edges:
  0 -> 1

Function: liquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getLiquidationPenalty()

Edges:
  0 -> 1

Function: snxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getSnxLiquidationPenalty()

Edges:
  0 -> 1

Function: liquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getLiquidationEscrowDuration()

Edges:
  0 -> 1

Function: selfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getSelfLiquidationPenalty()

Edges:
  0 -> 1

Function: flagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getFlagReward()

Edges:
  0 -> 1

Function: liquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getLiquidateReward()

Edges:
  0 -> 1

Function: rateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getRateStalePeriod()

Edges:
  0 -> 1

Function: exchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getExchangeFeeRate(currencyKey)

Edges:
  0 -> 1

Function: exchangeDynamicFeeThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getExchangeDynamicFeeConfig().threshold

Edges:
  0 -> 1

Function: exchangeDynamicFeeWeightDecay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getExchangeDynamicFeeConfig().weightDecay

Edges:
  0 -> 1

Function: exchangeDynamicFeeRounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getExchangeDynamicFeeConfig().rounds

Edges:
  0 -> 1

Function: exchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getExchangeDynamicFeeConfig().maxFee

Edges:
  0 -> 1

Function: minimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getMinimumStakeTime()

Edges:
  0 -> 1

Function: debtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getDebtSnapshotStaleTime()

Edges:
  0 -> 1

Function: aggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAggregatorWarningFlags()

Edges:
  0 -> 1

Function: tradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getTradingRewardsEnabled()

Edges:
  0 -> 1

Function: crossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getCrossDomainMessageGasLimit(gasLimitType)

Edges:
  0 -> 1

Function: etherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getEtherWrapperMaxETH()

Edges:
  0 -> 1

Function: etherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getEtherWrapperMintFeeRate()

Edges:
  0 -> 1

Function: etherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getEtherWrapperBurnFeeRate()

Edges:
  0 -> 1

Function: wrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getWrapperMaxTokenAmount(wrapper)

Edges:
  0 -> 1

Function: wrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getWrapperMintFeeRate(wrapper)

Edges:
  0 -> 1

Function: wrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getWrapperBurnFeeRate(wrapper)

Edges:
  0 -> 1

Function: interactionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getInteractionDelay(collateral)

Edges:
  0 -> 1

Function: collapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getCollapseFeeRate(collateral)

Edges:
  0 -> 1

Function: atomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicMaxVolumePerBlock()

Edges:
  0 -> 1

Function: atomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicTwapWindow()

Edges:
  0 -> 1

Function: atomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicEquivalentForDexPricing(currencyKey)

Edges:
  0 -> 1

Function: atomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicExchangeFeeRate(currencyKey)

Edges:
  0 -> 1

Function: atomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicVolatilityConsiderationWindow(currencyKey)

Edges:
  0 -> 1

Function: atomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getAtomicVolatilityUpdateThreshold(currencyKey)

Edges:
  0 -> 1

Function: pureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getPureChainlinkPriceForAtomicSwapsEnabled(currencyKey)

Edges:
  0 -> 1

Function: crossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getCrossChainSynthTransferEnabled(currencyKey)

Edges:
  0 -> 1

Function: setCrossDomainMessageGasLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setCrossDomainMessageGasLimit(_getGasLimitSetting(_gasLimitType),_crossDomainMessageGasLimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: CrossDomainMessageGasLimitChanged(_gasLimitType,_crossDomainMessageGasLimit)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setIssuanceRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO,ratio)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: IssuanceRatioUpdated(ratio)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setTradingRewardsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setTradingRewardsEnabled(SETTING_TRADING_REWARDS_ENABLED,_tradingRewardsEnabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TradingRewardsEnabled(_tradingRewardsEnabled)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setWaitingPeriodSecs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS,_waitingPeriodSecs)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: WaitingPeriodSecsUpdated(_waitingPeriodSecs)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setPriceDeviationThresholdFactor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setPriceDeviationThresholdFactor(SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,_priceDeviationThresholdFactor)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setFeePeriodDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION,_feePeriodDuration)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: FeePeriodDurationUpdated(_feePeriodDuration)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setTargetThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: threshold = flexibleStorage().setTargetThreshold(SETTING_TARGET_THRESHOLD,percent)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TargetThresholdUpdated(threshold)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setLiquidationDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY,time)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: LiquidationDelayUpdated(time)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setLiquidationRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setLiquidationRatio(SETTING_LIQUIDATION_RATIO,_liquidationRatio,getSnxLiquidationPenalty(),getIssuanceRatio())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: LiquidationRatioUpdated(_liquidationRatio)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setLiquidationEscrowDuration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATION_ESCROW_DURATION,duration)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: LiquidationEscrowDurationUpdated(duration)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setSnxLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setSnxLiquidationPenalty(SETTING_SNX_LIQUIDATION_PENALTY,penalty)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: SnxLiquidationPenaltyUpdated(penalty)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY,penalty)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: LiquidationPenaltyUpdated(penalty)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setSelfLiquidationPenalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setSelfLiquidationPenalty(SETTING_SELF_LIQUIDATION_PENALTY,penalty)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: SelfLiquidationPenaltyUpdated(penalty)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setFlagReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_FLAG_REWARD,reward)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: FlagRewardUpdated(reward)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setLiquidateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_LIQUIDATE_REWARD,reward)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: LiquidateRewardUpdated(reward)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setRateStalePeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD,period)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: RateStalePeriodUpdated(period)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setExchangeFeeRateForSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE,synthKeys,exchangeFeeRates)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < synthKeys.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ExchangeFeeUpdated(synthKeys[i],exchangeFeeRates[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 1

Function: setExchangeDynamicFeeThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(threshold != 0,Threshold cannot be 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD,threshold)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ExchangeDynamicFeeThresholdUpdated(threshold)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: setExchangeDynamicFeeWeightDecay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(weightDecay != 0,Weight decay cannot be 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY,weightDecay)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ExchangeDynamicFeeWeightDecayUpdated(weightDecay)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: setExchangeDynamicFeeRounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME,SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS,rounds)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ExchangeDynamicFeeRoundsUpdated(rounds)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setExchangeMaxDynamicFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE,maxFee)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ExchangeMaxDynamicFeeUpdated(maxFee)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setMinimumStakeTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME,_seconds)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MinimumStakeTimeUpdated(_seconds)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setDebtSnapshotStaleTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME,_seconds)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: DebtSnapshotStaleTimeUpdated(_seconds)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAggregatorWarningFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAggregatorWarningFlags(SETTING_AGGREGATOR_WARNING_FLAGS,_flags)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AggregatorWarningFlagsUpdated(_flags)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setEtherWrapperMaxETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH,_maxETH)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EtherWrapperMaxETHUpdated(_maxETH)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setEtherWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE,_rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EtherWrapperMintFeeRateUpdated(_rate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setEtherWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE,_rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: EtherWrapperBurnFeeRateUpdated(_rate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setWrapperMaxTokenAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setWrapperMaxTokenAmount(SETTING_WRAPPER_MAX_TOKEN_AMOUNT,_wrapper,_maxTokenAmount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: WrapperMaxTokenAmountUpdated(_wrapper,_maxTokenAmount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setWrapperMintFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setWrapperMintFeeRate(SETTING_WRAPPER_MINT_FEE_RATE,_wrapper,_rate,getWrapperBurnFeeRate(_wrapper))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: WrapperMintFeeRateUpdated(_wrapper,_rate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setWrapperBurnFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setWrapperBurnFeeRate(SETTING_WRAPPER_BURN_FEE_RATE,_wrapper,_rate,getWrapperMintFeeRate(_wrapper))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: WrapperBurnFeeRateUpdated(_wrapper,_rate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setInteractionDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY,_collateral,_interactionDelay)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: InteractionDelayUpdated(_interactionDelay)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setCollapseFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE,_collateral,_collapseFeeRate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: CollapseFeeRateUpdated(_collapseFeeRate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicMaxVolumePerBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK,_maxVolume)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicMaxVolumePerBlockUpdated(_maxVolume)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicTwapWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW,_window)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicTwapWindowUpdated(_window)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicEquivalentForDexPricing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicEquivalentForDexPricing(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,_currencyKey,_equivalent)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicEquivalentForDexPricingUpdated(_currencyKey,_equivalent)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicExchangeFeeRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicExchangeFeeRate(SETTING_ATOMIC_EXCHANGE_FEE_RATE,_currencyKey,_exchangeFeeRate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicExchangeFeeUpdated(_currencyKey,_exchangeFeeRate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicVolatilityConsiderationWindow
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicVolatilityConsiderationWindow(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,_currencyKey,_window)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicVolatilityConsiderationWindowUpdated(_currencyKey,_window)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAtomicVolatilityUpdateThreshold
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setAtomicVolatilityUpdateThreshold(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,_currencyKey,_threshold)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AtomicVolatilityUpdateThresholdUpdated(_currencyKey,_threshold)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setPureChainlinkPriceForAtomicSwapsEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setPureChainlinkPriceForAtomicSwapsEnabled(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,_currencyKey,_enabled)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: PureChainlinkPriceForAtomicSwapsEnabledUpdated(_currencyKey,_enabled)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setCrossChainSynthTransferEnabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: flexibleStorage().setCrossChainSynthTransferEnabled(SETTING_CROSS_SYNTH_TRANSFER_ENABLED,_currencyKey,_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: CrossChainSynthTransferEnabledUpdated(_currencyKey,_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CONTRACT_NAME = SystemSettings

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WAITING_PERIOD_SECS = waitingPeriodSecs

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = priceDeviationThresholdFactor

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ISSUANCE_RATIO = issuanceRatio

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FEE_PERIOD_DURATION = feePeriodDuration

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TARGET_THRESHOLD = targetThreshold

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_DELAY = liquidationDelay

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_RATIO = liquidationRatio

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_ESCROW_DURATION = liquidationEscrowDuration

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATION_PENALTY = liquidationPenalty

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SNX_LIQUIDATION_PENALTY = snxLiquidationPenalty

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_SELF_LIQUIDATION_PENALTY = selfLiquidationPenalty

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_FLAG_REWARD = flagReward

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_LIQUIDATE_REWARD = liquidateReward

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_RATE_STALE_PERIOD = rateStalePeriod

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_FEE_RATE = exchangeFeeRate

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = exchangeDynamicFeeThreshold

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = exchangeDynamicFeeWeightDecay

  ID: 18
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = exchangeDynamicFeeRounds

  ID: 19
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_EXCHANGE_MAX_DYNAMIC_FEE = exchangeMaxDynamicFee

  ID: 20
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_MINIMUM_STAKE_TIME = minimumStakeTime

  ID: 21
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_AGGREGATOR_WARNING_FLAGS = aggregatorWarningFlags

  ID: 22
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_TRADING_REWARDS_ENABLED = tradingRewardsEnabled

  ID: 23
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_DEBT_SNAPSHOT_STALE_TIME = debtSnapshotStaleTime

  ID: 24
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = crossDomainDepositGasLimit

  ID: 25
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = crossDomainEscrowGasLimit

  ID: 26
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = crossDomainRewardGasLimit

  ID: 27
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = crossDomainWithdrawalGasLimit

  ID: 28
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = crossDomainCloseGasLimit

  ID: 29
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = crossDomainRelayGasLimit

  ID: 30
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MAX_ETH = etherWrapperMaxETH

  ID: 31
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_MINT_FEE_RATE = etherWrapperMintFeeRate

  ID: 32
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ETHER_WRAPPER_BURN_FEE_RATE = etherWrapperBurnFeeRate

  ID: 33
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MAX_TOKEN_AMOUNT = wrapperMaxTokens

  ID: 34
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_MINT_FEE_RATE = wrapperMintFeeRate

  ID: 35
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_WRAPPER_BURN_FEE_RATE = wrapperBurnFeeRate

  ID: 36
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_INTERACTION_DELAY = interactionDelay

  ID: 37
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_COLLAPSE_FEE_RATE = collapseFeeRate

  ID: 38
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = atomicMaxVolumePerBlock

  ID: 39
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_TWAP_WINDOW = atomicTwapWindow

  ID: 40
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = atomicEquivalentForDexPricing

  ID: 41
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_EXCHANGE_FEE_RATE = atomicExchangeFeeRate

  ID: 42
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = atomicVolConsiderationWindow

  ID: 43
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = atomicVolUpdateThreshold

  ID: 44
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED = pureChainlinkForAtomicsEnabled

  ID: 45
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SETTING_CROSS_SYNTH_TRANSFER_ENABLED = crossChainSynthTransferEnabled

  ID: 46
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_FLEXIBLESTORAGE = FlexibleStorage

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46


Contract: Pausable
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),Owner must be set)

Edges:
  0 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: setPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _paused == paused

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: paused = _paused

  ID: 5
  Type: NodeType.IF
  Expression: paused

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: lastPauseTime = now

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: PauseChanged(paused)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  9 -> 1


Contract: ICollateralManager
==================================================


Contract: AddressSetLib
==================================================

Function: contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: set.elements.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: index = set.indices[candidate]

  ID: 5
  Type: NodeType.RETURN
  Expression: index != 0 || set.elements[0] == candidate

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5

Function: getPage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: endIndex = index + pageSize

  ID: 2
  Type: NodeType.IF
  Expression: endIndex > set.elements.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: endIndex = set.elements.length

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: endIndex <= index

  ID: 6
  Type: NodeType.RETURN
  Expression: new address[](0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: n = endIndex - index

  ID: 9
  Type: NodeType.VARIABLE
  Expression: page = new address[](n)

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < n

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: page[i] = set.elements[i + index]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.RETURN
  Expression: page

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 16
  12 -> 10
  13 -> 14
  13 -> 11
  14 -> 15
  15 -> 13

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! contains(set,element)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: set.indices[element] = set.elements.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: set.elements.push(element)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(contains(set,element),Element not in set.)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: index = set.indices[element]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: lastIndex = set.elements.length - 1

  ID: 4
  Type: NodeType.IF
  Expression: index != lastIndex

  ID: 5
  Type: NodeType.VARIABLE
  Expression: shiftedElement = set.elements[lastIndex]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: set.elements[index] = shiftedElement

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: set.indices[shiftedElement] = index

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: set.elements.pop()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: delete set.indices[element]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10


Contract: Bytes32SetLib
==================================================

Function: contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: set.elements.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: index = set.indices[candidate]

  ID: 5
  Type: NodeType.RETURN
  Expression: index != 0 || set.elements[0] == candidate

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5

Function: getPage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: endIndex = index + pageSize

  ID: 2
  Type: NodeType.IF
  Expression: endIndex > set.elements.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: endIndex = set.elements.length

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: endIndex <= index

  ID: 6
  Type: NodeType.RETURN
  Expression: new bytes32[](0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: n = endIndex - index

  ID: 9
  Type: NodeType.VARIABLE
  Expression: page = new bytes32[](n)

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < n

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: page[i] = set.elements[i + index]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.RETURN
  Expression: page

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 16
  12 -> 10
  13 -> 14
  13 -> 11
  14 -> 15
  15 -> 13

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! contains(set,element)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: set.indices[element] = set.elements.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: set.elements.push(element)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4

Function: remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(contains(set,element),Element not in set.)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: index = set.indices[element]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: lastIndex = set.elements.length - 1

  ID: 4
  Type: NodeType.IF
  Expression: index != lastIndex

  ID: 5
  Type: NodeType.VARIABLE
  Expression: shiftedElement = set.elements[lastIndex]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: set.elements[index] = shiftedElement

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: set.indices[shiftedElement] = index

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: set.elements.pop()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: delete set.indices[element]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10


Contract: State
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != address(0),Owner must be set)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: associatedContract = _associatedContract

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AssociatedContractUpdated(_associatedContract)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: setAssociatedContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: associatedContract = _associatedContract

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AssociatedContractUpdated(_associatedContract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1


Contract: CollateralManagerState
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: borrowRates.push(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: borrowRatesLastUpdated = block.timestamp

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: State(_associatedContract)

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: setAssociatedContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: associatedContract = _associatedContract

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: AssociatedContractUpdated(_associatedContract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: incrementTotalLoans
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalLoans = totalLoans.add(1)

  ID: 2
  Type: NodeType.RETURN
  Expression: totalLoans

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: long
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: totalIssuedSynths[synth].long

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: short
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: totalIssuedSynths[synth].short

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: incrementLongs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.add(amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: decrementLongs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalIssuedSynths[synth].long = totalIssuedSynths[synth].long.sub(amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: incrementShorts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.add(amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: decrementShorts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalIssuedSynths[synth].short = totalIssuedSynths[synth].short.sub(amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: getRateAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: borrowRates[index]

Edges:
  0 -> 1

Function: getRatesLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: borrowRates.length

Edges:
  0 -> 1

Function: updateBorrowRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: borrowRates.push(rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: borrowRatesLastUpdated = block.timestamp

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: ratesLastUpdated
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: borrowRatesLastUpdated

Edges:
  0 -> 1

Function: getRatesAndTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: newIndex = getRatesLength()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: entryRate = getRateAt(index)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: lastRate = getRateAt(newIndex - 1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: lastUpdated = ratesLastUpdated()

  ID: 5
  Type: NodeType.RETURN
  Expression: (entryRate,lastRate,lastUpdated,newIndex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: addShortCurrency
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: shortRates[currency].length > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: shortRates[currency].push(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: shortRatesLastUpdated[currency] = block.timestamp

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 5
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 4
  5 -> 1

Function: removeShortCurrency
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete shortRates[currency]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 2
  2 -> 1

Function: getShortRateAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: shortRates[currency][index]

Edges:
  0 -> 1

Function: getShortRatesLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: shortRates[currency].length

Edges:
  0 -> 1

Function: updateShortRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: shortRates[currency].push(rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: shortRatesLastUpdated[currency] = block.timestamp

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAssociatedContract()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: shortRateLastUpdated
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: shortRatesLastUpdated[currency]

Edges:
  0 -> 1

Function: getShortRatesAndTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: newIndex = getShortRatesLength(currency)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: entryRate = getShortRateAt(currency,index)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: lastRate = getShortRateAt(currency,newIndex - 1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: lastUpdated = shortRateLastUpdated(currency)

  ID: 5
  Type: NodeType.RETURN
  Expression: (entryRate,lastRate,lastUpdated,newIndex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5


Contract: CollateralManager
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: state = _state

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: setMaxDebt(_maxDebt)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: setMaxSkewRate(_maxSkewRate)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: setBaseBorrowRate(_baseBorrowRate)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: setBaseShortRate(_baseShortRate)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Owned(_owner)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Pausable()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: MixinResolver(_resolver)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 10
  10 -> 1

Function: combineArrays
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: combination = new bytes32[](first.length + second.length)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < first.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: combination[i] = first[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: j < second.length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: combination[first.length + j] = second[j]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 14
  Type: NodeType.RETURN
  Expression: combination

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11

Function: resolverAddressesRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: staticAddresses = new bytes32[](2)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: staticAddresses[0] = CONTRACT_ISSUER

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: staticAddresses[1] = CONTRACT_EXRATES

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: length = _shortableSynths.elements.length

  ID: 6
  Type: NodeType.IF
  Expression: length > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: shortAddresses = new bytes32[](length)

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: shortAddresses[i] = _shortableSynths.elements[i]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: synthAddresses = combineArrays(shortAddresses,_synths.elements)

  ID: 16
  Type: NodeType.IF
  Expression: synthAddresses.length > 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: addresses = combineArrays(synthAddresses,staticAddresses)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: addresses = staticAddresses

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.RETURN
  Expression: addresses

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 14
  7 -> 10
  8 -> 11
  9 -> 14
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 11
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 19
  18 -> 19
  19 -> 20

Function: rebuildCache
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: destination = resolver.requireAndGetAddress(name,string(abi.encodePacked(Resolver missing target: ,name)))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressCache[name] = destination

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: CacheUpdated(name,destination)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 5

Function: isResolverCached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: requiredAddresses = resolverAddressesRequired()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredAddresses.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: name = requiredAddresses[i]

  ID: 7
  Type: NodeType.IF
  Expression: resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: false

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: requireAndGetAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _foundAddress = addressCache[name]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_foundAddress != address(0),string(abi.encodePacked(Missing address: ,name)))

  ID: 3
  Type: NodeType.RETURN
  Expression: _foundAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _paused == paused

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: paused = _paused

  ID: 5
  Type: NodeType.IF
  Expression: paused

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: lastPauseTime = now

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: PauseChanged(paused)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  9 -> 1

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: isSynthManaged
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: synthsByKey[currencyKey] != bytes32(0)

Edges:
  0 -> 1

Function: _issuer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IIssuer(requireAndGetAddress(CONTRACT_ISSUER))

Edges:
  0 -> 1

Function: _exchangeRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES))

Edges:
  0 -> 1

Function: _synth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ISynth(requireAndGetAddress(synthName))

Edges:
  0 -> 1

Function: hasCollateral
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _collaterals.contains(collateral)

Edges:
  0 -> 1

Function: hasAllCollaterals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < collaterals.length

  ID: 5
  Type: NodeType.IF
  Expression: ! hasCollateral(collaterals[i])

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: long
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: state.long(synth)

  ID: 2
  Type: NodeType.RETURN
  Expression: amount

Edges:
  0 -> 1

Function: short
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: state.short(synth)

  ID: 2
  Type: NodeType.RETURN
  Expression: amount

Edges:
  0 -> 1

Function: totalLong
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: synths = _currencyKeys.elements

  ID: 2
  Type: NodeType.IF
  Expression: synths.length > 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < synths.length

  ID: 7
  Type: NodeType.VARIABLE
  Expression: synth = synths[i]

  ID: 8
  Type: NodeType.IF
  Expression: synth == sUSD

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: susdValue = susdValue.add(state.long(synth))

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: (rate,invalid) = _exchangeRates().rateAndInvalid(synth)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: amount = state.long(synth).multiplyDecimal(rate)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: susdValue = susdValue.add(amount)

  ID: 15
  Type: NodeType.IF
  Expression: invalid

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = true

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: (susdValue,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  2 -> 20
  3 -> 6
  4 -> 20
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 18
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 6
  20 -> 21

Function: totalShort
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: synths = _shortableSynths.elements

  ID: 2
  Type: NodeType.IF
  Expression: synths.length > 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < synths.length

  ID: 7
  Type: NodeType.VARIABLE
  Expression: synth = _synth(synths[i]).currencyKey()

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (rate,invalid) = _exchangeRates().rateAndInvalid(synth)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: amount = state.short(synth).multiplyDecimal(rate)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: susdValue = susdValue.add(amount)

  ID: 13
  Type: NodeType.IF
  Expression: invalid

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: (susdValue,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  2 -> 17
  3 -> 6
  4 -> 17
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 6
  17 -> 18

Function: totalLongAndShort
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currencyKeys = _currencyKeys.elements

  ID: 2
  Type: NodeType.IF
  Expression: currencyKeys.length > 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (rates,invalid) = _exchangeRates().ratesAndInvalidForCurrencies(currencyKeys)

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < rates.length

  ID: 10
  Type: NodeType.VARIABLE
  Expression: longAmount = state.long(currencyKeys[i]).multiplyDecimal(rates[i])

  ID: 11
  Type: NodeType.VARIABLE
  Expression: shortAmount = state.short(currencyKeys[i]).multiplyDecimal(rates[i])

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: susdValue = susdValue.add(longAmount).add(shortAmount)

  ID: 13
  Type: NodeType.IF
  Expression: invalid

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: (susdValue,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 17
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 17
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 9
  17 -> 18

Function: getBorrowRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: snxDebt = _issuer().totalIssuedSynths(sUSD,true)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (nonSnxDebt,ratesInvalid) = totalLong()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: totalDebt = snxDebt.add(nonSnxDebt)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: utilisation = nonSnxDebt.divideDecimal(totalDebt).divideDecimal(SECONDS_IN_A_YEAR)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: scaledUtilisation = utilisation.multiplyDecimal(utilisationMultiplier)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: borrowRate = scaledUtilisation.add(baseBorrowRate)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: anyRateIsInvalid = ratesInvalid

  ID: 10
  Type: NodeType.RETURN
  Expression: (borrowRate,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: getShortRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rateIsInvalid = _exchangeRates().rateIsInvalid(synthKey)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: longSupply = IERC20(address(_synth(shortableSynthsByKey[synthKey]))).totalSupply()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: shortSupply = state.short(synthKey)

  ID: 4
  Type: NodeType.IF
  Expression: longSupply > shortSupply

  ID: 5
  Type: NodeType.RETURN
  Expression: (0,rateIsInvalid)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: skew = shortSupply.sub(longSupply)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: proportionalSkew = skew.divideDecimal(longSupply.add(shortSupply)).divideDecimal(SECONDS_IN_A_YEAR)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: maxSkewLimit = proportionalSkew.multiplyDecimal(maxSkewRate)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: shortRate = maxSkewLimit.add(baseShortRate)

  ID: 11
  Type: NodeType.RETURN
  Expression: (shortRate,rateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: getRatesAndTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (entryRate,lastRate,lastUpdated,newIndex) = state.getRatesAndTime(index)

  ID: 2
  Type: NodeType.RETURN
  Expression: (entryRate,lastRate,lastUpdated,newIndex)

Edges:
  0 -> 1
  1 -> 2

Function: getShortRatesAndTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: (entryRate,lastRate,lastUpdated,newIndex) = state.getShortRatesAndTime(currency,index)

  ID: 2
  Type: NodeType.RETURN
  Expression: (entryRate,lastRate,lastUpdated,newIndex)

Edges:
  0 -> 1
  1 -> 2

Function: exceedsDebtLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: usdAmount = _exchangeRates().effectiveValue(currency,amount,sUSD)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (longAndShortValue,invalid) = totalLongAndShort()

  ID: 5
  Type: NodeType.RETURN
  Expression: (longAndShortValue.add(usdAmount) <= maxDebt,invalid)

  ID: 6
  Type: NodeType.RETURN
  Expression: (canIssue,anyRateIsInvalid)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: setUtilisationMultiplier
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_utilisationMultiplier > 0,Must be greater than 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: utilisationMultiplier = _utilisationMultiplier

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: UtilisationMultiplierUpdated(utilisationMultiplier)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: setMaxDebt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_maxDebt > 0,Must be greater than 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: maxDebt = _maxDebt

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MaxDebtUpdated(maxDebt)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: setMaxSkewRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: maxSkewRate = _maxSkewRate

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: MaxSkewRateUpdated(maxSkewRate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setBaseBorrowRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: baseBorrowRate = _baseBorrowRate

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: BaseBorrowRateUpdated(baseBorrowRate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setBaseShortRate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: baseShortRate = _baseShortRate

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: BaseShortRateUpdated(baseShortRate)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: getNewLoanId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: id = state.incrementTotalLoans()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

  ID: 3
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 2
  1 -> 3
  2 -> 1

Function: addCollaterals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < collaterals.length

  ID: 5
  Type: NodeType.IF
  Expression: ! _collaterals.contains(collaterals[i])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _collaterals.add(collaterals[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: CollateralAdded(collaterals[i])

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 10
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 4
  10 -> 3

Function: removeCollaterals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < collaterals.length

  ID: 5
  Type: NodeType.IF
  Expression: _collaterals.contains(collaterals[i])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _collaterals.remove(collaterals[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: CollateralRemoved(collaterals[i])

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 10
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 4
  10 -> 3

Function: addSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synthNamesInResolver.length == synthKeys.length,Input array length mismatch)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < synthNamesInResolver.length

  ID: 6
  Type: NodeType.IF
  Expression: ! _synths.contains(synthNamesInResolver[i])

  ID: 7
  Type: NodeType.VARIABLE
  Expression: synthName = synthNamesInResolver[i]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _synths.add(synthName)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _currencyKeys.add(synthKeys[i])

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: synthsByKey[synthKeys[i]] = synthName

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: SynthAdded(synthName)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: rebuildCache()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 15
  1 -> 4
  2 -> 5
  3 -> 14
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 12
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 5
  15 -> 1

Function: areSynthsAndCurrenciesSet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _synths.elements.length != requiredSynthNamesInResolver.length

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < requiredSynthNamesInResolver.length

  ID: 8
  Type: NodeType.IF
  Expression: ! _synths.contains(requiredSynthNamesInResolver[i])

  ID: 9
  Type: NodeType.RETURN
  Expression: false

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: synthsByKey[synthKeys[i]] != requiredSynthNamesInResolver[i]

  ID: 12
  Type: NodeType.RETURN
  Expression: false

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 15
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 6
  4 -> 7
  5 -> 15
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  14 -> 7

Function: removeSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(synthNamesInResolver.length == synthKeys.length,Input array length mismatch)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < synthNamesInResolver.length

  ID: 6
  Type: NodeType.IF
  Expression: _synths.contains(synthNamesInResolver[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _synths.remove(synthNamesInResolver[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _currencyKeys.remove(synthKeys[i])

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: delete synthsByKey[synthKeys[i]]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: SynthRemoved(synthNamesInResolver[i])

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 13
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 11
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 5
  13 -> 1

Function: addShortableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(requiredSynthNamesInResolver.length == synthKeys.length,Input array length mismatch)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < requiredSynthNamesInResolver.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: synth = requiredSynthNamesInResolver[i]

  ID: 7
  Type: NodeType.IF
  Expression: ! _shortableSynths.contains(synth)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _shortableSynths.add(synth)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: shortableSynthsByKey[synthKeys[i]] = synth

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ShortableSynthAdded(synth)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: state.addShortCurrency(synthKeys[i])

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: rebuildCache()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 15
  1 -> 4
  2 -> 5
  3 -> 14
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 12
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 5
  15 -> 1

Function: areShortableSynthsSet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(requiredSynthNamesInResolver.length == synthKeys.length,Input array length mismatch)

  ID: 2
  Type: NodeType.IF
  Expression: _shortableSynths.elements.length != requiredSynthNamesInResolver.length

  ID: 3
  Type: NodeType.RETURN
  Expression: false

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < synthKeys.length

  ID: 9
  Type: NodeType.IF
  Expression: state.getShortRatesLength(synthKeys[i]) == 0

  ID: 10
  Type: NodeType.RETURN
  Expression: false

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 7
  5 -> 8
  6 -> 13
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  9 -> 11
  11 -> 12
  12 -> 8

Function: removeShortableSynths
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < synths.length

  ID: 5
  Type: NodeType.IF
  Expression: _shortableSynths.contains(synths[i])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _shortableSynths.remove(synths[i])

  ID: 7
  Type: NodeType.VARIABLE
  Expression: synthKey = _synth(synths[i]).currencyKey()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: delete shortableSynthsByKey[synthKey]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: state.removeShortCurrency(synthKey)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ShortableSynthRemoved(synths[i])

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 13
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 4
  13 -> 3

Function: updateBorrowRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.updateBorrowRates(rate)

Edges:
  0 -> 1

Function: updateShortRates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.updateShortRates(currency,rate)

Edges:
  0 -> 1

Function: updateBorrowRatesCollateral
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.updateBorrowRates(rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: updateShortRatesCollateral
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.updateShortRates(currency,rate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: incrementLongs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.incrementLongs(synth,amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: decrementLongs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.decrementLongs(synth,amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: incrementShorts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.incrementShorts(synth,amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: decrementShorts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: state.decrementShorts(synth,amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

Edges:
  0 -> 2
  2 -> 1

Function: accrueInterest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! invalid,Invalid rate)

  ID: 10
  Type: NodeType.VARIABLE
  Expression: timeDelta = block.timestamp.sub(lastUpdated).mul(1e18)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: latestCumulative = lastRate.add(rate.multiplyDecimal(timeDelta))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: difference = latestCumulative.sub(entryRate)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: index = newIndex

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyCollateral()

  ID: 16
  Type: NodeType.IF
  Expression: isShort

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: (entryRate,lastRate,lastUpdated,newIndex) = getShortRatesAndTime(currency,interestIndex)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: (entryRate,lastRate,lastUpdated,newIndex) = getRatesAndTime(interestIndex)

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.IF
  Expression: isShort

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: (rate,invalid) = getShortRate(currency)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: (rate,invalid) = getBorrowRate()

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: isShort

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: updateShortRates(currency,latestCumulative)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: updateBorrowRates(latestCumulative)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.RETURN
  Expression: (difference,index)

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 16
  6 -> 7
  7 -> 20
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 24
  15 -> 1
  16 -> 17
  16 -> 18
  17 -> 19
  18 -> 19
  19 -> 6
  20 -> 21
  20 -> 22
  21 -> 23
  22 -> 23
  23 -> 9
  24 -> 25
  24 -> 26
  25 -> 27
  26 -> 27
  27 -> 28

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: utilisationMultiplier = 1e18

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: addressesToCache = (CONTRACT_ISSUER,CONTRACT_EXRATES)

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: sUSD = sUSD

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SECONDS_IN_A_YEAR = 31556926 * 1e18

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_NAME = CollateralManager

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: COLLATERAL_SYNTHS = collateralSynth

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_ISSUER = Issuer

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: CONTRACT_EXRATES = ExchangeRates

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5


Contract: ISynthetixNamedContract
==================================================


Contract: Migration_Han
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: BaseMigration(OWNER)

Edges:
  0 -> 1

Function: returnOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: payload = abi.encodeWithSignature(nominateNewOwner(address),owner)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = forContract.call(payload)

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.VARIABLE
  Expression: legacyPayload = abi.encodeWithSignature(nominateOwner(address),owner)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (legacySuccess,None) = forContract.call(legacyPayload)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(legacySuccess,Legacy nomination failed)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: nominateNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerNominated(_owner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: acceptOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == nominatedOwner,You must be nominated before you can accept ownership)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(owner,nominatedOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = nominatedOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nominatedOwner = address(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _onlyOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == owner,Only the contract owner may perform this action)

Edges:
  0 -> 1

Function: contractsRequiringOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: contracts = new address[](3)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: contracts[0] = address(addressresolver_i)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: contracts[1] = address(systemstatus_i)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: contracts[2] = address(issuer_i)

  ID: 5
  Type: NodeType.RETURN
  Expression: contracts

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: migrate
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: acceptAll()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: addressresolver_importAddresses_0()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_1()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_2()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: systemstatus_i.updateAccessControl(Issuance,new_Issuer_contract,true,false)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_5()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: nominateAll()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: acceptAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: contracts = contractsRequiringOwnership()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < contracts.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Owned(contracts[i]).acceptOwnership()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: nominateAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: contracts = contractsRequiringOwnership()

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < contracts.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: returnOwnership(contracts[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: addressresolver_importAddresses_0
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: addressresolver_importAddresses_names_0_0 = new bytes32[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: addressresolver_importAddresses_names_0_0[0] = bytes32(Issuer)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: addressresolver_importAddresses_destinations_0_1 = new address[](1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: addressresolver_importAddresses_destinations_0_1[0] = address(new_Issuer_contract)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: addressresolver_i.importAddresses(addressresolver_importAddresses_names_0_0,addressresolver_importAddresses_destinations_0_1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: addressresolver_rebuildCaches_1
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xc5f0b4194455e0C175ab68C501400e46C7203504)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xFAd53Cc9480634563E8ec71E8e693Ffd07981d38)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0x89FCb32F29e509cc42d0C8b6f058C993013A843F)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0x8e9757479D5ad4E7f9d951B60d39F5220b893d6c)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xf79603a71144e415730C1A6f57F366E4Ea962C00)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x83105D7CDd2fd9b8185BFF1cb56bB1595a618618)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0xd1cad1A569E70d2Df4C8ed43d3cC93DBE16285dE)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0xaeA0065E146FD75Dc24465961a583827284D405a)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0x9f231dBE53D460f359B2B8CC47574493caA5B7Bf)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0xeAcaEd9581294b1b5cfb6B941d4B8B81B2005437)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0x94f864e55c77E07C2C7BF7bFBc334b7a8123442A)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(0x38c8A4d93757D3D2E0110Cfb5f18B9cC293e0fdA)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0x10A5F7D9D65bCc2734763444D4940a31b109275f)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: addressresolver_rebuildCaches_2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](7)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0xdAe6C79c46aB3B280Ca28259000695529cbD1339)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(new_Issuer_contract)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0x7A3d898b717e50a96fd8b232E9d15F0A547A7eeb)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: issuer_addSynths_5
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: issuer_addSynths_synthsToAdd_5_0 = new ISynth[](10)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[0] = ISynth(0x10A5F7D9D65bCc2734763444D4940a31b109275f)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[1] = ISynth(0xa8E31E3C38aDD6052A9407298FAEB8fD393A6cF9)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[2] = ISynth(0xE1cc2332852B2Ac0dA59A1f9D3051829f4eF3c1C)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[3] = ISynth(0xfb020CA7f4e8C4a5bBBe060f59a249c6275d2b69)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[4] = ISynth(0xdc883b9d9Ee16f74bE08826E68dF4C9D9d26e8bD)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[5] = ISynth(0xBb5b03E920cF702De5A3bA9Fc1445aF4B3919c88)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[6] = ISynth(0xdAe6C79c46aB3B280Ca28259000695529cbD1339)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[7] = ISynth(0x1cB004a8e84a5CE95C1fF895EE603BaC8EC506c7)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[8] = ISynth(0x5D4C724BFe3a228Ff0E29125Ac1571FE093700a4)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: issuer_addSynths_synthsToAdd_5_0[9] = ISynth(0x07C1E81C345A7c58d7c24072EFc5D929BD0647AD)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: issuer_i.addSynths(issuer_addSynths_synthsToAdd_5_0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83)

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: systemstatus_i = SystemStatus(0x696c905F8F8c006cA46e9808fE7e00049507798F)

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: issuer_i = Issuer(0x7A1b3DB73E5B8c58EDC8A821890005064f2B83Fd)

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: new_Issuer_contract = 0x7A1b3DB73E5B8c58EDC8A821890005064f2B83Fd

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


