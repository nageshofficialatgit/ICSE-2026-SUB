Contract: IERC1967Upgradeable
==================================================


Contract: IERC1822ProxiableUpgradeable
==================================================


Contract: IBeaconUpgradeable
==================================================


Contract: AddressUpgradeable
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: account.code.length > 0

Edges:
  0 -> 1

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: returndata

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 7

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: StorageSlotUpgradeable
==================================================

Function: getAddressSlot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = slot

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getBooleanSlot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = slot

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getBytes32Slot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = slot

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getUint256Slot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = slot

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getStringSlot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = store

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getBytesSlot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: r = store

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: MerkleProofUpgradeable
==================================================

Function: verify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProof(proof,leaf) == root

Edges:
  0 -> 1

Function: verifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProofCalldata(proof,leaf) == root

Edges:
  0 -> 1

Function: processProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = _hashPair(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: processProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = _hashPair(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: multiProofVerify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProof(proof,proofFlags,leaves) == root

Edges:
  0 -> 1

Function: multiProofVerifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProofCalldata(proof,proofFlags,leaves) == root

Edges:
  0 -> 1

Function: processMultiProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofLen = proof.length

  ID: 3
  Type: NodeType.VARIABLE
  Expression: totalHashes = proofFlags.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(leavesLen + proofLen - 1 == totalHashes,MerkleProof: invalid multiproof)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](totalHashes)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 12
  Type: NodeType.IFLOOP
  Expression: i < totalHashes

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = _hashPair(a,b)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 17
  Type: NodeType.IF
  Expression: totalHashes > 0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(proofPos == proofLen,MerkleProof: invalid multiproof)

  ID: 19
  Type: NodeType.RETURN
  Expression: hashes[totalHashes - 1]

  ID: 20
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 21
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 22
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 25
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 11
  9 -> 12
  10 -> 17
  11 -> 9
  12 -> 25
  12 -> 10
  15 -> 16
  16 -> 12
  17 -> 18
  17 -> 20
  18 -> 19
  20 -> 21
  20 -> 22
  25 -> 26
  25 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 33
  29 -> 31
  31 -> 32
  32 -> 15
  33 -> 34
  33 -> 35
  34 -> 36
  35 -> 36
  36 -> 32

Function: processMultiProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofLen = proof.length

  ID: 3
  Type: NodeType.VARIABLE
  Expression: totalHashes = proofFlags.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(leavesLen + proofLen - 1 == totalHashes,MerkleProof: invalid multiproof)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](totalHashes)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 12
  Type: NodeType.IFLOOP
  Expression: i < totalHashes

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = _hashPair(a,b)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 17
  Type: NodeType.IF
  Expression: totalHashes > 0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(proofPos == proofLen,MerkleProof: invalid multiproof)

  ID: 19
  Type: NodeType.RETURN
  Expression: hashes[totalHashes - 1]

  ID: 20
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 21
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 22
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 25
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 11
  9 -> 12
  10 -> 17
  11 -> 9
  12 -> 25
  12 -> 10
  15 -> 16
  16 -> 12
  17 -> 18
  17 -> 20
  18 -> 19
  20 -> 21
  20 -> 22
  25 -> 26
  25 -> 27
  26 -> 28
  27 -> 28
  28 -> 29
  29 -> 33
  29 -> 31
  31 -> 32
  32 -> 15
  33 -> 34
  33 -> 35
  34 -> 36
  35 -> 36
  36 -> 32

Function: _hashPair
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: _efficientHash(a,b)

  ID: 4
  Type: NodeType.RETURN
  Expression: _efficientHash(b,a)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: _efficientHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,a)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,b)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = keccak256(uint256,uint256)(0x00,0x40)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: IERC165Upgradeable
==================================================


Contract: IMaterials
==================================================


Contract: IMutantHounds
==================================================


Contract: IOperatorFilterRegistry
==================================================


Contract: IERC2981Upgradeable
==================================================


Contract: Initializable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1


Contract: IERC1155ReceiverUpgradeable
==================================================


Contract: IERC1155Upgradeable
==================================================


Contract: IERC1155MetadataURIUpgradeable
==================================================


Contract: ContextUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1


Contract: OwnableUpgradeable
==================================================

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: PausableUpgradeable
==================================================

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1


Contract: ERC165Upgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC165Upgradeable).interfaceId

Edges:
  0 -> 1


Contract: OperatorFiltererUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __OperatorFilterer_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(registry_).code.length > 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(registry_)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 6
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: toggleOperatorFilterDisabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: disabled = ! operatorFilterDisabled

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = disabled

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OperatorFilterDisabled(disabled)

  ID: 4
  Type: NodeType.RETURN
  Expression: disabled

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateOperatorFilterRegistry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(newRegistry)

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: ! registry.isRegistered(address(this))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  9 -> 1

Function: updateRegistrySubscription
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = operatorFilterRegistry

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: registry.unsubscribe(address(this),copyEntries)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 8
  7 -> 8
  9 -> 1

Function: _registerAndSubscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registry.isRegistered(address(this))

  ID: 2
  Type: NodeType.IF
  Expression: subscribe

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: registry.subscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: registry.copyEntriesOf(address(this),subscriptionOrRegistrantToCopy)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: subscribe

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndSubscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 8
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy != address(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndCopyEntries(address(this),subscriptionOrRegistrantToCopy)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: registry.register(address(this))

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 13
  6 -> 7
  6 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13


Contract: ERC2981Upgradeable
==================================================

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ERC2981_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC2981_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: royalty = _tokenRoyaltyInfo[tokenId]

  ID: 2
  Type: NodeType.IF
  Expression: royalty.receiver == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: royalty = _defaultRoyaltyInfo

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator()

  ID: 6
  Type: NodeType.RETURN
  Expression: (royalty.receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: invalid receiver)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyaltyInfo = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyaltyInfo

Edges:
  0 -> 1

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: Invalid parameters)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _tokenRoyaltyInfo[tokenId]

Edges:
  0 -> 1


Contract: ERC1967UpgradeUpgradeable
==================================================

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ERC1967Upgrade_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC1967Upgrade_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _getImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value

Edges:
  0 -> 1

Function: _setImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newImplementation),ERC1967: new implementation is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Upgraded(newImplementation)

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _upgradeTo(newImplementation)

  ID: 2
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(newImplementation,data)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4

Function: _upgradeToAndCallUUPS
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 3
  Type: NodeType.TRY
  Expression: slot = IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID()

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)

  ID: 6
  Type: NodeType.CATCH
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCall(newImplementation,data,forceCall)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 9
  3 -> 4
  3 -> 6
  3 -> 8
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9

Function: _getAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value

Edges:
  0 -> 1

Function: _setAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin

Edges:
  0 -> 1
  1 -> 2

Function: _changeAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: AdminChanged(_getAdmin(),newAdmin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setAdmin(newAdmin)

Edges:
  0 -> 1
  1 -> 2

Function: _getBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value

Edges:
  0 -> 1

Function: _setBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newBeacon),ERC1967: new beacon is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _upgradeBeaconToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setBeacon(newBeacon)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: BeaconUpgraded(newBeacon)

  ID: 3
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(),data)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: UUPSUpgradeable
==================================================

Function: __ERC1967Upgrade_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC1967Upgrade_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _getImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value

Edges:
  0 -> 1

Function: _setImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newImplementation),ERC1967: new implementation is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Upgraded(newImplementation)

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _upgradeTo(newImplementation)

  ID: 2
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(newImplementation,data)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4

Function: _upgradeToAndCallUUPS
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 3
  Type: NodeType.TRY
  Expression: slot = IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID()

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)

  ID: 6
  Type: NodeType.CATCH
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCall(newImplementation,data,forceCall)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 9
  3 -> 4
  3 -> 6
  3 -> 8
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9

Function: _getAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value

Edges:
  0 -> 1

Function: _setAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin

Edges:
  0 -> 1
  1 -> 2

Function: _changeAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: AdminChanged(_getAdmin(),newAdmin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setAdmin(newAdmin)

Edges:
  0 -> 1
  1 -> 2

Function: _getBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value

Edges:
  0 -> 1

Function: _setBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newBeacon),ERC1967: new beacon is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _upgradeBeaconToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setBeacon(newBeacon)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: BeaconUpgraded(newBeacon)

  ID: 3
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(),data)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __UUPSUpgradeable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __UUPSUpgradeable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: proxiableUUID
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _IMPLEMENTATION_SLOT

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: notDelegated()

Edges:
  0 -> 2
  2 -> 1

Function: upgradeTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _authorizeUpgrade(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCallUUPS(newImplementation,new bytes(0),false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyProxy()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: upgradeToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _authorizeUpgrade(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCallUUPS(newImplementation,data,true)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyProxy()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: __self = address(this)

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50

Edges:
  0 -> 1
  1 -> 2


Contract: ERC1155xyzUpgradeable
==================================================

Function: __OperatorFilterer_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(registry_).code.length > 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(registry_)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 6
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: toggleOperatorFilterDisabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: disabled = ! operatorFilterDisabled

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = disabled

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OperatorFilterDisabled(disabled)

  ID: 4
  Type: NodeType.RETURN
  Expression: disabled

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateOperatorFilterRegistry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(newRegistry)

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: ! registry.isRegistered(address(this))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  9 -> 1

Function: updateRegistrySubscription
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = operatorFilterRegistry

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: registry.unsubscribe(address(this),copyEntries)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 8
  7 -> 8
  9 -> 1

Function: _registerAndSubscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registry.isRegistered(address(this))

  ID: 2
  Type: NodeType.IF
  Expression: subscribe

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: registry.subscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: registry.copyEntriesOf(address(this),subscriptionOrRegistrantToCopy)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: subscribe

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndSubscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 8
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy != address(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndCopyEntries(address(this),subscriptionOrRegistrantToCopy)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: registry.register(address(this))

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 13
  6 -> 7
  6 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __ERC2981_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC2981_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC1155Upgradeable).interfaceId || interfaceId == type()(IERC1155MetadataURIUpgradeable).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: royalty = _tokenRoyaltyInfo[tokenId]

  ID: 2
  Type: NodeType.IF
  Expression: royalty.receiver == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: royalty = _defaultRoyaltyInfo

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator()

  ID: 6
  Type: NodeType.RETURN
  Expression: (royalty.receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: invalid receiver)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyaltyInfo = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyaltyInfo

Edges:
  0 -> 1

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: Invalid parameters)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _tokenRoyaltyInfo[tokenId]

Edges:
  0 -> 1

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __ERC1155_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ERC1155_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ERC1155_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC1155: address zero is not a valid owner)

  ID: 2
  Type: NodeType.RETURN
  Expression: _tokenOwnerBalance[id][account]

Edges:
  0 -> 1
  1 -> 2

Function: balanceOfBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(accounts.length == ids.length,ERC1155: accounts and ids length mismatch)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: batchBalances = new uint256[](accounts.length)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < accounts.length

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: batchBalances[i] = balanceOf(accounts[i],ids[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 9
  Type: NodeType.RETURN
  Expression: batchBalances

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setApprovalForAll(_msgSender(),operator,approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperatorApproval(operator)

Edges:
  0 -> 2
  2 -> 1

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[account][operator]

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from == _msgSender() || isApprovedForAll(from,_msgSender()),ERC1155: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeTransferFrom(from,to,id,amount,data)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperator(from)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from == _msgSender() || isApprovedForAll(from,_msgSender()),ERC1155: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeBatchTransferFrom(from,to,ids,amounts,data)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperator(from)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: transfer to the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: insufficient balance for transfer)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,from,to,id,amount)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: _safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: transfer to the zero address)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: insufficient balance for transfer)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,from,to,ids,amounts)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _doSafeBatchTransferAcceptanceCheck(operator,from,to,ids,amounts,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 16
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 8
  16 -> 17
  17 -> 18

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: mint to the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] += amount

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,address(0),to,id,amount)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _doSafeTransferAcceptanceCheck(operator,address(0),to,id,amount,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mintBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] += amount

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,address(0),to,ids,amounts)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _doSafeBatchTransferAcceptanceCheck(operator,address(0),to,ids,amounts,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 8
  14 -> 15
  15 -> 16

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC1155: burn from the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,address(0),ids,amounts,)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: burn amount exceeds balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] -= amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,from,address(0),id,amount)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,address(0),ids,amounts,)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: _burnBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC1155: burn from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,address(0),ids,amounts,)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: burn amount exceeds balance)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] -= amount

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,from,address(0),ids,amounts)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,address(0),ids,amounts,)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 16
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 8
  16 -> 17

Function: _setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != operator,ERC1155: setting approval status for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[owner][operator] = approved

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(owner,operator,approved)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _beforeTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _doSafeTransferAcceptanceCheck
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: response = IERC1155ReceiverUpgradeable(to).onERC1155Received(operator,from,id,amount,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: response != IERC1155ReceiverUpgradeable.onERC1155Received.selector

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: ERC1155Receiver rejected tokens)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(string)(reason)

  ID: 9
  Type: NodeType.CATCH
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: transfer to non-ERC1155Receiver implementer)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 11
  2 -> 3
  2 -> 7
  2 -> 9
  2 -> 11
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 11
  7 -> 8
  8 -> 11
  9 -> 10
  10 -> 11

Function: _doSafeBatchTransferAcceptanceCheck
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: response = IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator,from,ids,amounts,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: ERC1155Receiver rejected tokens)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(string)(reason)

  ID: 9
  Type: NodeType.CATCH
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: transfer to non-ERC1155Receiver implementer)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 11
  2 -> 3
  2 -> 7
  2 -> 9
  2 -> 11
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 11
  7 -> 8
  8 -> 11
  9 -> 10
  10 -> 11

Function: _asSingletonArray
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: array = new uint256[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: array[0] = element

  ID: 3
  Type: NodeType.RETURN
  Expression: array

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: tokenSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokenBalance[tokenId]

Edges:
  0 -> 1


Contract: Materials
==================================================

Function: __UUPSUpgradeable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __UUPSUpgradeable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: proxiableUUID
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _IMPLEMENTATION_SLOT

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: notDelegated()

Edges:
  0 -> 2
  2 -> 1

Function: upgradeTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _authorizeUpgrade(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCallUUPS(newImplementation,new bytes(0),false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyProxy()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: upgradeToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _authorizeUpgrade(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCallUUPS(newImplementation,data,true)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyProxy()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: __ERC1967Upgrade_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC1967Upgrade_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _getImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value

Edges:
  0 -> 1

Function: _setImplementation
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newImplementation),ERC1967: new implementation is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeTo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Upgraded(newImplementation)

Edges:
  0 -> 1
  1 -> 2

Function: _upgradeToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _upgradeTo(newImplementation)

  ID: 2
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(newImplementation,data)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4

Function: _upgradeToAndCallUUPS
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setImplementation(newImplementation)

  ID: 3
  Type: NodeType.TRY
  Expression: slot = IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID()

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)

  ID: 6
  Type: NodeType.CATCH
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _upgradeToAndCall(newImplementation,data,forceCall)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 9
  3 -> 4
  3 -> 6
  3 -> 8
  4 -> 5
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9

Function: _getAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value

Edges:
  0 -> 1

Function: _setAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin

Edges:
  0 -> 1
  1 -> 2

Function: _changeAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: AdminChanged(_getAdmin(),newAdmin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setAdmin(newAdmin)

Edges:
  0 -> 1
  1 -> 2

Function: _getBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value

Edges:
  0 -> 1

Function: _setBeacon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(newBeacon),ERC1967: new beacon is not a contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _upgradeBeaconToAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setBeacon(newBeacon)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: BeaconUpgraded(newBeacon)

  ID: 3
  Type: NodeType.IF
  Expression: data.length > 0 || forceCall

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(),data)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5

Function: _disableInitializers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)

  ID: 2
  Type: NodeType.IF
  Expression: _initialized != type()(uint8).max

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _initialized = type()(uint8).max

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Initialized(type()(uint8).max)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: _getInitializedVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initialized

Edges:
  0 -> 1

Function: _isInitializing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _initializing

Edges:
  0 -> 1

Function: __Ownable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Ownable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: __Context_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __Context_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: __Pausable_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __Pausable_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: paused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _paused

Edges:
  0 -> 1

Function: _requireNotPaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! paused(),Pausable: paused)

Edges:
  0 -> 1

Function: _requirePaused
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(paused(),Pausable: not paused)

Edges:
  0 -> 1

Function: _pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Paused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpaused(_msgSender())

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: __ERC1155_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ERC1155_init_unchained()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 2
  2 -> 1

Function: __ERC1155_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == type()(IERC1155Upgradeable).interfaceId || super.supportsInterface(interfaceId)

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(account != address(0),ERC1155: address zero is not a valid owner)

  ID: 2
  Type: NodeType.RETURN
  Expression: _tokenOwnerBalance[id][account]

Edges:
  0 -> 1
  1 -> 2

Function: balanceOfBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(accounts.length == ids.length,ERC1155: accounts and ids length mismatch)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: batchBalances = new uint256[](accounts.length)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < accounts.length

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: batchBalances[i] = balanceOf(accounts[i],ids[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 9
  Type: NodeType.RETURN
  Expression: batchBalances

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setApprovalForAll(_msgSender(),operator,approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperatorApproval(operator)

Edges:
  0 -> 2
  2 -> 1

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[account][operator]

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from == _msgSender() || isApprovedForAll(from,_msgSender()),ERC1155: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeTransferFrom(from,to,id,amount,data)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperator(from)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from == _msgSender() || isApprovedForAll(from,_msgSender()),ERC1155: caller is not token owner or approved)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _safeBatchTransferFrom(from,to,ids,amounts,data)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedOperator(from)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: transfer to the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: insufficient balance for transfer)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,from,to,id,amount)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _doSafeTransferAcceptanceCheck(operator,from,to,id,amount,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: _safeBatchTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: transfer to the zero address)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: insufficient balance for transfer)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,from,to,ids,amounts)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,to,ids,amounts,data)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _doSafeBatchTransferAcceptanceCheck(operator,from,to,ids,amounts,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 16
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 8
  16 -> 17
  17 -> 18

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: mint to the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] += amount

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,address(0),to,id,amount)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _doSafeTransferAcceptanceCheck(operator,address(0),to,id,amount,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mintBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC1155: mint to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][to] += amount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] += amount

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,address(0),to,ids,amounts)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,address(0),to,ids,amounts,data)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _doSafeBatchTransferAcceptanceCheck(operator,address(0),to,ids,amounts,data)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 14
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 8
  14 -> 15
  15 -> 16

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC1155: burn from the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: ids = _asSingletonArray(id)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amounts = _asSingletonArray(amount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,address(0),ids,amounts,)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: burn amount exceeds balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] -= amount

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: TransferSingle(operator,from,address(0),id,amount)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,address(0),ids,amounts,)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: _burnBatch
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC1155: burn from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(ids.length == amounts.length,ERC1155: ids and amounts length mismatch)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: operator = _msgSender()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfer(operator,from,address(0),ids,amounts,)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < ids.length

  ID: 9
  Type: NodeType.VARIABLE
  Expression: id = ids[i]

  ID: 10
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i]

  ID: 11
  Type: NodeType.VARIABLE
  Expression: fromBalance = _tokenOwnerBalance[id][from]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(fromBalance >= amount,ERC1155: burn amount exceeds balance)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _tokenOwnerBalance[id][from] = fromBalance - amount

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _tokenBalance[id] -= amount

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: TransferBatch(operator,from,address(0),ids,amounts)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfer(operator,from,address(0),ids,amounts,)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 16
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 8
  16 -> 17

Function: _setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner != operator,ERC1155: setting approval status for self)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[owner][operator] = approved

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(owner,operator,approved)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _beforeTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _doSafeTransferAcceptanceCheck
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: response = IERC1155ReceiverUpgradeable(to).onERC1155Received(operator,from,id,amount,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: response != IERC1155ReceiverUpgradeable.onERC1155Received.selector

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: ERC1155Receiver rejected tokens)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(string)(reason)

  ID: 9
  Type: NodeType.CATCH
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: transfer to non-ERC1155Receiver implementer)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 11
  2 -> 3
  2 -> 7
  2 -> 9
  2 -> 11
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 11
  7 -> 8
  8 -> 11
  9 -> 10
  10 -> 11

Function: _doSafeBatchTransferAcceptanceCheck
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.isContract()

  ID: 2
  Type: NodeType.TRY
  Expression: response = IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator,from,ids,amounts,data)

  ID: 3
  Type: NodeType.CATCH
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: ERC1155Receiver rejected tokens)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(string)(reason)

  ID: 9
  Type: NodeType.CATCH
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(ERC1155: transfer to non-ERC1155Receiver implementer)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 11
  2 -> 3
  2 -> 7
  2 -> 9
  2 -> 11
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 11
  7 -> 8
  8 -> 11
  9 -> 10
  10 -> 11

Function: _asSingletonArray
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: array = new uint256[](1)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: array[0] = element

  ID: 3
  Type: NodeType.RETURN
  Expression: array

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: tokenSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokenBalance[tokenId]

Edges:
  0 -> 1

Function: __OperatorFilterer_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: address(registry_).code.length > 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(registry_)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 6
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: toggleOperatorFilterDisabled
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: disabled = ! operatorFilterDisabled

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: operatorFilterDisabled = disabled

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OperatorFilterDisabled(disabled)

  ID: 4
  Type: NodeType.RETURN
  Expression: disabled

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateOperatorFilterRegistry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = IOperatorFilterRegistry(newRegistry)

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: ! registry.isRegistered(address(this))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: operatorFilterRegistry = registry

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  9 -> 1

Function: updateRegistrySubscription
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: registry = operatorFilterRegistry

  ID: 2
  Type: NodeType.IF
  Expression: address(registry).code.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert RegistryInvalid()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy == address(0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: registry.unsubscribe(address(this),copyEntries)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _registerAndSubscribe(registry,subscriptionOrRegistrantToCopy,subscribe)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOperatorFilterAdmin()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 8
  7 -> 8
  9 -> 1

Function: _registerAndSubscribe
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: registry.isRegistered(address(this))

  ID: 2
  Type: NodeType.IF
  Expression: subscribe

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: registry.subscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: registry.copyEntriesOf(address(this),subscriptionOrRegistrantToCopy)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: subscribe

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndSubscribe(address(this),subscriptionOrRegistrantToCopy)

  ID: 8
  Type: NodeType.IF
  Expression: subscriptionOrRegistrantToCopy != address(0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: registry.registerAndCopyEntries(address(this),subscriptionOrRegistrantToCopy)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: registry.register(address(this))

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 13
  6 -> 7
  6 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13

Function: __ERC2981_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC2981_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: royaltyInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: royalty = _tokenRoyaltyInfo[tokenId]

  ID: 2
  Type: NodeType.IF
  Expression: royalty.receiver == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: royalty = _defaultRoyaltyInfo

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator()

  ID: 6
  Type: NodeType.RETURN
  Expression: (royalty.receiver,royaltyAmount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6

Function: _feeDenominator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 10000

Edges:
  0 -> 1

Function: _setDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: invalid receiver)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _defaultRoyaltyInfo = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _deleteDefaultRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _defaultRoyaltyInfo

Edges:
  0 -> 1

Function: _setTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeNumerator <= _feeDenominator(),ERC2981: royalty fee will exceed salePrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(receiver != address(0),ERC2981: Invalid parameters)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver,feeNumerator)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _resetTokenRoyalty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: delete _tokenRoyaltyInfo[tokenId]

Edges:
  0 -> 1

Function: __ERC165_init
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: __ERC165_init_unchained
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyInitializing()

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _disableInitializers()

Edges:
  0 -> 1

Function: _authorizeUpgrade
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 1

Function: _isOperatorFilterAdmin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! (owner() == operator)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NotOwner()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __ERC1155_init()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: __Pausable_init()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: __OperatorFilterer_init(DEFAULT_OPERATOR_FILTER_REGISTRY,DEFAULT_OPERATOR_FILTER_SUBSCRIPTION,true)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: __Ownable_init()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(royaltyReceiver,royaltyPercentage)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: name = name_

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: symbol = symbol_

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: initializer()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: burn2Redeem
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: stage = saleStages[saleId]

  ID: 2
  Type: NodeType.IF
  Expression: stage.startTime == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStageTime()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: stage.merkleRoot != bytes32(0)

  ID: 6
  Type: NodeType.IF
  Expression: ! _verifyMerkleAddress(_merkleProof,stage.merkleRoot,msg.sender,saleId)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert IncorrectProof()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: stage.startTime >= block.timestamp

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStageTime()()

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: length = tokenIds.length

  ID: 14
  Type: NodeType.IF
  Expression: length <= 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert NoTokenIdsSpecified()()

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: IMutantHounds(houndsContractAddress).materialsBurn(tokenIds,msg.sender)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: roundsClaimed = length / 4

  ID: 19
  Type: NodeType.VARIABLE
  Expression: roundsModulus = length % 4

  ID: 20
  Type: NodeType.VARIABLE
  Expression: materialsCycle_ = materialsCycle

  ID: 21
  Type: NodeType.VARIABLE
  Expression: i = materialsCycle_

  ID: 22
  Type: NodeType.IF
  Expression: roundsClaimed > 0

  ID: 23
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 24
  Type: NodeType.IFLOOP
  Expression: i < materialsCycle_ + 4

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _mint(msg.sender,i % 4 + 1,roundsClaimed,)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.VARIABLE
  Expression: additionalRounds = i + roundsModulus

  ID: 30
  Type: NodeType.IF
  Expression: roundsModulus > 0

  ID: 31
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 32
  Type: NodeType.IFLOOP
  Expression: i < additionalRounds

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: _mint(msg.sender,i % 4 + 1,1,)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 35
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: materialsCycle = (materialsCycle_ + length) % 4

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 38
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  22 -> 28
  23 -> 25
  24 -> 25
  24 -> 27
  25 -> 26
  26 -> 24
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  30 -> 36
  31 -> 33
  32 -> 33
  32 -> 35
  33 -> 34
  34 -> 32
  35 -> 36
  36 -> 37
  38 -> 1

Function: setFusedMinter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newFusedMinter == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidFusedMinter()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: fusedMinter = newFusedMinter

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: burnMaterials
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: amountsPerType.length != 6

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ArraysLengthMismatch()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: msg.sender != fusedMinter

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert NotFusedMinter()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < amountsPerType.length

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _burn(owner,i,amountsPerType[i])

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 9
  7 -> 10
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 10

Function: changeSecondaryRoyaltyReceiver
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _setDefaultRoyalty(newSecondaryRoyaltyReceiver,newRoyaltyValue)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: NewSecondaryRoyalties(newSecondaryRoyaltyReceiver,newRoyaltyValue)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _pause()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: setSaleStage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: saleStages[id] = stage

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: setUri
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: uriMapping[id] = newURI

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _unpause()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: VIPAirdrop
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: length = VIPs.length

  ID: 2
  Type: NodeType.IF
  Expression: length <= 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert NoRecipients()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < length

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _mint(VIPs[i],5,amount,)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  11 -> 1

Function: uri
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uriMapping[id]

Edges:
  0 -> 1

Function: _verifyMerkleAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: MerkleProofUpgradeable.verify(merkleProof,_merkleRoot,keccak256(bytes)(bytes.concat(keccak256(bytes)(abi.encode(minterAddress,saleId)))))

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: houndsContractAddress = 0x354634c4621cDfb7a25E6486cCA1E019777D841B

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


