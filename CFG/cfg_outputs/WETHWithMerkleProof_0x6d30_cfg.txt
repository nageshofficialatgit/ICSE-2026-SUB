Contract: IERC20
==================================================


Contract: IERC20Metadata
==================================================


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: IERC20Errors
==================================================


Contract: IERC721Errors
==================================================


Contract: IERC1155Errors
==================================================


Contract: ERC20
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += value

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.IF
  Expression: fromBalance < value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientBalance(address,uint256,uint256)(from,fromBalance,value)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - value

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= value

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += value

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance < type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7


Contract: Hashes
==================================================

Function: commutativeKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: efficientKeccak256(a,b)

  ID: 4
  Type: NodeType.RETURN
  Expression: efficientKeccak256(b,a)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: efficientKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,a)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,b)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = keccak256(uint256,uint256)(0x00,0x40)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: MerkleProof
==================================================

Function: verify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProof(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: verifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProofCalldata(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: multiProofVerify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProof(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35

Function: multiProofVerifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProofCalldata(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35


Contract: WETHWithMerkleProof
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: merkleRoot = _merkleRoot

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ERC20(Wrapped Ether,WETH)

Edges:
  0 -> 2
  2 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += value

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.IF
  Expression: fromBalance < value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientBalance(address,uint256,uint256)(from,fromBalance,value)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - value

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= value

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += value

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance < type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: claimTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(MerkleProof.verifyCalldata(proof,merkleRoot,leaf),Invalid proof)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _mint(msg.sender,amount)

Edges:
  0 -> 1
  1 -> 2


