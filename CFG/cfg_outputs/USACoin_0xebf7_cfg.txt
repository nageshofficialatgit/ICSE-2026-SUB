Contract: AggregatorV3Interface
==================================================


Contract: IERC20
==================================================


Contract: IUniswapV3Router
==================================================


Contract: IUniswapV3Factory
==================================================


Contract: USACoin
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: initialTotalSupply = initialSupply * (10 ** uint256(decimals))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _balances[msg.sender] = initialTotalSupply

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: creator = _creator

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: uniswapRouter = IUniswapV3Router(_uniswapRouter)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: tokenPriceFeeds[_token1UsdPriceFeed] = AggregatorV3Interface(_token1UsdPriceFeed)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tokenPriceFeeds[_token2UsdPriceFeed] = AggregatorV3Interface(_token2UsdPriceFeed)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenPriceFeeds[_token3UsdPriceFeed] = AggregatorV3Interface(_token3UsdPriceFeed)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tokenPriceFeeds[_token4UsdPriceFeed] = AggregatorV3Interface(_token4UsdPriceFeed)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: acceptedTokens.push(_dlmToken)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),msg.sender,initialTotalSupply)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: initialTotalSupply

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _balances[msg.sender] -= amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,to,amount)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _balances[from] -= amount

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += amount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _allowances[from][msg.sender] -= amount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,amount)

  ID: 7
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _allowances[msg.sender][spender] = amount

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,spender,amount)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: getLatestPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (None,price,None,None,None) = priceFeed.latestRoundData()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(price > 0,Invalid price from oracle)

  ID: 4
  Type: NodeType.RETURN
  Expression: uint256(price)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: setTokenPriceFeed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == creator,Only creator can set price feeds)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tokenPriceFeeds[token] = AggregatorV3Interface(priceFeed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: acceptedTokens.push(token)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getUniswapPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: pool = IUniswapV3Factory(uniswapRouter.WETH()).getPool(tokenIn,tokenOut,uniswapFee)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(pool != address(0),Pool does not exist)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: price = uniswapRouter.exactInputSingle(tokenIn,tokenOut,uniswapFee,address(this),block.timestamp,1,1,0)

  ID: 4
  Type: NodeType.RETURN
  Expression: price

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getBestTokenForFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: highestBalance = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: bestToken = address(0)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: bestTokenFee = 0

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < acceptedTokens.length

  ID: 8
  Type: NodeType.VARIABLE
  Expression: token = acceptedTokens[i]

  ID: 9
  Type: NodeType.VARIABLE
  Expression: tokenBalance = IERC20(token).balanceOf(user)

  ID: 10
  Type: NodeType.IF
  Expression: tokenBalance > 0

  ID: 11
  Type: NodeType.VARIABLE
  Expression: tokenPriceInUsd = getUniswapPrice(token,uniswapRouter.WETH())

  ID: 12
  Type: NodeType.VARIABLE
  Expression: feeInToken = (feeInUsd * (10 ** uint256(decimals))) / tokenPriceInUsd

  ID: 13
  Type: NodeType.IF
  Expression: tokenBalance >= feeInToken && tokenBalance > highestBalance

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: highestBalance = tokenBalance

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bestToken = token

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: bestTokenFee = feeInToken

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.RETURN
  Expression: (bestToken,bestTokenFee)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 20
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 18
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 17
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 7

Function: exemptFromFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == creator,Only creator can exempt addresses)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: exemptedAddresses[_wallet] = true

Edges:
  0 -> 1
  1 -> 2

Function: removeExemption
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == creator,Only creator can remove exemption)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: exemptedAddresses[_wallet] = false

Edges:
  0 -> 1
  1 -> 2

Function: sellTokensAndPayFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_balances[msg.sender] >= tokenAmount,Insufficient token balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokenPriceInUsd = fixedTokenPriceInUsd

  ID: 3
  Type: NodeType.VARIABLE
  Expression: saleValueInUsd = (tokenAmount * tokenPriceInUsd) / (10 ** uint256(decimals))

  ID: 4
  Type: NodeType.VARIABLE
  Expression: feeInUsd = (saleValueInUsd * 5) / 100

  ID: 5
  Type: NodeType.IF
  Expression: exemptedAddresses[msg.sender]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: feeInUsd = 0

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (bestToken,feeInToken) = getBestTokenForFee(msg.sender,feeInUsd)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(bestToken != address(0),No valid token found for fee payment)

  ID: 12
  Type: NodeType.IF
  Expression: feeInUsd > 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: IERC20(bestToken).transferFrom(msg.sender,creator,feeInToken)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _balances[msg.sender] -= tokenAmount

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _balances[creator] += tokenAmount

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: FeePaid(msg.sender,tokenAmount,feeInToken)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17

Function: withdrawFees
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == creator,Only creator can withdraw fees)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: contractBalance = address(this).balance

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(contractBalance > 0,No fees to withdraw)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: address(creator).transfer(contractBalance)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getTokenPriceInUsd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ethPriceInUsd = getLatestPrice(ethUsdPriceFeed)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: tokenPriceInEth = getUniswapPrice(token,uniswapRouter.WETH())

  ID: 3
  Type: NodeType.VARIABLE
  Expression: tokenPriceInUsd = (tokenPriceInEth * ethPriceInUsd) / (10 ** 18)

  ID: 4
  Type: NodeType.RETURN
  Expression: tokenPriceInUsd

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = USACoin

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = USA

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: fixedTokenPriceInUsd = 1 * (10 ** 18)

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: uniswapFee = 3000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


