Contract: OraclizeI
==================================================


Contract: OraclizeAddrResolverI
==================================================


Contract: usingOraclize
==================================================

Function: oraclize_setNetwork
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_mainnet)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_ropsten3)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_kovan)

  ID: 14
  Type: NodeType.RETURN
  Expression: true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_rinkeby)

  ID: 19
  Type: NodeType.RETURN
  Expression: true

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)

  ID: 23
  Type: NodeType.RETURN
  Expression: true

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)

  ID: 27
  Type: NodeType.RETURN
  Expression: true

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)

  ID: 31
  Type: NodeType.RETURN
  Expression: true

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  15 -> 16
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  24 -> 25
  25 -> 26
  25 -> 28
  26 -> 27
  28 -> 29
  29 -> 30
  29 -> 32
  30 -> 31
  32 -> 33

Function: __callback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: oraclize_useCoupon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize.useCoupon(code)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_getPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.getPrice(datasource,gaslimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_query
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: dynargs = new bytes[](5)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dynargs[0] = args[0]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dynargs[1] = args[1]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dynargs[2] = args[2]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dynargs[3] = args[3]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dynargs[4] = args[4]

  ID: 7
  Type: NodeType.RETURN
  Expression: oraclize_query(datasource,dynargs,gaslimit)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

  ID: 9
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: oraclize_cbAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.cbAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setProofType(proofP)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setCustomGasPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setCustomGasPrice(gasPrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setConfig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setConfig(config)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_randomDS_getSessionPubKeyHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.randomDS_getSessionPubKeyHash()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: getCodeSize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: _size

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: parseAddr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tmp = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: iaddr = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 2

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < 2 + 2 * 20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: iaddr *= 256

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: b1 = uint160(tmp[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: b2 = uint160(tmp[i + 1])

  ID: 12
  Type: NodeType.IF
  Expression: (b1 >= 97) && (b1 <= 102)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b1 -= 87

  ID: 14
  Type: NodeType.IF
  Expression: (b1 >= 65) && (b1 <= 70)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: b1 -= 55

  ID: 16
  Type: NodeType.IF
  Expression: (b1 >= 48) && (b1 <= 57)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b1 -= 48

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: (b2 >= 97) && (b2 <= 102)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: b2 -= 87

  ID: 23
  Type: NodeType.IF
  Expression: (b2 >= 65) && (b2 <= 70)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: b2 -= 55

  ID: 25
  Type: NodeType.IF
  Expression: (b2 >= 48) && (b2 <= 57)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: b2 -= 48

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: iaddr += (b1 * 16 + b2)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 32
  Type: NodeType.RETURN
  Expression: address(iaddr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 32
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 20
  14 -> 15
  14 -> 16
  15 -> 19
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 29
  23 -> 24
  23 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 8

Function: strCompare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: a = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: b = bytes(_b)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: minLength = a.length

  ID: 4
  Type: NodeType.IF
  Expression: b.length < minLength

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: minLength = b.length

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < minLength

  ID: 11
  Type: NodeType.IF
  Expression: a[i] < b[i]

  ID: 12
  Type: NodeType.RETURN
  Expression: - 1

  ID: 13
  Type: NodeType.IF
  Expression: a[i] > b[i]

  ID: 14
  Type: NodeType.RETURN
  Expression: 1

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: a.length < b.length

  ID: 19
  Type: NodeType.RETURN
  Expression: - 1

  ID: 20
  Type: NodeType.IF
  Expression: a.length > b.length

  ID: 21
  Type: NodeType.RETURN
  Expression: 1

  ID: 22
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 18
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  17 -> 10
  18 -> 19
  18 -> 20
  20 -> 21
  20 -> 22

Function: indexOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: h = bytes(_haystack)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: n = bytes(_needle)

  ID: 3
  Type: NodeType.IF
  Expression: h.length < 1 || n.length < 1 || (n.length > h.length)

  ID: 4
  Type: NodeType.RETURN
  Expression: - 1

  ID: 5
  Type: NodeType.IF
  Expression: h.length > (2 ** 128 - 1)

  ID: 6
  Type: NodeType.RETURN
  Expression: - 1

  ID: 7
  Type: NodeType.VARIABLE
  Expression: subindex = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < h.length

  ID: 12
  Type: NodeType.IF
  Expression: h[i] == n[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: subindex = 1

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: subindex ++

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: subindex == n.length

  ID: 19
  Type: NodeType.RETURN
  Expression: int256(i)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.RETURN
  Expression: - 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 10
  8 -> 11
  9 -> 23
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 21
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 15
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 11

Function: strConcat
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: strConcat(_a,_b,,,)

Edges:
  0 -> 1

Function: parseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bresult = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: mint = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: decimals = false

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < bresult.length

  ID: 8
  Type: NodeType.IF
  Expression: (bresult[i] >= 48) && (bresult[i] <= 57)

  ID: 9
  Type: NodeType.IF
  Expression: decimals

  ID: 10
  Type: NodeType.IF
  Expression: _b == 0

  ID: 11
  Type: NodeType.BREAK
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _b --

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mint *= 10

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mint += uint256(bresult[i]) - 48

  ID: 17
  Type: NodeType.IF
  Expression: bresult[i] == 46

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: decimals = true

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 22
  Type: NodeType.IF
  Expression: _b > 0

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mint *= 10 ** _b

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: mint

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 22
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 17
  9 -> 10
  9 -> 14
  10 -> 11
  10 -> 12
  11 -> 5
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 7
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25

Function: uint2str
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: i == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = i

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: j != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: j /= 10

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: bstr = new bytes(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: k = len - 1

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bstr[k --] = bytes1(48 + i % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i /= 10

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: string(bstr)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: stra2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: ba2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: oraclize_setNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_network_name = _network_name

Edges:
  0 -> 1

Function: oraclize_getNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize_network_name

Edges:
  0 -> 1

Function: oraclize_newRandomDSQuery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_nbytes == 0) || (_nbytes > 32)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: nbytes = new bytes(1)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: nbytes[0] = bytes1(_nbytes)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: unonce = new bytes(32)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash = new bytes(32)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash()

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: args = (unonce,nbytes,sessionKeyHash)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: queryId = oraclize_query(_delay,random,args,_customGasLimit)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_setCommitment(queryId,sha3()(bytes8(_delay),args[1],sha256()(args[0]),args[2]))

  ID: 14
  Type: NodeType.RETURN
  Expression: queryId

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: oraclize_randomDS_setCommitment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_args[queryId] = commitment

Edges:
  0 -> 1

Function: verifySig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sigr_ = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: offset = 4 + (uint256(dersig[3]) - 0x20)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sigr_ = copyBytes(dersig,offset,32,sigr_,0)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sigs_ = new bytes(32)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: offset += 32 + 2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sigs_ = copyBytes(dersig,offset + (uint256(dersig[offset - 1]) - 0x20),32,sigs_,0)

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,27,sigr,sigs)

  ID: 14
  Type: NodeType.IF
  Expression: address(sha3()(pubkey)) == signer

  ID: 15
  Type: NodeType.RETURN
  Expression: true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,28,sigr,sigs)

  ID: 17
  Type: NodeType.RETURN
  Expression: (address(sha3()(pubkey)) == signer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: oraclize_randomDS_proofVerify__sessionKeyValidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sig2 = new bytes(uint256(proof[sig2offset + 1]) + 2)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset,sig2.length,sig2,0)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: appkey1_pubkey = new bytes(64)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 1,64,appkey1_pubkey,0)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: tosign2 = new bytes(1 + 65 + 32)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tosign2[0] = 1

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 65,65,tosign2,1)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: CODEHASH = 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(CODEHASH,0,32,tosign2,1 + 65)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign2),sig2,appkey1_pubkey)

  ID: 12
  Type: NodeType.IF
  Expression: sigok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: LEDGERKEY = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4

  ID: 16
  Type: NodeType.VARIABLE
  Expression: tosign3 = new bytes(1 + 65)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: tosign3[0] = 0xFE

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3,65,tosign3,1)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: sig3 = new bytes(uint256(proof[3 + 65 + 1]) + 2)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 65,sig3.length,sig3,0)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign3),sig3,LEDGERKEY)

  ID: 22
  Type: NodeType.RETURN
  Expression: sigok

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: oraclize_randomDS_proofVerify__returnCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_proof[0] != L) || (_proof[1] != P) || (_proof[2] != 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: 1

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: proofVerified = oraclize_randomDS_proofVerify__main(_proof,_queryId,bytes(_result),oraclize_getNetworkName())

  ID: 5
  Type: NodeType.IF
  Expression: proofVerified == false

  ID: 6
  Type: NodeType.RETURN
  Expression: 2

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: matchBytes32Prefix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: match_ = true

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < prefix.length

  ID: 6
  Type: NodeType.IF
  Expression: content[i] != prefix[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: match_ = false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: match_

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5

Function: oraclize_randomDS_proofVerify__main
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: ledgerProofLength = 3 + 65 + (uint256(proof[3 + 65 + 1]) + 2) + 32

  ID: 3
  Type: NodeType.VARIABLE
  Expression: keyhash = new bytes(32)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32,keyhash,0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: checkok = (sha3()(keyhash) == sha3()(sha256()(context_name,queryId)))

  ID: 6
  Type: NodeType.IF
  Expression: checkok == false

  ID: 7
  Type: NodeType.RETURN
  Expression: false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: sig1 = new bytes(uint256(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + (32 + 8 + 1 + 32),sig1.length,sig1,0)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: checkok = matchBytes32Prefix(sha256()(sig1),result)

  ID: 12
  Type: NodeType.IF
  Expression: checkok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: commitmentSlice1 = new bytes(8 + 1 + 32)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + 32,8 + 1 + 32,commitmentSlice1,0)

  ID: 17
  Type: NodeType.VARIABLE
  Expression: sessionPubkey = new bytes(64)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 64,64,sessionPubkey,0)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: sessionPubkeyHash = sha256()(sessionPubkey)

  ID: 21
  Type: NodeType.IF
  Expression: oraclize_randomDS_args[queryId] == sha3()(commitmentSlice1,sessionPubkeyHash)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: delete oraclize_randomDS_args[queryId]

  ID: 23
  Type: NodeType.RETURN
  Expression: false

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.VARIABLE
  Expression: tosign1 = new bytes(32 + 8 + 1 + 32)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32 + 8 + 1 + 32,tosign1,0)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: checkok = verifySig(sha256()(tosign1),sig1,sessionPubkey)

  ID: 28
  Type: NodeType.IF
  Expression: checkok == false

  ID: 29
  Type: NodeType.RETURN
  Expression: false

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof,sig2offset)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.RETURN
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  32 -> 33
  33 -> 34

Function: copyBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: minLength = length + toOffset

  ID: 2
  Type: NodeType.IF
  Expression: to.length < minLength

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 32 + fromOffset

  ID: 6
  Type: NodeType.VARIABLE
  Expression: j = 32 + toOffset

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < (32 + fromOffset + length)

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i += 32

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: j += 32

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: to

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 13
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 8
  13 -> 14

Function: safer_ecrecover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (ret,addr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: ecrecovery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: sig.length != 65

  ID: 5
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: v < 27

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: v += 27

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: v != 27 && v != 28

  ID: 13
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: safer_ecrecover(hash,v,r,s)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: day = 60 * 60 * 24

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: week = 60 * 60 * 24 * 7

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: month = 60 * 60 * 24 * 30

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_NONE = 0x00

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_TLSNotary = 0x10

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Android = 0x20

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Ledger = 0x30

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Native = 0xF0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofStorage_IPFS = 0x01

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_auto = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_mainnet = 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_testnet = 2

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_morden = 2

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_consensys = 161

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13


Contract: strings
==================================================

Function: memcpy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: len >= 32

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dest += 32

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: src += 32

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len -= 32

  ID: 9
  Type: NodeType.VARIABLE
  Expression: mask = 256 ** (32 - len) - 1

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 3
  2 -> 9
  3 -> 4
  3 -> 2
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 3
  9 -> 10
  10 -> 11

Function: toSlice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: slice(bytes(self).length,ptr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: len
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = self._ptr - 31

  ID: 2
  Type: NodeType.VARIABLE
  Expression: end = ptr + self._len

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: len = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: ptr < end

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ptr += 1

  ID: 12
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ptr += 2

  ID: 14
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ptr += 3

  ID: 16
  Type: NodeType.IF
  Expression: b < 0xF8

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ptr += 4

  ID: 18
  Type: NodeType.IF
  Expression: b < 0xFC

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ptr += 5

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ptr += 6

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 27
  Type: NodeType.RETURN
  Expression: len

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 27
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 25
  12 -> 13
  12 -> 14
  13 -> 24
  14 -> 15
  14 -> 16
  15 -> 23
  16 -> 17
  16 -> 18
  17 -> 22
  18 -> 19
  18 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 6

Function: toSliceB32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ret._len = len(self)

  ID: 4
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: copy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: slice(self._len,self._ptr)

Edges:
  0 -> 1

Function: toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ret = new string(self._len)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: memcpy(retptr,self._ptr,self._len)

  ID: 6
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: empty
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self._len == 0

Edges:
  0 -> 1

Function: compare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: shortest = self._len

  ID: 2
  Type: NodeType.IF
  Expression: other._len < self._len

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: shortest = other._len

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: selfptr = self._ptr

  ID: 6
  Type: NodeType.VARIABLE
  Expression: otherptr = other._ptr

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: idx = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: idx < shortest

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: a != b

  ID: 16
  Type: NodeType.VARIABLE
  Expression: mask = ~ (2 ** (8 * (32 - shortest + idx)) - 1)

  ID: 17
  Type: NodeType.VARIABLE
  Expression: diff = (a & mask) - (b & mask)

  ID: 18
  Type: NodeType.IF
  Expression: diff != 0

  ID: 19
  Type: NodeType.RETURN
  Expression: int256(diff)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: selfptr += 32

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: otherptr += 32

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: idx += 32

  ID: 25
  Type: NodeType.RETURN
  Expression: int256(self._len) - int256(other._len)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 25
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 21
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 10

Function: equals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: compare(self,other) == 0

Edges:
  0 -> 1

Function: nextRune
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: nextRune(self,ret)

  ID: 2
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2

Function: ord
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: div = 2 ** 248

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: b = word / div

  ID: 10
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ret = b

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: len = 1

  ID: 13
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x1F

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: len = 2

  ID: 16
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x0F

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: len = 3

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x07

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: len = 4

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: len > self._len

  ID: 25
  Type: NodeType.RETURN
  Expression: 0

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 28
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 29
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 30
  Type: NodeType.IFLOOP
  Expression: i < len

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: div = div / 256

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: b = (word / div) & 0xFF

  ID: 33
  Type: NodeType.IF
  Expression: b & 0xC0 != 0x80

  ID: 34
  Type: NodeType.RETURN
  Expression: 0

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: ret = (ret * 64) | (b & 0x3F)

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 38
  Type: NodeType.RETURN
  Expression: ret

  ID: 39
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 13
  11 -> 12
  12 -> 23
  13 -> 14
  13 -> 16
  14 -> 15
  15 -> 22
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 21
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  26 -> 29
  27 -> 30
  28 -> 38
  29 -> 27
  30 -> 31
  30 -> 28
  31 -> 32
  32 -> 33
  33 -> 34
  33 -> 35
  35 -> 36
  36 -> 37
  37 -> 30

Function: keccak
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: startsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len < needle._len

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: self._ptr == needle._ptr

  ID: 5
  Type: NodeType.RETURN
  Expression: true

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: equal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: beyond
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len < needle._len

  ID: 2
  Type: NodeType.RETURN
  Expression: self

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: equal = true

  ID: 5
  Type: NodeType.IF
  Expression: self._ptr != needle._ptr

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: equal

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: self._len -= needle._len

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: self._ptr += needle._len

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: self

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 12
  10 -> 11
  11 -> 12
  12 -> 13

Function: endsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len < needle._len

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: selfptr = self._ptr + self._len - needle._len

  ID: 5
  Type: NodeType.IF
  Expression: selfptr == needle._ptr

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: equal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: until
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len < needle._len

  ID: 2
  Type: NodeType.RETURN
  Expression: self

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: selfptr = self._ptr + self._len - needle._len

  ID: 5
  Type: NodeType.VARIABLE
  Expression: equal = true

  ID: 6
  Type: NodeType.IF
  Expression: selfptr != needle._ptr

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: equal

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: self._len -= needle._len

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: self

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: findPtr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: needlelen <= selflen

  ID: 4
  Type: NodeType.IF
  Expression: needlelen <= 32

  ID: 5
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: ptr

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ptr = selfptr

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: idx = 0

  ID: 15
  Type: NodeType.IFLOOP
  Expression: idx <= selflen - needlelen

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: hash == testHash

  ID: 20
  Type: NodeType.RETURN
  Expression: ptr

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ptr += 1

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: idx ++

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.RETURN
  Expression: selfptr + selflen

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 25
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 14
  12 -> 15
  13 -> 24
  14 -> 12
  15 -> 16
  15 -> 13
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  21 -> 22
  22 -> 23
  23 -> 15
  24 -> 25
  25 -> 26

Function: rfindPtr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: needlelen <= selflen

  ID: 3
  Type: NodeType.IF
  Expression: needlelen <= 32

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: ptr

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ptr = selfptr + (selflen - needlelen)

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.IFLOOP
  Expression: ptr >= selfptr

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: hash == testHash

  ID: 17
  Type: NodeType.RETURN
  Expression: ptr + needlelen

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ptr -= 1

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.RETURN
  Expression: selfptr

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 22
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 20
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19
  19 -> 12
  20 -> 21
  21 -> 22
  22 -> 23

Function: find
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = findPtr(self._len,self._ptr,needle._len,needle._ptr)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: self._len -= ptr - self._ptr

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: self._ptr = ptr

  ID: 4
  Type: NodeType.RETURN
  Expression: self

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: rfind
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = rfindPtr(self._len,self._ptr,needle._len,needle._ptr)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: self._len = ptr - self._ptr

  ID: 3
  Type: NodeType.RETURN
  Expression: self

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: split
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: split(self,needle,token)

  ID: 2
  Type: NodeType.RETURN
  Expression: token

Edges:
  0 -> 1
  1 -> 2

Function: rsplit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rsplit(self,needle,token)

  ID: 2
  Type: NodeType.RETURN
  Expression: token

Edges:
  0 -> 1
  1 -> 2

Function: count
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = findPtr(self._len,self._ptr,needle._len,needle._ptr) + needle._len

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: ptr <= self._ptr + self._len

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ptr = findPtr(self._len - (ptr - self._ptr),ptr,needle._len,needle._ptr) + needle._len

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 3
  6 -> 7

Function: contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: rfindPtr(self._len,self._ptr,needle._len,needle._ptr) != self._ptr

Edges:
  0 -> 1

Function: concat
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ret = new string(self._len + other._len)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: memcpy(retptr,self._ptr,self._len)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: memcpy(retptr + self._len,other._ptr,other._len)

  ID: 7
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: join
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: parts.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: len = self._len * (parts.length - 1)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < parts.length

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: len += parts[i]._len

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ret = new string(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 18
  Type: NodeType.IFLOOP
  Expression: i < parts.length

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: memcpy(retptr,parts[i]._ptr,parts[i]._len)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: retptr += parts[i]._len

  ID: 21
  Type: NodeType.IF
  Expression: i < parts.length - 1

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: memcpy(retptr,self._ptr,self._len)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: retptr += self._len

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 26
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 11
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 17
  15 -> 18
  16 -> 26
  17 -> 15
  18 -> 19
  18 -> 16
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 18


Contract: DSSafeAddSub
==================================================

Function: safeToAdd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (a + b >= a)

Edges:
  0 -> 1

Function: safeAdd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! safeToAdd(a,b)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a + b

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: safeToSubtract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (b <= a)

Edges:
  0 -> 1

Function: safeSub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! safeToSubtract(a,b)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4


Contract: Etheroll
==================================================

Function: safeToAdd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (a + b >= a)

Edges:
  0 -> 1

Function: safeAdd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! safeToAdd(a,b)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a + b

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: safeToSubtract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (b <= a)

Edges:
  0 -> 1

Function: safeSub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! safeToSubtract(a,b)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: oraclize_setNetwork
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_mainnet)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_ropsten3)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_kovan)

  ID: 14
  Type: NodeType.RETURN
  Expression: true

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetworkName(eth_rinkeby)

  ID: 19
  Type: NodeType.RETURN
  Expression: true

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)

  ID: 23
  Type: NodeType.RETURN
  Expression: true

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)

  ID: 27
  Type: NodeType.RETURN
  Expression: true

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)

  ID: 31
  Type: NodeType.RETURN
  Expression: true

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  15 -> 16
  16 -> 17
  16 -> 20
  17 -> 18
  18 -> 19
  20 -> 21
  21 -> 22
  21 -> 24
  22 -> 23
  24 -> 25
  25 -> 26
  25 -> 28
  26 -> 27
  28 -> 29
  29 -> 30
  29 -> 32
  30 -> 31
  32 -> 33

Function: __callback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: playerAddress[myid] == 0x0

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: sl_result = result.toSlice()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: sl_result.beyond([.toSlice()).until(].toSlice())

  ID: 6
  Type: NodeType.VARIABLE
  Expression: serialNumberOfResult = parseInt(sl_result.split(, .toSlice()).toString())

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: playerRandomResult[myid] = parseInt(sl_result.beyond([.toSlice()).until(].toSlice()).toString())

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: playerDieResult[myid] = uint256(sha3()(playerRandomResult[myid],proof)) % 100 + 1

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: playerTempAddress[myid] = playerAddress[myid]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: delete playerAddress[myid]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: playerTempReward[myid] = playerProfit[myid]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: playerProfit[myid] = 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: maxPendingPayouts = safeSub(maxPendingPayouts,playerTempReward[myid])

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: playerTempBetValue[myid] = playerBetValue[myid]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: playerBetValue[myid] = 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: totalBets += 1

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: totalWeiWagered += playerTempBetValue[myid]

  ID: 18
  Type: NodeType.IF
  Expression: playerDieResult[myid] == 0 || bytes(result).length == 0 || bytes(proof).length == 0 || playerRandomResult[myid] == 0

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: LogResult(serialNumberOfResult,playerBetId[myid],playerTempAddress[myid],playerNumber[myid],playerDieResult[myid],playerTempBetValue[myid],3,proof,playerRandomResult[myid])

  ID: 20
  Type: NodeType.IF
  Expression: ! playerTempAddress[myid].send(playerTempBetValue[myid])

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: LogResult(serialNumberOfResult,playerBetId[myid],playerTempAddress[myid],playerNumber[myid],playerDieResult[myid],playerTempBetValue[myid],4,proof,playerRandomResult[myid])

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]],playerTempBetValue[myid])

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.RETURN
  Expression: 

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.IF
  Expression: playerDieResult[myid] < playerNumber[myid]

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: contractBalance = safeSub(contractBalance,playerTempReward[myid])

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: totalWeiWon = safeAdd(totalWeiWon,playerTempReward[myid])

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: playerTempReward[myid] = safeAdd(playerTempReward[myid],playerTempBetValue[myid])

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: LogResult(serialNumberOfResult,playerBetId[myid],playerTempAddress[myid],playerNumber[myid],playerDieResult[myid],playerTempReward[myid],1,proof,playerRandomResult[myid])

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: setMaxProfit()

  ID: 32
  Type: NodeType.IF
  Expression: ! playerTempAddress[myid].send(playerTempReward[myid])

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: LogResult(serialNumberOfResult,playerBetId[myid],playerTempAddress[myid],playerNumber[myid],playerDieResult[myid],playerTempReward[myid],2,proof,playerRandomResult[myid])

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]],playerTempReward[myid])

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.RETURN
  Expression: 

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: playerDieResult[myid] >= playerNumber[myid]

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: LogResult(serialNumberOfResult,playerBetId[myid],playerTempAddress[myid],playerNumber[myid],playerDieResult[myid],playerTempBetValue[myid],0,proof,playerRandomResult[myid])

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: contractBalance = safeAdd(contractBalance,(playerTempBetValue[myid] - 1))

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: setMaxProfit()

  ID: 42
  Type: NodeType.IF
  Expression: ! playerTempAddress[myid].send(1)

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]],1)

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.RETURN
  Expression: 

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: onlyOraclize()

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: payoutsAreActive()

Edges:
  0 -> 47
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 25
  19 -> 20
  20 -> 21
  20 -> 23
  21 -> 22
  22 -> 23
  23 -> 24
  25 -> 26
  26 -> 27
  26 -> 37
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  32 -> 35
  33 -> 34
  34 -> 35
  35 -> 36
  37 -> 38
  38 -> 39
  38 -> 46
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  42 -> 44
  43 -> 44
  44 -> 45
  47 -> 48
  48 -> 1

Function: oraclize_useCoupon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize.useCoupon(code)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_getPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.getPrice(datasource,gaslimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_query
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: dynargs = new bytes[](5)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dynargs[0] = args[0]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dynargs[1] = args[1]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dynargs[2] = args[2]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dynargs[3] = args[3]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dynargs[4] = args[4]

  ID: 7
  Type: NodeType.RETURN
  Expression: oraclize_query(datasource,dynargs,gaslimit)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

  ID: 9
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: oraclize_cbAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.cbAddress()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setProofType(proofP)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setCustomGasPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setCustomGasPrice(gasPrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_setConfig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.setConfig(config)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: oraclize_randomDS_getSessionPubKeyHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize.randomDS_getSessionPubKeyHash()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: oraclizeAPI()

Edges:
  0 -> 2
  2 -> 1

Function: getCodeSize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: _size

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: parseAddr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tmp = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: iaddr = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 2

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < 2 + 2 * 20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: iaddr *= 256

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: b1 = uint160(tmp[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: b2 = uint160(tmp[i + 1])

  ID: 12
  Type: NodeType.IF
  Expression: (b1 >= 97) && (b1 <= 102)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b1 -= 87

  ID: 14
  Type: NodeType.IF
  Expression: (b1 >= 65) && (b1 <= 70)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: b1 -= 55

  ID: 16
  Type: NodeType.IF
  Expression: (b1 >= 48) && (b1 <= 57)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b1 -= 48

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: (b2 >= 97) && (b2 <= 102)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: b2 -= 87

  ID: 23
  Type: NodeType.IF
  Expression: (b2 >= 65) && (b2 <= 70)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: b2 -= 55

  ID: 25
  Type: NodeType.IF
  Expression: (b2 >= 48) && (b2 <= 57)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: b2 -= 48

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: iaddr += (b1 * 16 + b2)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 32
  Type: NodeType.RETURN
  Expression: address(iaddr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 32
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 20
  14 -> 15
  14 -> 16
  15 -> 19
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 29
  23 -> 24
  23 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 8

Function: strCompare
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: a = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: b = bytes(_b)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: minLength = a.length

  ID: 4
  Type: NodeType.IF
  Expression: b.length < minLength

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: minLength = b.length

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < minLength

  ID: 11
  Type: NodeType.IF
  Expression: a[i] < b[i]

  ID: 12
  Type: NodeType.RETURN
  Expression: - 1

  ID: 13
  Type: NodeType.IF
  Expression: a[i] > b[i]

  ID: 14
  Type: NodeType.RETURN
  Expression: 1

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: a.length < b.length

  ID: 19
  Type: NodeType.RETURN
  Expression: - 1

  ID: 20
  Type: NodeType.IF
  Expression: a.length > b.length

  ID: 21
  Type: NodeType.RETURN
  Expression: 1

  ID: 22
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 18
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  17 -> 10
  18 -> 19
  18 -> 20
  20 -> 21
  20 -> 22

Function: indexOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: h = bytes(_haystack)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: n = bytes(_needle)

  ID: 3
  Type: NodeType.IF
  Expression: h.length < 1 || n.length < 1 || (n.length > h.length)

  ID: 4
  Type: NodeType.RETURN
  Expression: - 1

  ID: 5
  Type: NodeType.IF
  Expression: h.length > (2 ** 128 - 1)

  ID: 6
  Type: NodeType.RETURN
  Expression: - 1

  ID: 7
  Type: NodeType.VARIABLE
  Expression: subindex = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < h.length

  ID: 12
  Type: NodeType.IF
  Expression: h[i] == n[0]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: subindex = 1

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: subindex ++

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: subindex == n.length

  ID: 19
  Type: NodeType.RETURN
  Expression: int256(i)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.RETURN
  Expression: - 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
  7 -> 10
  8 -> 11
  9 -> 23
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 21
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 15
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 11

Function: strConcat
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: strConcat(_a,_b,,,)

Edges:
  0 -> 1

Function: parseInt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bresult = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: mint = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: decimals = false

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < bresult.length

  ID: 8
  Type: NodeType.IF
  Expression: (bresult[i] >= 48) && (bresult[i] <= 57)

  ID: 9
  Type: NodeType.IF
  Expression: decimals

  ID: 10
  Type: NodeType.IF
  Expression: _b == 0

  ID: 11
  Type: NodeType.BREAK
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _b --

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mint *= 10

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mint += uint256(bresult[i]) - 48

  ID: 17
  Type: NodeType.IF
  Expression: bresult[i] == 46

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: decimals = true

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 22
  Type: NodeType.IF
  Expression: _b > 0

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mint *= 10 ** _b

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: mint

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 22
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  8 -> 17
  9 -> 10
  9 -> 14
  10 -> 11
  10 -> 12
  11 -> 5
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 20
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 7
  22 -> 23
  22 -> 24
  23 -> 24
  24 -> 25

Function: uint2str
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: i == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = i

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: j != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: j /= 10

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: bstr = new bytes(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: k = len - 1

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bstr[k --] = bytes1(48 + i % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i /= 10

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: string(bstr)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: stra2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: ba2cbor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: arrlen = arr.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: outputlen = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: elemArray = new bytes[](arrlen)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: elemArray[i] = (bytes(arr[i]))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: ctr = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: cborlen = arrlen + 0x80

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: outputlen += bytes1(cborlen).length

  ID: 14
  Type: NodeType.VARIABLE
  Expression: res = new bytes(outputlen)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: bytes1(cborlen).length > ctr

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(cborlen)[ctr]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 23
  Type: NodeType.IFLOOP
  Expression: i < arrlen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0x5F

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 26
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 27
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: x = 0

  ID: 29
  Type: NodeType.IFLOOP
  Expression: x < elemArray[i].length

  ID: 30
  Type: NodeType.IF
  Expression: x % 23 == 0

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: elemcborlen += 0x40

  ID: 33
  Type: NodeType.VARIABLE
  Expression: lctr = ctr

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: bytes1(elemcborlen).length > ctr - lctr

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = bytes1(elemcborlen)[ctr - lctr]

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 38
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = elemArray[i][x]

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: x ++

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: res[ctr] = 0xFF

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: ctr ++

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 46
  Type: NodeType.RETURN
  Expression: res

  ID: 47
  Type: NodeType.IF
  Expression: elemArray[i].length - x >= 24

  ID: 48
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = 23

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: elemcborlen = elemArray[i].length - x

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 11
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 7
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 16
  19 -> 22
  20 -> 23
  21 -> 46
  22 -> 20
  23 -> 24
  23 -> 21
  24 -> 25
  25 -> 28
  26 -> 29
  27 -> 43
  28 -> 26
  29 -> 30
  29 -> 27
  30 -> 47
  30 -> 39
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 38
  36 -> 37
  37 -> 35
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 29
  43 -> 44
  44 -> 45
  45 -> 23
  47 -> 48
  47 -> 49
  48 -> 50
  49 -> 50
  50 -> 32

Function: oraclize_setNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_network_name = _network_name

Edges:
  0 -> 1

Function: oraclize_getNetworkName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: oraclize_network_name

Edges:
  0 -> 1

Function: oraclize_newRandomDSQuery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_nbytes == 0) || (_nbytes > 32)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: nbytes = new bytes(1)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: nbytes[0] = bytes1(_nbytes)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: unonce = new bytes(32)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash = new bytes(32)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash()

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: args = (unonce,nbytes,sessionKeyHash)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: queryId = oraclize_query(_delay,random,args,_customGasLimit)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_setCommitment(queryId,sha3()(bytes8(_delay),args[1],sha256()(args[0]),args[2]))

  ID: 14
  Type: NodeType.RETURN
  Expression: queryId

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14

Function: oraclize_randomDS_setCommitment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_args[queryId] = commitment

Edges:
  0 -> 1

Function: verifySig
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: sigr_ = new bytes(32)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: offset = 4 + (uint256(dersig[3]) - 0x20)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: sigr_ = copyBytes(dersig,offset,32,sigr_,0)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: sigs_ = new bytes(32)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: offset += 32 + 2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: sigs_ = copyBytes(dersig,offset + (uint256(dersig[offset - 1]) - 0x20),32,sigs_,0)

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,27,sigr,sigs)

  ID: 14
  Type: NodeType.IF
  Expression: address(sha3()(pubkey)) == signer

  ID: 15
  Type: NodeType.RETURN
  Expression: true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (sigok,signer) = safer_ecrecover(tosignh,28,sigr,sigs)

  ID: 17
  Type: NodeType.RETURN
  Expression: (address(sha3()(pubkey)) == signer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: oraclize_randomDS_proofVerify__sessionKeyValidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sig2 = new bytes(uint256(proof[sig2offset + 1]) + 2)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset,sig2.length,sig2,0)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: appkey1_pubkey = new bytes(64)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 1,64,appkey1_pubkey,0)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: tosign2 = new bytes(1 + 65 + 32)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tosign2[0] = 1

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 65,65,tosign2,1)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: CODEHASH = 0xfd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(CODEHASH,0,32,tosign2,1 + 65)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign2),sig2,appkey1_pubkey)

  ID: 12
  Type: NodeType.IF
  Expression: sigok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: LEDGERKEY = 0x7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4

  ID: 16
  Type: NodeType.VARIABLE
  Expression: tosign3 = new bytes(1 + 65)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: tosign3[0] = 0xFE

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3,65,tosign3,1)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: sig3 = new bytes(uint256(proof[3 + 65 + 1]) + 2)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,3 + 65,sig3.length,sig3,0)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: sigok = verifySig(sha256()(tosign3),sig3,LEDGERKEY)

  ID: 22
  Type: NodeType.RETURN
  Expression: sigok

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22

Function: oraclize_randomDS_proofVerify__returnCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: (_proof[0] != L) || (_proof[1] != P) || (_proof[2] != 1)

  ID: 2
  Type: NodeType.RETURN
  Expression: 1

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: proofVerified = oraclize_randomDS_proofVerify__main(_proof,_queryId,bytes(_result),oraclize_getNetworkName())

  ID: 5
  Type: NodeType.IF
  Expression: proofVerified == false

  ID: 6
  Type: NodeType.RETURN
  Expression: 2

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: matchBytes32Prefix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: match_ = true

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < prefix.length

  ID: 6
  Type: NodeType.IF
  Expression: content[i] != prefix[i]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: match_ = false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: match_

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5

Function: oraclize_randomDS_proofVerify__main
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: ledgerProofLength = 3 + 65 + (uint256(proof[3 + 65 + 1]) + 2) + 32

  ID: 3
  Type: NodeType.VARIABLE
  Expression: keyhash = new bytes(32)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32,keyhash,0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: checkok = (sha3()(keyhash) == sha3()(sha256()(context_name,queryId)))

  ID: 6
  Type: NodeType.IF
  Expression: checkok == false

  ID: 7
  Type: NodeType.RETURN
  Expression: false

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: sig1 = new bytes(uint256(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + (32 + 8 + 1 + 32),sig1.length,sig1,0)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: checkok = matchBytes32Prefix(sha256()(sig1),result)

  ID: 12
  Type: NodeType.IF
  Expression: checkok == false

  ID: 13
  Type: NodeType.RETURN
  Expression: false

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: commitmentSlice1 = new bytes(8 + 1 + 32)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength + 32,8 + 1 + 32,commitmentSlice1,0)

  ID: 17
  Type: NodeType.VARIABLE
  Expression: sessionPubkey = new bytes(64)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,sig2offset - 64,64,sessionPubkey,0)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: sessionPubkeyHash = sha256()(sessionPubkey)

  ID: 21
  Type: NodeType.IF
  Expression: oraclize_randomDS_args[queryId] == sha3()(commitmentSlice1,sessionPubkeyHash)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: delete oraclize_randomDS_args[queryId]

  ID: 23
  Type: NodeType.RETURN
  Expression: false

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.VARIABLE
  Expression: tosign1 = new bytes(32 + 8 + 1 + 32)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: copyBytes(proof,ledgerProofLength,32 + 8 + 1 + 32,tosign1,0)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: checkok = verifySig(sha256()(tosign1),sig1,sessionPubkey)

  ID: 28
  Type: NodeType.IF
  Expression: checkok == false

  ID: 29
  Type: NodeType.RETURN
  Expression: false

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof,sig2offset)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.RETURN
  Expression: oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 30
  30 -> 31
  31 -> 32
  31 -> 33
  32 -> 33
  33 -> 34

Function: copyBytes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: minLength = length + toOffset

  ID: 2
  Type: NodeType.IF
  Expression: to.length < minLength

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 32 + fromOffset

  ID: 6
  Type: NodeType.VARIABLE
  Expression: j = 32 + toOffset

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < (32 + fromOffset + length)

  ID: 9
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i += 32

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: j += 32

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: to

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 13
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 8
  13 -> 14

Function: safer_ecrecover
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: (ret,addr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: ecrecovery
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: sig.length != 65

  ID: 5
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: v < 27

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: v += 27

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: v != 27 && v != 28

  ID: 13
  Type: NodeType.RETURN
  Expression: (false,0)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: safer_ecrecover(hash,v,r,s)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15

Function: Etheroll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: treasury = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: oraclize_setNetwork(networkID_auto)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ownerSetHouseEdge(990)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ownerSetMaxProfitAsPercentOfHouse(10000)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ownerSetMinBet(100000000000000000)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: gasForOraclize = 235000

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: oraclize_setCustomGasPrice(20000000000)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: playerRollDice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: rngId = oraclize_query(nested,[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random["serialNumber","data"]', '\n{"jsonrpc":"2.0","method":"generateSignedIntegers","params":{"apiKey":${[decrypt] BKg3TCs7lkzNr1kR6pxjPCM2SOejcFojUPMTOsBkC/47HHPf1sP2oxVLTjNBu+slR9SgZyqDtjVOV5Yzg12iUkbubp0DpcjCEdeJTHnGwC6gD729GUVoGvo96huxwRoZlCjYO80rWq2WGYoR/LC3WampDuvv2Bo=},"n":1,"min":1,"max":100,"replacement":true,"base":10${[identity] "}"},"id":1${[identity] "}"}'],gasForOraclize)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: playerBetId[rngId] = rngId

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: playerNumber[rngId] = rollUnder

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: playerBetValue[rngId] = msg.value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: playerAddress[rngId] = msg.sender

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: playerProfit[rngId] = ((((msg.value * (100 - (safeSub(rollUnder,1)))) / (safeSub(rollUnder,1)) + msg.value)) * houseEdge / houseEdgeDivisor) - msg.value

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: maxPendingPayouts = safeAdd(maxPendingPayouts,playerProfit[rngId])

  ID: 8
  Type: NodeType.IF
  Expression: maxPendingPayouts >= contractBalance

  ID: 9
  Type: NodeType.THROW
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: LogBet(playerBetId[rngId],playerAddress[rngId],safeAdd(playerBetValue[rngId],playerProfit[rngId]),playerProfit[rngId],playerBetValue[rngId],playerNumber[rngId])

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: gameIsActive()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: betIsValid(msg.value,rollUnder)

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  12 -> 13
  13 -> 1

Function: playerWithdrawPendingTransactions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: withdrawAmount = playerPendingWithdrawals[msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: playerPendingWithdrawals[msg.sender] = 0

  ID: 3
  Type: NodeType.IF
  Expression: msg.sender.call.value(withdrawAmount)()

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: playerPendingWithdrawals[msg.sender] = withdrawAmount

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: payoutsAreActive()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  8 -> 1

Function: playerGetPendingTxByAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: playerPendingWithdrawals[addressToCheck]

Edges:
  0 -> 1

Function: setMaxProfit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor

Edges:
  0 -> 1

Function: playerCheckProvablyFair
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(sha3()(randomResult,proof)) % 100 + 1

Edges:
  0 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: contractBalance = safeAdd(contractBalance,msg.value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setMaxProfit()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyTreasury()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: ownerSetCallbackGasPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: oraclize_setCustomGasPrice(newCallbackGasPrice)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerSetOraclizeSafeGas
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: gasForOraclize = newSafeGasToOraclize

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerUpdateContractBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: contractBalance = newContractBalanceInWei

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerSetHouseEdge
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: houseEdge = newHouseEdge

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerSetMaxProfitAsPercentOfHouse
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newMaxProfitAsPercent > 10000

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: maxProfitAsPercentOfHouse = newMaxProfitAsPercent

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: setMaxProfit()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: ownerSetMinBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: minBet = newMinimumBet

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerTransferEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: contractBalance = safeSub(contractBalance,amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setMaxProfit()

  ID: 3
  Type: NodeType.IF
  Expression: ! sendTo.send(amount)

  ID: 4
  Type: NodeType.THROW
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: LogOwnerTransfer(sendTo,amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  7 -> 1

Function: ownerRefundPlayer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: maxPendingPayouts = safeSub(maxPendingPayouts,originalPlayerProfit)

  ID: 2
  Type: NodeType.IF
  Expression: ! sendTo.send(originalPlayerBetValue)

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: LogRefund(originalPlayerBetId,sendTo,originalPlayerBetValue)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  6 -> 1

Function: ownerPauseGame
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: gamePaused = newStatus

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerPausePayouts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: payoutsPaused = newPayoutStatus

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerSetTreasury
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: treasury = newTreasury

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerChangeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: ownerkill
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: suicide(address)(owner)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalBets = 244612

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalWeiWon = 110633844560463069959901

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalWeiWagered = 316486087709317593009320

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: day = 60 * 60 * 24

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: week = 60 * 60 * 24 * 7

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: month = 60 * 60 * 24 * 30

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_NONE = 0x00

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_TLSNotary = 0x10

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Android = 0x20

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Ledger = 0x30

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofType_Native = 0xF0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: proofStorage_IPFS = 0x01

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_auto = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_mainnet = 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_testnet = 2

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_morden = 2

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: networkID_consensys = 161

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxProfitDivisor = 1000000

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: houseEdgeDivisor = 1000

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxNumber = 99

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minNumber = 2

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17


