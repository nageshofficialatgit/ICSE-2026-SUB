Contract: SafeMath
==================================================

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: ERC20Basic
==================================================


Contract: ERC20
==================================================


Contract: BasicToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 3
  Type: NodeType.IF
  Expression: _to == address(this)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: commitDividend(owner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[owner] = balances[owner].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,owner,_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_to)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 3
  Type: NodeType.IF
  Expression: _to == address(this)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: commitDividend(owner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[owner] = balances[owner].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,owner,_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_to)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_from)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_to)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(3 * 32)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(! ((_value != 0) && (allowed[msg.sender][_spender] != 0)))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1


Contract: SmartBillions
==================================================

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_from)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_to)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(3 * 32)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(! ((_value != 0) && (allowed[msg.sender][_spender] != 0)))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 3
  Type: NodeType.IF
  Expression: _to == address(this)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: commitDividend(owner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[owner] = balances[owner].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,owner,_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_to)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: SmartBillions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: animator = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: wallets[owner].lastDividendPeriod = uint16(dividendPeriod)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: dividends.push(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dividends.push(0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: hashesLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(hashes.length)

Edges:
  0 -> 1

Function: walletBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(wallets[_owner].balance)

Edges:
  0 -> 1

Function: walletPeriodOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(wallets[_owner].lastDividendPeriod)

Edges:
  0 -> 1

Function: walletBlockOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(wallets[_owner].nextWithdrawBlock)

Edges:
  0 -> 1

Function: betValueOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(bets[_owner].value)

Edges:
  0 -> 1

Function: betHashOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(bets[_owner].betHash)

Edges:
  0 -> 1

Function: betBlockNumberOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(bets[_owner].blockNum)

Edges:
  0 -> 1

Function: dividendsBlocks
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: investStart > 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: period = (block.number - hashFirst) / (10 * hashesSize)

  ID: 5
  Type: NodeType.IF
  Expression: period > dividendPeriod

  ID: 6
  Type: NodeType.RETURN
  Expression: (0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: ((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)))

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8

Function: changeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(_who != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_who)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = _who

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: changeAnimator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(_who != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: commitDividend(_who)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: animator = _who

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyAnimator()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: setInvestStart
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(investStart == 1 && hashFirst > 0 && block.number < _when)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: investStart = _when

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setBetMax
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: hashBetMax = _maxsum

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: resetBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: hashNext = block.number + 3

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: hashBetSum = 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: coldStore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: houseKeeping()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount)

  ID: 3
  Type: NodeType.IF
  Expression: investBalance >= investBalanceGot / 2

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(_amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: coldStoreLast = block.number

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: hotStore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: walletBalance += msg.value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].balance += uint208(msg.value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: houseKeeping()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: houseKeeping
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: investStart > 1 && block.number >= investStart + (hashesSize * 5)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: investStart = 0

  ID: 3
  Type: NodeType.IF
  Expression: hashFirst > 0

  ID: 4
  Type: NodeType.VARIABLE
  Expression: period = (block.number - hashFirst) / (10 * hashesSize)

  ID: 5
  Type: NodeType.IF
  Expression: period > dividends.length - 2

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dividends.push(0)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: dividendPeriod ++

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 12
  3 -> 4
  3 -> 11
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12

Function: payWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number

  ID: 2
  Type: NodeType.VARIABLE
  Expression: balance = wallets[msg.sender].balance

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].balance = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: walletBalance -= balance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: pay(balance)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: pay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: maxpay = this.balance / 2

  ID: 2
  Type: NodeType.IF
  Expression: maxpay >= _amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(_amount)

  ID: 4
  Type: NodeType.IF
  Expression: _amount > 1000000000000000

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: houseKeeping()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: keepbalance = _amount - maxpay

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: walletBalance += keepbalance

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].balance += uint208(keepbalance)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(maxpay)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 12
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: investDirect
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: invest(owner)

Edges:
  0 -> 1

Function: invest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: investing = msg.value

  ID: 3
  Type: NodeType.IF
  Expression: investing > investBalanceMax - investBalance

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: investing = investBalanceMax - investBalance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: investBalance = investBalanceMax

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: investBalanceGot = investBalanceMax

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: investStart = 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(msg.value.sub(investing))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: investBalance += investing

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: investBalanceGot += investing

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: _partner == address(0) || _partner == owner

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: walletBalance += investing / 10

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: wallets[owner].balance += uint208(investing / 10)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: walletBalance += (investing * 5 / 100) * 2

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: wallets[owner].balance += uint208(investing * 5 / 100)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: wallets[_partner].balance += uint208(investing * 5 / 100)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: senderBalance = investing / 10 ** 15

  ID: 21
  Type: NodeType.VARIABLE
  Expression: ownerBalance = investing * 16 / 10 ** 17

  ID: 22
  Type: NodeType.VARIABLE
  Expression: animatorBalance = investing * 10 / 10 ** 17

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] += senderBalance

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: balances[owner] += ownerBalance

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: balances[animator] += animatorBalance

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: totalSupply += senderBalance + ownerBalance + animatorBalance

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),msg.sender,senderBalance)

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),owner,ownerBalance)

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),animator,animatorBalance)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: LogInvestment(msg.sender,_partner,investing)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 9
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 11
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 15
  13 -> 14
  14 -> 18
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30

Function: disinvest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(investStart == 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: initialInvestment = balances[msg.sender] * 10 ** 15

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,address(0),balances[msg.sender])

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: delete balances[msg.sender]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: investBalance -= initialInvestment

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: payWallet()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: payDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(investStart == 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: payWallet()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: commitDividend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: last = wallets[_who].lastDividendPeriod

  ID: 2
  Type: NodeType.IF
  Expression: (balances[_who] == 0) || (last == 0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: wallets[_who].lastDividendPeriod = uint16(dividendPeriod)

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: last == dividendPeriod

  ID: 7
  Type: NodeType.RETURN
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: share = balances[_who] * 0xffffffff / totalSupply

  ID: 10
  Type: NodeType.VARIABLE
  Expression: balance = 0

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: last < dividendPeriod

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: balance += share * dividends[last]

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: last ++

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: balance = (balance / 0xffffffff)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: walletBalance += balance

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: wallets[_who].balance += uint208(balance)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: wallets[_who].lastDividendPeriod = uint16(last)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: LogDividend(_who,balance,last)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 13
  12 -> 16
  13 -> 14
  13 -> 12
  14 -> 15
  15 -> 13
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20

Function: betPrize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bethash = uint24(_player.betHash)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: hit = bethash ^ _hash

  ID: 4
  Type: NodeType.IF
  Expression: matches == 6

  ID: 5
  Type: NodeType.RETURN
  Expression: (uint256(_player.value) * 7000000)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: matches == 5

  ID: 8
  Type: NodeType.RETURN
  Expression: (uint256(_player.value) * 20000)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: matches == 4

  ID: 11
  Type: NodeType.RETURN
  Expression: (uint256(_player.value) * 500)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: matches == 3

  ID: 14
  Type: NodeType.RETURN
  Expression: (uint256(_player.value) * 25)

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: matches == 2

  ID: 17
  Type: NodeType.RETURN
  Expression: (uint256(_player.value) * 3)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: (0)

  ID: 20
  Type: NodeType.IF
  Expression: (hit & 0xF00000) == 0

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: matches = 1 + 1 + 1 + 1 + 1 + 1

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: matches = 0 + 0 + 0 + 0 + 0 + 0

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 20
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19
  20 -> 21
  20 -> 22
  21 -> 23
  22 -> 23
  23 -> 4

Function: betOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: player = bets[_who]

  ID: 2
  Type: NodeType.IF
  Expression: (player.value == 0) || (player.blockNum <= 1) || (block.number < player.blockNum) || (block.number >= player.blockNum + (10 * hashesSize))

  ID: 3
  Type: NodeType.RETURN
  Expression: (0)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: block.number < player.blockNum + 256

  ID: 6
  Type: NodeType.RETURN
  Expression: (betPrize(player,uint24(block.blockhash(player.blockNum))))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: hashFirst > 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: hash = getHash(player.blockNum)

  ID: 10
  Type: NodeType.IF
  Expression: hash == 0x1000000

  ID: 11
  Type: NodeType.RETURN
  Expression: (uint256(player.value))

  ID: 12
  Type: NodeType.RETURN
  Expression: (betPrize(player,uint24(hash)))

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.RETURN
  Expression: (0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  8 -> 14
  9 -> 10
  10 -> 11
  10 -> 12
  14 -> 15

Function: won
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: player = bets[msg.sender]

  ID: 2
  Type: NodeType.IF
  Expression: player.blockNum == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:0,betHash:0,blockNum:1})

  ID: 4
  Type: NodeType.RETURN
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: (player.value == 0) || (player.blockNum == 1)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: payWallet()

  ID: 8
  Type: NodeType.RETURN
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool)(block.number > player.blockNum)

  ID: 11
  Type: NodeType.IF
  Expression: player.blockNum + (10 * hashesSize) <= block.number

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: LogLate(msg.sender,player.blockNum,block.number)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:0,betHash:0,blockNum:1})

  ID: 14
  Type: NodeType.RETURN
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: prize = 0

  ID: 17
  Type: NodeType.VARIABLE
  Expression: hash = 0

  ID: 18
  Type: NodeType.IF
  Expression: block.number < player.blockNum + 256

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: hash = uint24(block.blockhash(player.blockNum))

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: prize = betPrize(player,uint24(hash))

  ID: 21
  Type: NodeType.IF
  Expression: hashFirst > 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: hash = getHash(player.blockNum)

  ID: 23
  Type: NodeType.IF
  Expression: hash == 0x1000000

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: LogLate(msg.sender,player.blockNum,block.number)

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:0,betHash:0,blockNum:1})

  ID: 26
  Type: NodeType.RETURN
  Expression: ()

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: prize = betPrize(player,uint24(hash))

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: LogLate(msg.sender,player.blockNum,block.number)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:0,betHash:0,blockNum:1})

  ID: 31
  Type: NodeType.RETURN
  Expression: ()

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:0,betHash:0,blockNum:1})

  ID: 35
  Type: NodeType.IF
  Expression: prize > 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: LogWin(msg.sender,uint256(player.betHash),uint256(hash),prize)

  ID: 37
  Type: NodeType.IF
  Expression: prize > maxWin

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: maxWin = prize

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: LogRecordWin(msg.sender,prize)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: pay(prize)

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: LogLoss(msg.sender,uint256(player.betHash),uint256(hash))

  ID: 43
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  5 -> 6
  6 -> 7
  6 -> 9
  7 -> 8
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  13 -> 14
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 21
  19 -> 20
  20 -> 33
  21 -> 22
  21 -> 29
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  25 -> 26
  27 -> 28
  28 -> 32
  29 -> 30
  30 -> 31
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  35 -> 42
  36 -> 37
  37 -> 38
  37 -> 40
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 43
  42 -> 43

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 2
  Type: NodeType.IF
  Expression: investStart > 1

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: invest(owner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: play()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: investStart == 0 && balances[msg.sender] > 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: commitDividend(msg.sender)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: won()

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11

Function: play
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: playSystem(uint256(keccak256()(msg.sender,block.number)),address(0))

Edges:
  0 -> 1

Function: playRandom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: playSystem(uint256(keccak256()(msg.sender,block.number)),_partner)

Edges:
  0 -> 1

Function: playSystem
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: won()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: bethash = uint24(_hash)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value <= 1000000000000000000 && msg.value < hashBetMax)

  ID: 4
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 5
  Type: NodeType.IF
  Expression: investStart == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: dividends[dividendPeriod] += msg.value / 20

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: _partner != address(0)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: fee = msg.value / 100

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: walletBalance += fee

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: wallets[_partner].balance += uint208(fee)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: hashNext < block.number + 3

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: hashNext = block.number + 3

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: hashBetSum = msg.value

  ID: 16
  Type: NodeType.IF
  Expression: hashBetSum > hashBetMax

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: hashNext ++

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: hashBetSum = msg.value

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: hashBetSum += msg.value

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: bets[msg.sender] = Bet({value:uint192(msg.value),betHash:uint32(bethash),blockNum:uint32(hashNext)})

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: LogBet(msg.sender,uint256(bethash),hashNext,msg.value)

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: putHashes(25)

  ID: 26
  Type: NodeType.RETURN
  Expression: (hashNext)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 24
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 12
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 16
  14 -> 15
  15 -> 21
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26

Function: addHashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: n = hashes.length

  ID: 3
  Type: NodeType.IF
  Expression: n + _sadd > hashesSize

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: hashes.length = hashesSize

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: hashes.length += _sadd

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: n < hashes.length

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: hashes[n] = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: n ++

  ID: 12
  Type: NodeType.IF
  Expression: hashes.length >= hashesSize

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: hashFirst = block.number - (block.number % 10)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: hashLast = hashFirst

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.RETURN
  Expression: (hashes.length)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 9
  8 -> 12
  9 -> 10
  9 -> 8
  10 -> 11
  11 -> 9
  12 -> 13
  12 -> 15
  13 -> 14
  14 -> 15
  15 -> 16

Function: addHashes128
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (addHashes(128))

Edges:
  0 -> 1

Function: calcHashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ((uint256(block.blockhash(_lastb)) & 0xFFFFFF) | ((uint256(block.blockhash(_lastb + 1)) & 0xFFFFFF) << 24) | ((uint256(block.blockhash(_lastb + 2)) & 0xFFFFFF) << 48) | ((uint256(block.blockhash(_lastb + 3)) & 0xFFFFFF) << 72) | ((uint256(block.blockhash(_lastb + 4)) & 0xFFFFFF) << 96) | ((uint256(block.blockhash(_lastb + 5)) & 0xFFFFFF) << 120) | ((uint256(block.blockhash(_lastb + 6)) & 0xFFFFFF) << 144) | ((uint256(block.blockhash(_lastb + 7)) & 0xFFFFFF) << 168) | ((uint256(block.blockhash(_lastb + 8)) & 0xFFFFFF) << 192) | ((uint256(block.blockhash(_lastb + 9)) & 0xFFFFFF) << 216) | ((uint256(_delta) / hashesSize) << 240))

Edges:
  0 -> 1

Function: getHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: delta = (_block - hashFirst) / 10

  ID: 2
  Type: NodeType.VARIABLE
  Expression: hash = hashes[delta % hashesSize]

  ID: 3
  Type: NodeType.IF
  Expression: delta / hashesSize != hash >> 240

  ID: 4
  Type: NodeType.RETURN
  Expression: (0x1000000)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: slotp = (_block - hashFirst) % 10

  ID: 7
  Type: NodeType.RETURN
  Expression: (uint32((hash >> (24 * slotp)) & 0xFFFFFF))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7

Function: putHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: lastb = hashLast

  ID: 2
  Type: NodeType.IF
  Expression: lastb == 0 || block.number <= lastb + 10

  ID: 3
  Type: NodeType.RETURN
  Expression: (false)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.IF
  Expression: block.number < 256

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: blockn256 = 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: blockn256 = block.number - 255

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: lastb < blockn256

  ID: 11
  Type: NodeType.VARIABLE
  Expression: num = blockn256

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: num += num % 10

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: lastb = num

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: delta = (lastb - hashFirst) / 10

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta))

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: hashLast = lastb + 10

  ID: 18
  Type: NodeType.RETURN
  Expression: (true)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 14
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18

Function: putHashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: n = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: n < _num

  ID: 5
  Type: NodeType.IF
  Expression: ! putHash()

  ID: 6
  Type: NodeType.RETURN
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: n ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  4 -> 5
  4 -> 3
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: walletBalance = 0

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: investStart = 1

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: investBalance = 0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: investBalanceGot = 0

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: investBalanceMax = 200000000000000000000000

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: dividendPeriod = 1

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: maxWin = 0

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashFirst = 0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashLast = 0

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashNext = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashBetSum = 0

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashBetMax = 5000000000000000000

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: coldStoreLast = 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = SmartBillions Token

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = PLAY

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: hashesSize = 16384

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


