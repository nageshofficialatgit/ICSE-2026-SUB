Contract: MultiChainBatcher
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: serviceFeeBP = 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _notEntered = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: paused = false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _calculateFeeNativeToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: whitelisted[msg.sender]

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (total * serviceFeeBP) / (10000 + serviceFeeBP)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _calculateFeeToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: whitelisted[msg.sender]

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (total * serviceFeeBP) / 10000

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes)(transferFrom(address,address,uint256))),sender,recipient,amount))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success && (data.length == 0 || abi.decode(data,(bool))),Token transferFrom failed)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes)(transfer(address,uint256))),recipient,amount))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success && (data.length == 0 || abi.decode(data,(bool))),Token transfer failed)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ContractPaused()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ContractUnpaused()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: batchNativeTokenTransferEqual
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = recipients.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(count > 0,No recipients)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value >= 5e14,Minimum 0.0005 native tokens required)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: feeAmount = _calculateFeeNativeToken(msg.value)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: distributionAmount = msg.value - feeAmount

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(distributionAmount % count == 0,Distribution amount not evenly divisible)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: amountEach = distributionAmount / count

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 12
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i]

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedWallet[recipient],Recipient blacklisted)

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = recipient.call{value: amountEach}()

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,Native token transfer failed)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: NativeTokenDistributed(msg.sender,distributionAmount,count,feeAmount)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: notBlacklistedCaller()

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 19
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 18
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 11
  19 -> 20
  20 -> 1

Function: batchNativeTokenTransferCustom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = recipients.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(count > 0 && count == amounts.length,Invalid input)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value >= 5e14,Minimum 0.0005 native tokens required)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: totalSend = 0

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: totalSend += amounts[i]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.value == totalSend + feeAmount,Incorrect native token amount sent)

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < count

  ID: 17
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i_scope_0]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedWallet[recipient],Recipient blacklisted)

  ID: 19
  Type: NodeType.VARIABLE
  Expression: amount = amounts[i_scope_0]

  ID: 20
  Type: NodeType.IF
  Expression: amount > 0

  ID: 21
  Type: NodeType.VARIABLE
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = recipient.call{value: amount}()

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,Native token transfer failed)

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ++ i_scope_0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: NativeTokenDistributed(msg.sender,totalSend,count,feeAmount)

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: notBlacklistedCaller()

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 29
  Type: NodeType.IF
  Expression: whitelisted[msg.sender]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: feeAmount = 0

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: feeAmount = (totalSend * serviceFeeBP) / 10000

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 27
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 29
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 8
  12 -> 15
  13 -> 16
  14 -> 26
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  20 -> 24
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 16
  27 -> 28
  28 -> 1
  29 -> 30
  29 -> 31
  30 -> 32
  31 -> 32
  32 -> 12

Function: batchTokenTransferEqual
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token != address(0),Token address cannot be zero)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedToken[token],Token blacklisted)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: count = recipients.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(count > 0,No recipients)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amountEach >= 1e14,Each token amount must be at least 0.0001 tokens)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: totalTransfer = amountEach * count

  ID: 7
  Type: NodeType.VARIABLE
  Expression: feeAmount = _calculateFeeToken(totalTransfer)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: _safeTransferFrom(token,msg.sender,address(this),totalTransfer + feeAmount)

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 12
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 13
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedWallet[recipient],Recipient blacklisted)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _safeTransfer(token,recipient,amountEach)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: TokenDistributed(msg.sender,token,totalTransfer,count,feeAmount)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: notBlacklistedCaller()

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 18
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 11
  9 -> 12
  10 -> 17
  11 -> 9
  12 -> 13
  12 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 12
  18 -> 19
  19 -> 1

Function: batchTokenTransferCustom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token != address(0),Token address cannot be zero)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedToken[token],Token blacklisted)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: count = recipients.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(count > 0 && count == amounts.length,Invalid input)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: totalTransfer = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[i] >= 1e14,Each token amount must be at least 0.0001 tokens)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: totalTransfer += amounts[i]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 13
  Type: NodeType.VARIABLE
  Expression: feeAmount = _calculateFeeToken(totalTransfer)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _safeTransferFrom(token,msg.sender,address(this),totalTransfer + feeAmount)

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 18
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < count

  ID: 19
  Type: NodeType.VARIABLE
  Expression: recipient = recipients[i_scope_0]

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedWallet[recipient],Recipient blacklisted)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: _safeTransfer(token,recipient,amounts[i_scope_0])

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ++ i_scope_0

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: TokenDistributed(msg.sender,token,totalTransfer,count,feeAmount)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: notBlacklistedCaller()

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 24
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 13
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 9
  13 -> 14
  14 -> 17
  15 -> 18
  16 -> 23
  17 -> 15
  18 -> 19
  18 -> 16
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 18
  24 -> 25
  25 -> 1

Function: getAllowances
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: len = owners.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowances = new uint256[](len)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < len

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: allowances[i] = IERC20(token).allowance(owners[i],spender)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: allowances

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: getTokenMetadata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: token.code.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.TRY
  Expression: sym = IERC20Metadata(token).symbol()

  ID: 5
  Type: NodeType.CATCH
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: symbol = sym

  ID: 7
  Type: NodeType.CATCH
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: symbol = 

  ID: 9
  Type: NodeType.TRY
  Expression: dec = IERC20Metadata(token).decimals()

  ID: 10
  Type: NodeType.CATCH
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: decimals = dec

  ID: 12
  Type: NodeType.CATCH
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: decimals = 0

  ID: 14
  Type: NodeType.RETURN
  Expression: (symbol,decimals)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  4 -> 9
  5 -> 6
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 12
  10 -> 11
  11 -> 14
  12 -> 13
  13 -> 14

Function: getWalletHoldingsPercentage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalSupply = IERC20(token).totalSupply()

  ID: 2
  Type: NodeType.IF
  Expression: totalSupply == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: combinedBalance = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < holders.length

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: combinedBalance += IERC20(token).balanceOf(holders[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: percentageBasisPoints = (combinedBalance * 10000) / totalSupply

  ID: 13
  Type: NodeType.RETURN
  Expression: percentageBasisPoints

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 12
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 9
  12 -> 13

Function: isSmartContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: addr.code.length > 0

Edges:
  0 -> 1

Function: batchTokenBalances
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokens.length > 0,Tokens array is empty)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(addresses.length > 0,Addresses array is empty)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: addrCount = addresses.length

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tokenCount = tokens.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances = new uint256[][](addrCount)

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < addrCount

  ID: 10
  Type: NodeType.VARIABLE
  Expression: addr = addresses[i]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(addr != address(0),Address is zero)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: addrBalances = new uint256[](tokenCount)

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: j < tokenCount

  ID: 17
  Type: NodeType.VARIABLE
  Expression: tokenAddr = tokens[j]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenAddr != address(0),Token address is zero)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenAddr.code.length > 0,Token address is not a contract)

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.VARIABLE
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: (success,data) = tokenAddr.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector,addr))

  ID: 23
  Type: NodeType.IF
  Expression: success && data.length >= 32

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: addrBalances[j] = abi.decode(data,(uint256))

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: addrBalances[j] = 0

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: ++ j

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: balances[i] = addrBalances

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 30
  Type: NodeType.RETURN
  Expression: balances

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 30
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 15
  13 -> 16
  14 -> 28
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 16
  28 -> 29
  29 -> 9

Function: batchNativeBalances
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(addresses.length > 0,Addresses array is empty)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: len = addresses.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances = new uint256[](len)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < len

  ID: 8
  Type: NodeType.VARIABLE
  Expression: addr = addresses[i]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(addr != address(0),Address is zero)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: balances[i] = addr.balance

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 12
  Type: NodeType.RETURN
  Expression: balances

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 12
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 7

Function: estimateBatchGasCost
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: estimatedGas = baseGas + perRecipientGas * numRecipients

  ID: 4
  Type: NodeType.IF
  Expression: isTokenTransfer

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: baseGas = 50000

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: baseGas = 21000

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: isTokenTransfer

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: perRecipientGas = 55000

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: perRecipientGas = 25000

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: estimatedGas

Edges:
  0 -> 4
  3 -> 12
  4 -> 5
  4 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 3

Function: setServiceFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(feeBasisPoints <= 10000,Fee too high)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: serviceFeeBP = feeBasisPoints

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ServiceFeeChanged(feeBasisPoints)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: addWhitelistedAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! whitelisted[account],Already whitelisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: whitelisted[account] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AddressWhitelisted(account)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: removeWhitelistedAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(whitelisted[account],Not whitelisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: whitelisted[account] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: AddressUnwhitelisted(account)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: blacklistToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedToken[token],Token already blacklisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: blacklistedToken[token] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TokenBlacklisted(token)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: removeBlacklistedToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(blacklistedToken[token],Token not blacklisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: blacklistedToken[token] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TokenRemovedFromBlacklist(token)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: blacklistWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! blacklistedWallet[wallet],Wallet already blacklisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: blacklistedWallet[wallet] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: WalletBlacklisted(wallet)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: removeBlacklistedWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(blacklistedWallet[wallet],Wallet not blacklisted)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: blacklistedWallet[wallet] = false

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: WalletRemovedFromBlacklist(wallet)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerOrModerator()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: getWhitelistedAddresses
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: whitelistedAddresses

Edges:
  0 -> 1

Function: getBlacklistedAddresses
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (blacklistedTokenAddresses,blacklistedWalletAddresses)

  ID: 2
  Type: NodeType.RETURN
  Expression: (blacklistedTokens,blacklistedWallets)

Edges:
  0 -> 1

Function: withdrawFees
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(to != address(0),Invalid recipient)

  ID: 2
  Type: NodeType.IF
  Expression: token == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount <= address(this).balance,Insufficient NATIVETOKEN)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (sent,None) = to.call{value: amount}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(sent,NATIVETOKEN withdraw failed)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: contractBalance = IERC20(token).balanceOf(address(this))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount <= contractBalance,Insufficient token balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _safeTransfer(token,to,amount)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: FeesWithdrawn(token,to,amount)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 13
  13 -> 1

Function: updateModerator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: moderator = newModerator

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ModeratorUpdated(newModerator)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),New owner cannot be zero)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnerChanged(newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Received(msg.sender,msg.value)

Edges:
  0 -> 1


Contract: IERC20
==================================================


Contract: IERC20Metadata
==================================================


