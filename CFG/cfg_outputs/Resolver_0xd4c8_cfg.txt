Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: INameWrapper
==================================================


Contract: ENS
==================================================


Contract: IERC20
==================================================


Contract: Verifier
==================================================


Contract: Resolver
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: url = _url

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < _signers.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: signers[_signers[i]] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: NewSigners(_signers)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Ownable(initialOwner)

Edges:
  0 -> 9
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  9 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: addChain
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(signers[msg.sender],Not a signer)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: verifierOf[chainId].ensverifier = l2Verifier

Edges:
  0 -> 1
  1 -> 2

Function: setDefaultStorage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(signers[msg.sender],Not a signer)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: defaultL2Chain = chain

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: defaultL2Storage = l2Contract

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setURL
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(signers[msg.sender],Not a signer)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: url = _url

Edges:
  0 -> 1
  1 -> 2

Function: setSigners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(signers[msg.sender],Not a signer)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < _signers.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: signers[_signers[i]] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: NewSigners(_signers)

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: decodeData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: functionSelector = mload(uint256)(callData + 0x20)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: callDataWithoutSelector = new bytes(callData.length - 4)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < callData.length - 4

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: callDataWithoutSelector[i] = callData[i + 4]

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.IF
  Expression: functionSelector == 0x3b3b57de || functionSelector == 0xbc1c58d1

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: (node) = abi.decode(callDataWithoutSelector,(bytes32))

  ID: 13
  Type: NodeType.IF
  Expression: functionSelector == 0xf1cb7e06

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: (node,None) = abi.decode(callDataWithoutSelector,(bytes32,uint256))

  ID: 15
  Type: NodeType.IF
  Expression: functionSelector == 0x59d1d43c

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (node,None) = abi.decode(callDataWithoutSelector,(bytes32,string))

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Record type not supported)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.RETURN
  Expression: (functionSelector,callDataWithoutSelector,node)

  ID: 22
  Type: NodeType.RETURN
  Expression: (functionSelector,callDataWithoutSelector,node)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 11
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 8
  11 -> 12
  11 -> 13
  12 -> 20
  13 -> 14
  13 -> 15
  14 -> 19
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21

Function: decodeNameAndComputeNamehashes
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: pos = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: labelsCount = 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: pos < input.length

  ID: 5
  Type: NodeType.VARIABLE
  Expression: length = uint8(input[pos])

  ID: 6
  Type: NodeType.IF
  Expression: length == 0

  ID: 7
  Type: NodeType.BREAK
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: pos += length + 1

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: labelsCount ++

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: pos = 0

  ID: 13
  Type: NodeType.VARIABLE
  Expression: labels = new string[](labelsCount)

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: labelIndex = 0

  ID: 17
  Type: NodeType.IFLOOP
  Expression: pos < input.length

  ID: 18
  Type: NodeType.VARIABLE
  Expression: length_scope_0 = uint8(input[pos])

  ID: 19
  Type: NodeType.IF
  Expression: length_scope_0 == 0

  ID: 20
  Type: NodeType.BREAK
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(length_scope_0 > 0 && length_scope_0 <= 63,Invalid length)

  ID: 23
  Type: NodeType.VARIABLE
  Expression: labelBytes = new bytes(length_scope_0)

  ID: 24
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 25
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 27
  Type: NodeType.IFLOOP
  Expression: i < length_scope_0

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: labelBytes[i] = input[pos + i + 1]

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: labels[labelIndex] = string(labelBytes)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: pos += length_scope_0 + 1

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: labelIndex ++

  ID: 34
  Type: NodeType.VARIABLE
  Expression: namehashes = new bytes32[](upperDomainCount)

  ID: 35
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 36
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 37
  Type: NodeType.VARIABLE
  Expression: i_scope_1 = 1

  ID: 38
  Type: NodeType.IFLOOP
  Expression: i_scope_1 < labelsCount - 1

  ID: 39
  Type: NodeType.VARIABLE
  Expression: domain = labels[i_scope_1]

  ID: 40
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 41
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 42
  Type: NodeType.VARIABLE
  Expression: j = i_scope_1 + 1

  ID: 43
  Type: NodeType.IFLOOP
  Expression: j < labelsCount

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: domain = string(abi.encodePacked(labels[j],.,domain))

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: namehashes[i_scope_1 - 1] = namehash(domain)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: i_scope_1 ++

  ID: 48
  Type: NodeType.RETURN
  Expression: namehashes

  ID: 49
  Type: NodeType.IF
  Expression: labelsCount > 1

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: upperDomainCount = labelsCount - 2

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: upperDomainCount = 0

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 11
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 4
  11 -> 12
  12 -> 13
  13 -> 16
  14 -> 17
  15 -> 49
  16 -> 14
  17 -> 18
  17 -> 15
  18 -> 19
  19 -> 20
  19 -> 21
  20 -> 15
  21 -> 22
  22 -> 23
  23 -> 26
  24 -> 27
  25 -> 30
  26 -> 24
  27 -> 28
  27 -> 25
  28 -> 29
  29 -> 27
  30 -> 31
  31 -> 32
  32 -> 17
  34 -> 37
  35 -> 38
  36 -> 48
  37 -> 35
  38 -> 39
  38 -> 36
  39 -> 42
  40 -> 43
  41 -> 46
  42 -> 40
  43 -> 44
  43 -> 41
  44 -> 45
  45 -> 43
  46 -> 47
  47 -> 38
  49 -> 50
  49 -> 51
  50 -> 52
  51 -> 52
  52 -> 34

Function: namehash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: node = 0x0000000000000000000000000000000000000000000000000000000000000000

  ID: 2
  Type: NodeType.IF
  Expression: bytes(name).length > 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: labels = splitLabels(name)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = labels.length

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i > 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: node = keccak256(bytes)(abi.encodePacked(node,keccak256(bytes)(abi.encodePacked(labels[i - 1]))))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: node

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 10
  3 -> 6
  4 -> 7
  5 -> 10
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 7
  10 -> 11

Function: splitLabels
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: labelCount = 1

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < bytes(name).length

  ID: 6
  Type: NodeType.IF
  Expression: bytes(name)[i] == .

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: labelCount ++

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.VARIABLE
  Expression: labels = new string[](labelCount)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: labelIndex = 0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: start = 0

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: i_scope_0 <= bytes(name).length

  ID: 17
  Type: NodeType.IF
  Expression: i_scope_0 == bytes(name).length || bytes(name)[i_scope_0] == .

  ID: 18
  Type: NodeType.VARIABLE
  Expression: labelBytes = new bytes(i_scope_0 - start)

  ID: 19
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 20
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 21
  Type: NodeType.VARIABLE
  Expression: j = 0

  ID: 22
  Type: NodeType.IFLOOP
  Expression: j < labelBytes.length

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: labelBytes[j] = bytes(name)[start + j]

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: j ++

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: labels[labelIndex ++] = string(labelBytes)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: start = i_scope_0 + 1

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 29
  Type: NodeType.RETURN
  Expression: labels

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 5
  10 -> 11
  11 -> 12
  12 -> 15
  13 -> 16
  14 -> 29
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 18
  17 -> 27
  18 -> 21
  19 -> 22
  20 -> 25
  21 -> 19
  22 -> 23
  22 -> 20
  23 -> 24
  24 -> 22
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 16

Function: findAuthorizedAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: namehashes = decodeNameAndComputeNamehashes(input)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < namehashes.length

  ID: 6
  Type: NodeType.VARIABLE
  Expression: authorized = ens.owner(namehashes[i])

  ID: 7
  Type: NodeType.IF
  Expression: authorized != address(0)

  ID: 8
  Type: NodeType.RETURN
  Expression: (authorized,namehashes[i])

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: (address(0),0x0000000000000000000000000000000000000000000000000000000000000000)

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 5

Function: resolve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (functionSelector,callDataWithoutSelector,None) = decodeData(data)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: authorized = context

  ID: 5
  Type: NodeType.VARIABLE
  Expression: callData = abi.encode(functionSelector,callDataWithoutSelector,authorized)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: urls = new string[](1)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: urls[0] = url

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert OffchainLookup(address,string[],bytes,bytes4,bytes)(address(this),urls,callData,Resolver.resolveWithProof.selector,callData)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: resolveWithProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (chainId,None,None,None,None,None,None) = abi.decode(response,(uint256,bytes,bytes32,bytes,bytes32,bytes32,bytes32))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: l2Verifier = verifierOf[chainId].ensverifier

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = Verifier(l2Verifier).resolveWithProof(response,extraData)

  ID: 5
  Type: NodeType.RETURN
  Expression: result

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceID == 0x9061b923 || interfaceID == 0xa0b7b54e

Edges:
  0 -> 1

Function: withdrawERC20
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: IERC20(tokenAddr).transfer(owner(),amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _to.transfer(address(this).balance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: getOperationHandler
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: revert OperationHandledOnchain(uint256,address)(defaultL2Chain,defaultL2Storage)

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e)

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: nameWrapper = INameWrapper(0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401)

Edges:
  0 -> 1


