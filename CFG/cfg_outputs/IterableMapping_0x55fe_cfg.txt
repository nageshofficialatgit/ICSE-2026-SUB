Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: DividendPayingTokenInterface
==================================================


Contract: DividendPayingTokenOptionalInterface
==================================================


Contract: IERC20
==================================================


Contract: IUniswapRouter01
==================================================


Contract: IUniswapRouter02
==================================================


Contract: IUniswapPair
==================================================


Contract: IUniswapFactory
==================================================


Contract: IterableMapping
==================================================

Function: get
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: map.values[key]

Edges:
  0 -> 1

Function: getIndexOfKey
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! map.inserted[key]

  ID: 2
  Type: NodeType.RETURN
  Expression: - 1

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: int256(map.indexOf[key])

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getKeyAtIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: map.keys[index]

Edges:
  0 -> 1

Function: size
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: map.keys.length

Edges:
  0 -> 1

Function: set
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: map.inserted[key]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: map.values[key] = val

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: map.inserted[key] = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: map.values[key] = val

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: map.indexOf[key] = map.keys.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: map.keys.push(key)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 7
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! map.inserted[key]

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: delete map.inserted[key]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: delete map.values[key]

  ID: 6
  Type: NodeType.VARIABLE
  Expression: index = map.indexOf[key]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: lastIndex = map.keys.length - 1

  ID: 8
  Type: NodeType.VARIABLE
  Expression: lastKey = map.keys[lastIndex]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: map.indexOf[lastKey] = index

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: delete map.indexOf[key]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: map.keys[index] = lastKey

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: map.keys.pop()

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENTERED = 2

Edges:
  0 -> 1


Contract: IERC20Errors
==================================================


Contract: IERC20Metadata
==================================================


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: ERC20
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

Edges:
  0 -> 1
  1 -> 2

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += value

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.IF
  Expression: fromBalance < value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientBalance(address,uint256,uint256)(from,fromBalance,value)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - value

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= value

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += value

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7


Contract: DividendPayingToken
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: RewardToken = _rewardToken

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ERC20(_name,_symbol)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Ownable(msg.sender)

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += value

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.IF
  Expression: fromBalance < value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientBalance(address,uint256,uint256)(from,fromBalance,value)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - value

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= value

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += value

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: RewardToken != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidRewardToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: distributeDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: totalSupply() == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__NoSupply()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: amount > 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendPerShare += (amount * magnitude) / totalSupply()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: DividendsDistributed(msg.sender,amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: totalDividendsDistributed += amount

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: withdrawDividend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _withdrawDividendOfUser(address(msg.sender))

Edges:
  0 -> 1

Function: _withdrawDividendOfUser
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _withdrawableDividend = withdrawableDividendOf(user)

  ID: 2
  Type: NodeType.IF
  Expression: _withdrawableDividend > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: withdrawnDividends[user] += _withdrawableDividend

  ID: 4
  Type: NodeType.IF
  Expression: RewardToken == address(0)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,None) = user.call{value: _withdrawableDividend}()

  ID: 7
  Type: NodeType.IF
  Expression: ! success

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: withdrawnDividends[user] -= _withdrawableDividend

  ID: 9
  Type: NodeType.RETURN
  Expression: 0

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: IERC20(RewardToken).transfer(user,_withdrawableDividend)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: DividendWithdrawn(user,_withdrawableDividend)

  ID: 14
  Type: NodeType.RETURN
  Expression: _withdrawableDividend

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 15
  3 -> 4
  4 -> 5
  4 -> 11
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  15 -> 16

Function: dividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: withdrawableDividendOf(_owner)

Edges:
  0 -> 1

Function: withdrawableDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: accumulativeDividendOf(_owner) - withdrawnDividends[_owner]

Edges:
  0 -> 1

Function: withdrawnDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: withdrawnDividends[_owner]

Edges:
  0 -> 1

Function: accumulativeDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: valCorrection = int256(magnifiedDividendPerShare * balanceOf(_owner))

  ID: 2
  Type: NodeType.IF
  Expression: valCorrection < 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: valCorrection += magnifiedDividendCorrections[_owner]

  ID: 6
  Type: NodeType.IF
  Expression: valCorrection < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionUnderflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: fullCorrection = uint256(valCorrection)

  ID: 10
  Type: NodeType.RETURN
  Expression: fullCorrection / magnitude

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10

Function: mintBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidAccount()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: super._update(address(0),account,value)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: magVal = int256(magnifiedDividendPerShare * value)

  ID: 6
  Type: NodeType.IF
  Expression: magVal < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendCorrections[account] -= magVal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9

Function: burnBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidAccount()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: super._update(account,address(0),value)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: magVal = int256(magnifiedDividendPerShare * value)

  ID: 6
  Type: NodeType.IF
  Expression: magVal < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendCorrections[account] += magVal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9

Function: _setBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentBalance = balanceOf(account)

  ID: 2
  Type: NodeType.IF
  Expression: newBalance > currentBalance

  ID: 3
  Type: NodeType.VARIABLE
  Expression: mintAmount = newBalance - currentBalance

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mintBalance(account,mintAmount)

  ID: 5
  Type: NodeType.IF
  Expression: newBalance < currentBalance

  ID: 6
  Type: NodeType.VARIABLE
  Expression: burnAmount = currentBalance - newBalance

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: burnBalance(account,burnAmount)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 9
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: magnitude = 2 ** 128

Edges:


Contract: DividendTracker
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: claimWait = 300

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: minimumTokenBalanceForDividends = minTokenHold

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: DividendPayingToken(allName,allName,_rewardToken)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: RewardToken != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidRewardToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: distributeDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: totalSupply() == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__NoSupply()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: amount > 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendPerShare += (amount * magnitude) / totalSupply()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: DividendsDistributed(msg.sender,amount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: totalDividendsDistributed += amount

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: withdrawDividend
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__WithdrawDisabled()()

Edges:
  0 -> 1

Function: _withdrawDividendOfUser
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _withdrawableDividend = withdrawableDividendOf(user)

  ID: 2
  Type: NodeType.IF
  Expression: _withdrawableDividend > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: withdrawnDividends[user] += _withdrawableDividend

  ID: 4
  Type: NodeType.IF
  Expression: RewardToken == address(0)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (success,None) = user.call{value: _withdrawableDividend}()

  ID: 7
  Type: NodeType.IF
  Expression: ! success

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: withdrawnDividends[user] -= _withdrawableDividend

  ID: 9
  Type: NodeType.RETURN
  Expression: 0

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: IERC20(RewardToken).transfer(user,_withdrawableDividend)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: DividendWithdrawn(user,_withdrawableDividend)

  ID: 14
  Type: NodeType.RETURN
  Expression: _withdrawableDividend

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 15
  3 -> 4
  4 -> 5
  4 -> 11
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  15 -> 16

Function: dividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: withdrawableDividendOf(_owner)

Edges:
  0 -> 1

Function: withdrawableDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: accumulativeDividendOf(_owner) - withdrawnDividends[_owner]

Edges:
  0 -> 1

Function: withdrawnDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: withdrawnDividends[_owner]

Edges:
  0 -> 1

Function: accumulativeDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: valCorrection = int256(magnifiedDividendPerShare * balanceOf(_owner))

  ID: 2
  Type: NodeType.IF
  Expression: valCorrection < 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: valCorrection += magnifiedDividendCorrections[_owner]

  ID: 6
  Type: NodeType.IF
  Expression: valCorrection < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionUnderflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: fullCorrection = uint256(valCorrection)

  ID: 10
  Type: NodeType.RETURN
  Expression: fullCorrection / magnitude

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10

Function: mintBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidAccount()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: super._update(address(0),account,value)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: magVal = int256(magnifiedDividendPerShare * value)

  ID: 6
  Type: NodeType.IF
  Expression: magVal < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendCorrections[account] -= magVal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9

Function: burnBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__InvalidAccount()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: super._update(account,address(0),value)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: magVal = int256(magnifiedDividendPerShare * value)

  ID: 6
  Type: NodeType.IF
  Expression: magVal < 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__DividendCorrectionOverflow()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: magnifiedDividendCorrections[account] += magVal

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9

Function: _setBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentBalance = balanceOf(account)

  ID: 2
  Type: NodeType.IF
  Expression: newBalance > currentBalance

  ID: 3
  Type: NodeType.VARIABLE
  Expression: mintAmount = newBalance - currentBalance

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mintBalance(account,mintAmount)

  ID: 5
  Type: NodeType.IF
  Expression: newBalance < currentBalance

  ID: 6
  Type: NodeType.VARIABLE
  Expression: burnAmount = currentBalance - newBalance

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: burnBalance(account,burnAmount)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 9
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 8
  8 -> 9

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _totalSupply += value

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fromBalance = _balances[from]

  ID: 4
  Type: NodeType.IF
  Expression: fromBalance < value

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientBalance(address,uint256,uint256)(from,fromBalance,value)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _balances[from] = fromBalance - value

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _totalSupply -= value

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _balances[to] += value

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: excludeFromDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: excludedFromDividends[account] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _setBalance(account,0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: tokenHoldersMap.remove(account)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ExcludeFromDividends(account)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateClaimWait
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newClaimWait < 60 || newClaimWait > 86400

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert DividendTracker__ClaimWaitOutOfRange()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ClaimWaitUpdated(newClaimWait,claimWait)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: claimWait = newClaimWait

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: getLastProcessedIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: lastProcessedIndex

Edges:
  0 -> 1

Function: getNumberOfTokenHolders
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: tokenHoldersMap.keys.length

Edges:
  0 -> 1

Function: getAccount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: account = _account

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: index = tokenHoldersMap.getIndexOfKey(account)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: iterationsUntilProcessed = - 1

  ID: 4
  Type: NodeType.IF
  Expression: index >= 0

  ID: 5
  Type: NodeType.IF
  Expression: uint256(index) > lastProcessedIndex

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: iterationsUntilProcessed = index - int256(lastProcessedIndex)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: iterationsUntilProcessed = index + int256(processesUntilEndOfArray)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: withdrawableDividends = withdrawableDividendOf(account)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: totalDividends = accumulativeDividendOf(account)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: lastClaimTime = lastClaimTimes[account]

  ID: 16
  Type: NodeType.IF
  Expression: tokenHoldersMap.keys.length > lastProcessedIndex

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: processesUntilEndOfArray = tokenHoldersMap.keys.length - lastProcessedIndex

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: processesUntilEndOfArray = 0

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.IF
  Expression: lastClaimTime > 0

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: nextClaimTime = lastClaimTime + claimWait

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: nextClaimTime = 0

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.IF
  Expression: nextClaimTime > block.timestamp

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: secondsUntilAutoClaimAvailable = nextClaimTime - block.timestamp

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: secondsUntilAutoClaimAvailable = 0

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.RETURN
  Expression: (account,index,iterationsUntilProcessed,withdrawableDividends,totalDividends,lastClaimTime,nextClaimTime,secondsUntilAutoClaimAvailable)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 10
  5 -> 6
  5 -> 16
  6 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 20
  16 -> 17
  16 -> 18
  17 -> 19
  18 -> 19
  19 -> 8
  20 -> 21
  20 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  25 -> 27
  26 -> 27
  27 -> 28

Function: getAccountAtIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: index >= tokenHoldersMap.size()

  ID: 2
  Type: NodeType.RETURN
  Expression: (0x0000000000000000000000000000000000000000,- 1,- 1,0,0,0,0,0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: account = tokenHoldersMap.getKeyAtIndex(index)

  ID: 5
  Type: NodeType.RETURN
  Expression: getAccount(account)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5

Function: canAutoClaim
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: lastClaimTime > block.timestamp

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: block.timestamp - (lastClaimTime) >= claimWait

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: setBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: excludedFromDividends[account]

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: newBalance >= minimumTokenBalanceForDividends

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _setBalance(account,newBalance)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: tokenHoldersMap.set(account,newBalance)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _setBalance(account,0)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenHoldersMap.remove(account)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: autoDistribute

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: processAccount(account,true)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 13
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  13 -> 1

Function: process
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: numberOfTokenHolders = tokenHoldersMap.keys.length

  ID: 2
  Type: NodeType.IF
  Expression: numberOfTokenHolders == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: (0,0,lastProcessedIndex)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _lastProcessedIndex = lastProcessedIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: gasUsed = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: gasLeft = gasleft()()

  ID: 8
  Type: NodeType.VARIABLE
  Expression: iterations = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: claims = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.IFLOOP
  Expression: gasUsed < gas && iterations < numberOfTokenHolders

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _lastProcessedIndex ++

  ID: 13
  Type: NodeType.IF
  Expression: _lastProcessedIndex >= tokenHoldersMap.keys.length

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _lastProcessedIndex = 0

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: account = tokenHoldersMap.keys[_lastProcessedIndex]

  ID: 17
  Type: NodeType.IF
  Expression: canAutoClaim(lastClaimTimes[account])

  ID: 18
  Type: NodeType.IF
  Expression: processAccount(address(account),true)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: claims ++

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: iterations ++

  ID: 23
  Type: NodeType.VARIABLE
  Expression: newGasLeft = gasleft()()

  ID: 24
  Type: NodeType.IF
  Expression: gasLeft > newGasLeft

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: gasUsed += gasLeft - newGasLeft

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: gasLeft = newGasLeft

  ID: 28
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: lastProcessedIndex = _lastProcessedIndex

  ID: 30
  Type: NodeType.RETURN
  Expression: (iterations,claims,lastProcessedIndex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 28
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 21
  18 -> 19
  18 -> 20
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 11
  28 -> 29
  29 -> 30

Function: processAccount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: amount = _withdrawDividendOfUser(account)

  ID: 2
  Type: NodeType.IF
  Expression: amount > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: lastClaimTimes[account] = block.timestamp

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: Claim(account,amount,automatic)

  ID: 5
  Type: NodeType.RETURN
  Expression: true

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: false

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  4 -> 5
  6 -> 7
  8 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: magnitude = 2 ** 128

Edges:


Contract: LegalXToken
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _marketingWalletAddress = _marketingWallet

  ID: 2
  Type: NodeType.VARIABLE
  Expression: TOTAL_SUPPLY = 1000000000000000000000000000

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dividendTracker = new DividendTracker(LEGALX_Tracker,TOTAL_SUPPLY / 100_000,address(this))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: swapTokensAtAmount = TOTAL_SUPPLY / 100_00

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _uniswapV2Router = IUniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: WETH = _uniswapV2Router.WETH()

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _uniswapV2Pair = IUniswapFactory(_uniswapV2Router.factory()).createPair(address(this),_uniswapV2Router.WETH())

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: uniswapV2Router = _uniswapV2Router

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: uniswapV2Pair = _uniswapV2Pair

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _setAutomatedMarketMakerPair(_uniswapV2Pair,true)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(address(dividendTracker))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(address(this))

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(deadWallet)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(address(_uniswapV2Router))

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: excludeFromFees(owner(),true)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: excludeFromFees(_marketingWalletAddress,true)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: excludeFromFees(address(this),true)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _mint(owner(),TOTAL_SUPPLY)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ERC20(LegalX,LEGAL)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: Ownable((msg.sender))

Edges:
  0 -> 19
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  19 -> 20
  20 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: decimals
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 18

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _totalSupply

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _balances[account]

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transfer(owner,to,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _allowances[owner][spender]

Edges:
  0 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _spendAllowance(from,spender,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(from,to,value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: from == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _update(from,to,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7

Function: _update
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: amount == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: super._update(from,to,0)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: contractTokenBalance = balanceOf(address(this))

  ID: 6
  Type: NodeType.VARIABLE
  Expression: canSwap = contractTokenBalance >= swapTokensAtAmount

  ID: 7
  Type: NodeType.VARIABLE
  Expression: takeFee = swapping == 1

  ID: 8
  Type: NodeType.VARIABLE
  Expression: isSwap = lpPairs[from] || lpPairs[to]

  ID: 9
  Type: NodeType.IF
  Expression: canSwap && takeFee && ! lpPairs[from] && from != owner() && to != owner() && from != address(dividendTracker) && to != address(dividendTracker)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: swapping <<= 1

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: swapAndProcessTokens(contractTokenBalance)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: swapping >>= 1

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: _isExcludedFromFees[from] || _isExcludedFromFees[to] || ! isSwap

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: takeFee = false

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.IF
  Expression: takeFee

  ID: 18
  Type: NodeType.VARIABLE
  Expression: allFees = (amount * totalFees) / PERCENTAGE

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: amount -= allFees

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: super._update(from,address(this),allFees)

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: super._update(from,to,amount)

  ID: 23
  Type: NodeType.TRY
  Expression: dividendTracker.setBalance(address(from),balanceOf(from),true)

  ID: 24
  Type: NodeType.CATCH
  Expression: 

  ID: 25
  Type: NodeType.CATCH
  Expression: 

  ID: 26
  Type: NodeType.TRY
  Expression: dividendTracker.setBalance(address(to),balanceOf(to),true)

  ID: 27
  Type: NodeType.CATCH
  Expression: 

  ID: 28
  Type: NodeType.CATCH
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: swapping == 1

  ID: 30
  Type: NodeType.VARIABLE
  Expression: gas = gasForProcessing

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: swapping <<= 1

  ID: 32
  Type: NodeType.TRY
  Expression: (iterations,claims,lastProcessedIndex) = dividendTracker.process(gas)

  ID: 33
  Type: NodeType.CATCH
  Expression: 

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: ProcessedDividendTracker(iterations,claims,lastProcessedIndex,true,gas,tx.origin)

  ID: 35
  Type: NodeType.CATCH
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: swapping >>= 1

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 21
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 25
  23 -> 26
  24 -> 26
  25 -> 26
  26 -> 27
  26 -> 28
  26 -> 29
  27 -> 29
  28 -> 29
  29 -> 30
  29 -> 37
  30 -> 31
  31 -> 32
  32 -> 33
  32 -> 35
  32 -> 36
  33 -> 34
  34 -> 36
  35 -> 36
  36 -> 37

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidReceiver(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(address(0),account,value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: account == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSender(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _update(account,address(0),value)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidApprover(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: spender == address(0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InvalidSpender(address)(address(0))

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _allowances[owner][spender] = value

  ID: 8
  Type: NodeType.IF
  Expression: emitEvent

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,spender,value)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10

Function: _spendAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = allowance(owner,spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance != type()(uint256).max

  ID: 3
  Type: NodeType.IF
  Expression: currentAllowance < value

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ERC20InsufficientAllowance(address,uint256,uint256)(spender,currentAllowance,value)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _approve(owner,spender,currentAllowance - value,false)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 7
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: updateDividendTracker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: newDividendTracker = DividendTracker(address(newAddress))

  ID: 2
  Type: NodeType.IF
  Expression: newDividendTracker.owner() != address(this)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__DividendTrackerOwnerMismatch()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: newDividendTracker.excludeFromDividends(address(newDividendTracker))

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: newDividendTracker.excludeFromDividends(address(this))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: newDividendTracker.excludeFromDividends(owner())

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: newDividendTracker.excludeFromDividends(address(uniswapV2Router))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: UpdateDividendTracker(newAddress,address(dividendTracker))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: dividendTracker = newDividendTracker

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 1

Function: excludeFromFees
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _isExcludedFromFees[account] = excluded

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ExcludeFromFees(account,excluded)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: excludeMultipleAccountsFromFees
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < accounts.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _isExcludedFromFees[accounts[i]] = excluded

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ExcludeMultipleAccountsFromFees(accounts,excluded)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 4
  2 -> 7
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 4
  8 -> 3

Function: setMarketingWallet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: wallet == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__InvalidMarketingWallet()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _marketingWalletAddress = wallet

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: setRewardTokenFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rewardTokenFee = value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalFees = rewardTokenFee + marketingFee

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setMarketingFee
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: marketingFee = value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalFees = rewardTokenFee + marketingFee

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setAutomatedMarketMakerPair
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: pair == uniswapV2Pair

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__CannotRemoveMainUniswapPair()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _setAutomatedMarketMakerPair(pair,value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _setAutomatedMarketMakerPair
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: lpPairs[pair] = value

  ID: 2
  Type: NodeType.IF
  Expression: value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(pair)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetAutomatedMarketMakerPair(pair,value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: updateGasForProcessing
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newValue < 200000 || newValue > 500000

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__GasForProcessingOutOfRange()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: GasForProcessingUpdated(newValue,gasForProcessing)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: gasForProcessing = newValue

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: updateClaimWait
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.updateClaimWait(claimWait)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: getClaimWait
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.claimWait()

Edges:
  0 -> 1

Function: getTotalDividendsDistributed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.totalDividendsDistributed()

Edges:
  0 -> 1

Function: isExcludedFromFees
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _isExcludedFromFees[account]

Edges:
  0 -> 1

Function: withdrawableDividendOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.withdrawableDividendOf(account)

Edges:
  0 -> 1

Function: dividendTokenBalanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.balanceOf(account)

Edges:
  0 -> 1

Function: excludeFromDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.excludeFromDividends(account)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: getAccountDividendsInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.getAccount(account)

Edges:
  0 -> 1

Function: getAccountDividendsInfoAtIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.getAccountAtIndex(index)

Edges:
  0 -> 1

Function: processDividendTracker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (iterations,claims,lastProcessedIndex) = dividendTracker.process(gas)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ProcessedDividendTracker(iterations,claims,lastProcessedIndex,false,gas,msg.sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: claim
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.processAccount(address(msg.sender),false)

Edges:
  0 -> 1

Function: getLastProcessedIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.getLastProcessedIndex()

Edges:
  0 -> 1

Function: getNumberOfDividendTokenHolders
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: dividendTracker.getNumberOfTokenHolders()

Edges:
  0 -> 1

Function: swapAndProcessTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: mktAmount = (contractBalance * marketingFee) / (marketingFee + rewardTokenFee)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: rewardAmount = contractBalance - mktAmount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _transfer(address(this),address(dividendTracker),rewardAmount)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: swapTokensForETH(mktAmount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: dividendTracker.distributeDividends(rewardAmount)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: SendDividends(contractBalance,rewardAmount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 1

Function: swapTokensForETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = new address[](2)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: path[0] = address(this)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path[1] = WETH

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _approve(address(this),address(uniswapV2Router),tokenAmount)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,address(this),block.timestamp)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: updateSwapTokensAtAmount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: maxAmount = totalSupply() / 100

  ID: 2
  Type: NodeType.IF
  Expression: newAmount > maxAmount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__SwapTokensAmountTooHigh()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SwapTokensAtAmountUpdated(newAmount,swapTokensAtAmount)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: swapTokensAtAmount = newAmount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 1

Function: withdrawMarketingFunds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.sender != _marketingWalletAddress && msg.sender != owner()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert LEGALX__InvalidMarketingWallet()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amount = address(this).balance

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,No funds to withdraw)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (success,None) = address(_marketingWalletAddress).call{value: amount}()

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,ETH transfer failed)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 9
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: rewardTokenFee = 2

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: marketingFee = 3

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalFees = 5

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: gasForProcessing = 300_000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: deadWallet = 0x000000000000000000000000000000000000dEaD

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: swapping = 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PERCENTAGE = 100

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_SWAP_PERCENTAGE = 1

Edges:
  0 -> 1


