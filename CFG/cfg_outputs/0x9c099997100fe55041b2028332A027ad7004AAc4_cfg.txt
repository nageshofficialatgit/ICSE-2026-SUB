Contract: SafeMath
==================================================

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: z = x + y

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)((z >= x) && (z >= y))

  ID: 3
  Type: NodeType.RETURN
  Expression: z

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(x >= y)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: z = x - y

  ID: 3
  Type: NodeType.RETURN
  Expression: z

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: z = x * y

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)((x == 0) || (z / x == y))

  ID: 3
  Type: NodeType.RETURN
  Expression: z

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Ownable
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1


Contract: Haltable
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: halt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: halted = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: unhalt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: halted = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyInEmergency()

Edges:
  0 -> 2
  2 -> 3
  3 -> 1


Contract: ERC20Basic
==================================================


Contract: ERC20
==================================================


Contract: BasicToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((_value == 0) || (allowed[msg.sender][_spender] == 0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1


Contract: DGZToken
==================================================

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)((_value == 0) || (allowed[msg.sender][_spender] == 0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: DGZToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = totalSupply

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalSupply = 100 * 100000000000000

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 8

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Dogezer DGZ Token

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = DGZ

Edges:
  0 -> 1


Contract: DogezerICOPrivateCrowdSale
==================================================

Function: halt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: halted = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: unhalt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: halted = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyInEmergency()

Edges:
  0 -> 2
  2 -> 3
  3 -> 1

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: DogezerICOPrivateCrowdSale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: beneficiary = addressOfBeneficiary

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: startTime = 1516021200

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: duration = 2678400

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: tokensContractBalance = 500000000000000

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: price = 5000000

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: discountPrice = 4500000

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tokenReward = DGZToken(addressOfTokenUsedAsReward)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value >= minPurchase)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(crowdsaleClosed == false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(tokensContractBalance > 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(whiteList[msg.sender] == true)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: currentPrice = price

  ID: 6
  Type: NodeType.IF
  Expression: balanceOf[msg.sender] == 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(tokenOwnerNumber < tokenOwnerNumberMax)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenOwnerNumber ++

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: msg.value >= discountValue

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: currentPrice = discountPrice

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: amountSendTokens = msg.value / currentPrice

  ID: 14
  Type: NodeType.IF
  Expression: amountSendTokens > tokensContractBalance

  ID: 15
  Type: NodeType.VARIABLE
  Expression: refund = msg.value - (tokensContractBalance * currentPrice)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: amountSendTokens = tokensContractBalance

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: msg.sender.transfer(refund)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: FundTransfer(msg.sender,refund,true)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] += (msg.value - refund)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: balanceOf[msg.sender] += msg.value

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: tokenReward.transfer(msg.sender,amountSendTokens)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: FundTransfer(msg.sender,amountSendTokens,true)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: tokensContractBalance -= amountSendTokens

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: stopInEmergency()

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: onlyAfterStart()

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: onlyBeforeEnd()

Edges:
  0 -> 25
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 9
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 20
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  25 -> 26
  26 -> 27
  27 -> 1

Function: joinWhiteList
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _address != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: whiteList[_address] = true

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  1 -> 3
  2 -> 3
  4 -> 1

Function: finalizeSale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(crowdsaleClosed == false)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: crowdsaleClosed = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: reopenSale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: crowdsaleClosed = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: setPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _price != 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: price = _price

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  1 -> 3
  2 -> 3
  4 -> 1

Function: setDiscount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _discountPrice != 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: discountPrice = _discountPrice

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  1 -> 3
  2 -> 3
  4 -> 1

Function: fundWithdrawal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: beneficiary.transfer(_amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: tokenWithdrawal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tokenReward.transfer(beneficiary,_amount)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tokensContractBalance -= _amount

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: changeBeneficiary
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _newBeneficiary != address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: beneficiary = _newBeneficiary

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  1 -> 3
  2 -> 3
  4 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Dogezer Private Sale ITO

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: crowdsaleClosed = false

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokenOwnerNumber = 0

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokenOwnerNumberMax = 120

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minPurchase = 25.0 * 1000000000000000000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: discountValue = 100.0 * 1000000000000000000

Edges:
  0 -> 1
  1 -> 2


