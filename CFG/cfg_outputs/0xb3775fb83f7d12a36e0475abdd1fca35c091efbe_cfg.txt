Contract: Hourglass
==================================================

Function: Hourglass
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: administrators[0xdd8bb99b13fe33e1c32254dfb8fff3e71193f6b730a89dd33bfe5dedc6d83002] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x8b4DA1827932D71759687f925D17F81Fc94e3A9D] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53] = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x7563A35d5610eE7c9CD330E255Da0e779a644C19] = true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x215e3C713BADb158A457e61f99325bBB5d278E57] = true

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0xaFF8B5CDCB339eEf5e1100597740a394C7B9c6cA] = true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x8dc6569c28521560EAF1890bC41b2F3FC2010E1b] = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0xf14BE3662FE4c9215c27698166759Db6967De94f] = true

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C] = true

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x49Aae4D923207e80Fc91E626BCb6532502264dfC] = true

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x3a0cca1A832644B60730E5D4c27947C5De609d62] = true

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C] = true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x2b219C2178f099dE4E9A3667d5cCc2cc64da0763] = true

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x2A04C7335f90a6bd4e9c4F713DD792200e27F2E6] = true

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x35668818ba8F768D4C21787a6f45C86C69394dfD] = true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0xa3120da52e604aC3Fc80A63813Ef15476e0B6AbD] = true

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x924E71bA600372e2410285423F1Fe66799b717EC] = true

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x6Ed450e062C20F929CB7Ee72fCc53e9697980a18] = true

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x18864A6682c8EB79EEA5B899F11bC94ef9a85ADb] = true

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x9cC1BdC994b7a847705D19106287C0BF94EF04B5] = true

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x6926572813ec1438088963f208C61847df435a74] = true

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0xE16Ab764a02Ae03681E351Ac58FE79717c0eE8C6] = true

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x276F4a79F22D1BfC51Bd8dc5b27Bfd934C823932] = true

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0xA2b4ed3E2f4beF09FB35101B76Ef4cB9D3eeCaCf] = true

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: ambassadors_[0x147fc6b04c95BCE47D013c8d7a200ee434323669] = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: buy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: purchaseTokens(msg.value,_referredBy)

Edges:
  0 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: purchaseTokens(msg.value,0x0)

Edges:
  0 -> 1

Function: reinvest
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _dividends = myDividends(false)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _dividends += referralBalance_[_customerAddress]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: referralBalance_[_customerAddress] = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _tokens = purchaseTokens(_dividends,0x0)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onReinvestment(_customerAddress,_dividends,_tokens)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyStronghands()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: exit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _tokens = tokenBalanceLedger_[_customerAddress]

  ID: 3
  Type: NodeType.IF
  Expression: _tokens > 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: sell(_tokens)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: withdraw()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _dividends = myDividends(false)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _dividends += referralBalance_[_customerAddress]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: referralBalance_[_customerAddress] = 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _customerAddress.transfer(_dividends)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onWithdraw(_customerAddress,_dividends)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyStronghands()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: sell
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_amountOfTokens <= tokenBalanceLedger_[_customerAddress])

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _tokens = _amountOfTokens

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _ethereum = tokensToEthereum_(_tokens)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.div(_ethereum,dividendFee_)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.sub(_ethereum,_dividends)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tokenSupply_ = SafeMath.sub(tokenSupply_,_tokens)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress],_tokens)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: _updatedPayouts = int256(profitPerShare_ * _tokens + (_taxedEthereum * magnitude))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_customerAddress] -= _updatedPayouts

  ID: 11
  Type: NodeType.IF
  Expression: tokenSupply_ > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: profitPerShare_ = SafeMath.add(profitPerShare_,(_dividends * magnitude) / tokenSupply_)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onTokenSell(_customerAddress,_tokens,_taxedEthereum)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: onlyBagholders()

Edges:
  0 -> 15
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  15 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress])

  ID: 3
  Type: NodeType.IF
  Expression: myDividends(true) > 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: withdraw()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _tokenFee = SafeMath.div(_amountOfTokens,dividendFee_)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _taxedTokens = SafeMath.sub(_amountOfTokens,_tokenFee)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: _dividends = tokensToEthereum_(_tokenFee)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tokenSupply_ = SafeMath.sub(tokenSupply_,_tokenFee)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress],_amountOfTokens)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress],_taxedTokens)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_customerAddress] -= int256(profitPerShare_ * _amountOfTokens)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_toAddress] += int256(profitPerShare_ * _taxedTokens)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: profitPerShare_ = SafeMath.add(profitPerShare_,(_dividends * magnitude) / tokenSupply_)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: Transfer(_customerAddress,_toAddress,_taxedTokens)

  ID: 16
  Type: NodeType.RETURN
  Expression: true

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: onlyBagholders()

Edges:
  0 -> 17
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  17 -> 1

Function: disableInitialStage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyAmbassadors = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAdministrator()

Edges:
  0 -> 2
  2 -> 1

Function: setAdministrator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: administrators[_identifier] = _status

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAdministrator()

Edges:
  0 -> 2
  2 -> 1

Function: setStakingRequirement
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: stakingRequirement = _amountOfTokens

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAdministrator()

Edges:
  0 -> 2
  2 -> 1

Function: setName
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: name = _name

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAdministrator()

Edges:
  0 -> 2
  2 -> 1

Function: setSymbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: symbol = _symbol

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyAdministrator()

Edges:
  0 -> 2
  2 -> 1

Function: totalEthereumBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: this.balance

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: tokenSupply_

Edges:
  0 -> 1

Function: myTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.RETURN
  Expression: balanceOf(_customerAddress)

Edges:
  0 -> 1
  1 -> 2

Function: myDividends
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 3
  Type: NodeType.IF
  Expression: _includeReferralBonus

  ID: 4
  Type: NodeType.RETURN
  Expression: dividendsOf(_customerAddress) + referralBalance_[_customerAddress]

  ID: 5
  Type: NodeType.RETURN
  Expression: dividendsOf(_customerAddress)

Edges:
  0 -> 1
  1 -> 3
  3 -> 4
  3 -> 5

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: tokenBalanceLedger_[_customerAddress]

Edges:
  0 -> 1

Function: dividendsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

Edges:
  0 -> 1

Function: sellPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenSupply_ == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: tokenPriceInitial_ - tokenPriceIncremental_

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _ethereum = tokensToEthereum_(1e18)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.div(_ethereum,dividendFee_)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.sub(_ethereum,_dividends)

  ID: 6
  Type: NodeType.RETURN
  Expression: _taxedEthereum

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: buyPrice
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tokenSupply_ == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: tokenPriceInitial_ + tokenPriceIncremental_

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _ethereum = tokensToEthereum_(1e18)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.div(_ethereum,dividendFee_)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.add(_ethereum,_dividends)

  ID: 6
  Type: NodeType.RETURN
  Expression: _taxedEthereum

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: calculateTokensReceived
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.div(_ethereumToSpend,dividendFee_)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.sub(_ethereumToSpend,_dividends)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _amountOfTokens = ethereumToTokens_(_taxedEthereum)

  ID: 4
  Type: NodeType.RETURN
  Expression: _amountOfTokens

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: calculateEthereumReceived
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokensToSell <= tokenSupply_)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _ethereum = tokensToEthereum_(_tokensToSell)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.div(_ethereum,dividendFee_)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.sub(_ethereum,_dividends)

  ID: 5
  Type: NodeType.RETURN
  Expression: _taxedEthereum

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: purchaseTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _customerAddress = msg.sender

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _undividedDividends = SafeMath.div(_incomingEthereum,dividendFee_)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _referralBonus = SafeMath.div(_undividedDividends,3)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _dividends = SafeMath.sub(_undividedDividends,_referralBonus)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _taxedEthereum = SafeMath.sub(_incomingEthereum,_undividedDividends)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _amountOfTokens = ethereumToTokens_(_taxedEthereum)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _fee = _dividends * magnitude

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_))

  ID: 9
  Type: NodeType.IF
  Expression: _referredBy != 0x0000000000000000000000000000000000000000 && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy],_referralBonus)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _dividends = SafeMath.add(_dividends,_referralBonus)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _fee = _dividends * magnitude

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: tokenSupply_ > 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: tokenSupply_ = SafeMath.add(tokenSupply_,_amountOfTokens)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: profitPerShare_ += (_dividends * magnitude / (tokenSupply_))

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / (tokenSupply_))))

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenSupply_ = _amountOfTokens

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress],_amountOfTokens)

  ID: 21
  Type: NodeType.VARIABLE
  Expression: _updatedPayouts = int256((profitPerShare_ * _amountOfTokens) - _fee)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: payoutsTo_[_customerAddress] += _updatedPayouts

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: onTokenPurchase(_customerAddress,_incomingEthereum,_amountOfTokens,_referredBy)

  ID: 24
  Type: NodeType.RETURN
  Expression: _amountOfTokens

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: antiEarlyWhale(_incomingEthereum)

Edges:
  0 -> 25
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 13
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 18
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  25 -> 1

Function: ethereumToTokens_
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _tokenPriceInitial = tokenPriceInitial_ * 1e18

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _tokensReceived = ((SafeMath.sub((sqrt((_tokenPriceInitial ** 2) + (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18)) + (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2)) + (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_))),_tokenPriceInitial)) / (tokenPriceIncremental_)) - (tokenSupply_)

  ID: 3
  Type: NodeType.RETURN
  Expression: _tokensReceived

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: tokensToEthereum_
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokens_ = (_tokens + 1e18)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _tokenSupply = (tokenSupply_ + 1e18)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _etherReceived = (SafeMath.sub((((tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))) - tokenPriceIncremental_) * (tokens_ - 1e18)),(tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2) / 1e18)

  ID: 4
  Type: NodeType.RETURN
  Expression: _etherReceived

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: sqrt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: z = (x + 1) / 2

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: y = x

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: z < y

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: y = z

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: z = (x / z + z) / 2

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: y

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 4
  7 -> 8

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = PowH3D

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = P3D

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: stakingRequirement = 100e18

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokenSupply_ = 0

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: onlyAmbassadors = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: dividendFee_ = 10

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokenPriceInitial_ = 100000000000

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokenPriceIncremental_ = 10000000000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: magnitude = 2 ** 64

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ambassadorMaxPurchase_ = 1000000000000000000

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ambassadorQuota_ = 20000000000000000000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c / a == b)

  ID: 6
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 2
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


