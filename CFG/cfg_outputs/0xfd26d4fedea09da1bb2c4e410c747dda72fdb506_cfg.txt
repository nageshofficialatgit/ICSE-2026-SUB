Contract: ERC20Basic
==================================================


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(token.transfer(to,value))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(token.transferFrom(from,to,value))

Edges:
  0 -> 1

Function: safeApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(token.approve(spender,value))

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

Edges:


Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c / a == b)

  ID: 6
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 2
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: cei
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ((a + b - 1) / b) * b

Edges:
  0 -> 1


Contract: BasicToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= balances[msg.sender])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1


Contract: ERC20
==================================================


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= balances[msg.sender])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 6
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_to != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= balances[_from])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= allowed[_from][msg.sender])

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

Edges:
  0 -> 1

Function: increaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldValue = allowed[msg.sender][_spender]

  ID: 2
  Type: NodeType.IF
  Expression: _subtractedValue > oldValue

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 7
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7


Contract: tokenRecipient
==================================================


Contract: VZToken
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: super.transferFrom(_from,_to,_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidAddress(_to)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidAddress(_from)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(_from)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(_to)

Edges:
  0 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 1

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

Edges:
  0 -> 1

Function: increaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 3
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: decreaseApproval
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldValue = allowed[msg.sender][_spender]

  ID: 2
  Type: NodeType.IF
  Expression: _subtractedValue > oldValue

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,allowed[msg.sender][_spender])

  ID: 7
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: super.transfer(_to,_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidAddress(_to)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(_to)

Edges:
  0 -> 2
  2 -> 3
  3 -> 4
  4 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: VZToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_owner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply = INITIAL_SUPPLY

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_owner] = INITIAL_SUPPLY - VECTORZILLA_RESERVE_VZT

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: balances[VECTORZILLA_RESERVE] = VECTORZILLA_RESERVE_VZT

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 1

Function: burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_value <= balances[msg.sender])

  ID: 2
  Type: NodeType.VARIABLE
  Expression: burner = msg.sender

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[burner] = balances[burner].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Burn(burner,_value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Transfer(burner,address(0x0),_value)

  ID: 7
  Type: NodeType.RETURN
  Expression: true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyWhenBurnable(_value)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(msg.sender)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 9
  9 -> 1

Function: burnFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(transferFrom(_from,msg.sender,_value))

  ID: 2
  Type: NodeType.RETURN
  Expression: burn(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyWhenBurnable(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(_from)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyWhenNotFrozen(msg.sender)

  ID: 6
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 5
  5 -> 1

Function: approveAndCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: spender = tokenRecipient(_spender)

  ID: 2
  Type: NodeType.IF
  Expression: approve(_spender,_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: spender.receiveApproval(msg.sender,_value,this,_extraData)

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidAddress(_spender)

  ID: 7
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  5 -> 7
  6 -> 1

Function: freezeAccount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: frozenAccount[target] = freeze

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: FrozenFunds(target,freeze)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: withdrawToOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(weiAmt > 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(weiAmt)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Withdraw(this,msg.sender,weiAmt)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: claimTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _token == 0x0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(this.balance)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: token = StandardToken(_token)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: balance = token.balanceOf(this)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: token.transfer(owner,balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Withdraw(this,owner,balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: setTokenSaleContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_tokenSaleContract != tokenSaleContract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tokenSaleContract = _tokenSaleContract

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidContractAddress(_tokenSaleContract)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _addr == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: (size > 0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: sendToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _from = owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[_from] >= _value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(balances[_to] + _value > balances[_to])

  ID: 4
  Type: NodeType.VARIABLE
  Expression: previousBalances = balances[_from] + balances[_to]

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: balances[_from] -= _value

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: balances[_to] += _value

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(balances[_from] + balances[_to] == previousBalances)

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: onlyWhenValidAddress(_to)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerAndContract()

Edges:
  0 -> 10
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  10 -> 11
  11 -> 1

Function: batchSendTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(addresses.length == _values.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(addresses.length <= 20)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.VARIABLE
  Expression: len = addresses.length

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < len

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: sendToken(addresses[i],_values[i])

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: true

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwnerAndContract()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 7
  6 -> 10
  7 -> 8
  7 -> 6
  8 -> 9
  9 -> 7
  11 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = VectorZilla Token

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = VZT

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: version = 1.0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: INITIAL_SUPPLY = 100000000 * 10 ** 18

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BURNABLE_UP_TO = 90000000 * 10 ** 18

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: VECTORZILLA_RESERVE_VZT = 25000000 * 10 ** 18

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: VECTORZILLA_RESERVE = 0xF63e65c57024886cCa65985ca6E2FB38df95dA11

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7


Contract: Pausable
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Pause()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpause()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: paused = false

Edges:
  0 -> 1


Contract: CanReclaimToken
==================================================

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: reclaimToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: token == 0x0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(this.balance)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: ecr20BasicToken = ERC20Basic(token)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: balance = ecr20BasicToken.balanceOf(this)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ecr20BasicToken.safeTransfer(owner,balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Withdraw(msg.sender,owner,balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

Edges:


Contract: HasNoTokens
==================================================

Function: reclaimToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: token == 0x0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(this.balance)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: ecr20BasicToken = ERC20Basic(token)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: balance = ecr20BasicToken.balanceOf(this)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ecr20BasicToken.safeTransfer(owner,balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Withdraw(msg.sender,owner,balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: tokenFallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: from_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: value_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: data_

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert()()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

Edges:


Contract: VZTPresale
==================================================

Function: tokenFallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: from_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: value_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: data_

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert()()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: reclaimToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: token == 0x0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner.transfer(this.balance)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: ecr20BasicToken = ERC20Basic(token)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: balance = ecr20BasicToken.balanceOf(this)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ecr20BasicToken.safeTransfer(owner,balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Withdraw(msg.sender,owner,balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: Ownable
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = msg.sender

Edges:
  0 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newOwner != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(masterOwner == msg.sender)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(owner,newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: pause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Pause()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: unpause
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: paused = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Unpause()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: whenPaused()

Edges:
  0 -> 3
  1 -> 2
  3 -> 4
  4 -> 1

Function: VZTPresale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_token != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_owner != address(0))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: token = VZToken(_token)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: doPayment(msg.sender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

Edges:
  0 -> 2
  2 -> 1

Function: payableInFiatEth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].paidFiat = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: purchasePresale(buyer,value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: setTokenContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(token != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: token = VZToken(_token)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: addToWhitelist
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addr != address(0))

  ID: 2
  Type: NodeType.IF
  Expression: ! whitelist[_addr]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: whitelist[_addr] = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: numWhitelisted ++

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[_addr].kycApproved = true

  ID: 7
  Type: NodeType.RETURN
  Expression: true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: addManyToWhitelist
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addresses.length <= 50)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: idx = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: len = _addresses.length

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: idx < len

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _addr = _addresses[idx]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: addToWhitelist(_addr)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: idx ++

  ID: 10
  Type: NodeType.RETURN
  Expression: true

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  5 -> 10
  6 -> 7
  6 -> 5
  7 -> 8
  8 -> 9
  9 -> 6
  11 -> 1

Function: removeFomWhitelist
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_addr != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(whitelist[_addr])

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: delete whitelist[_addr]

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[_addr].kycApproved = false

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: numWhitelisted --

  ID: 6
  Type: NodeType.RETURN
  Expression: true

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  7 -> 1

Function: sendTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_user != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(_user != address(this))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(purchaseLog[_user].kycApproved)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(purchaseLog[_user].vztValue > 0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! purchaseLog[_user].tokensDistributed)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! refundLog[_user])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[_user].tokensDistributed = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[_user].lastDistributionTime = now

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: totalDistributed ++

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: token.sendToken(_user,purchaseLog[_user].vztValue)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: TokenDistributed(_user,purchaseLog[_user].vztValue)

  ID: 12
  Type: NodeType.RETURN
  Expression: true

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 13
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  13 -> 1

Function: refundEthIfKYCNotVerified
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! purchaseLog[_user].kycApproved

  ID: 2
  Type: NodeType.RETURN
  Expression: doRefund(_user)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: false

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  3 -> 4
  5 -> 1

Function: isWhitelisted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: whitelist[buyer]

Edges:
  0 -> 1

Function: isPresale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ! isFinalized && now >= startDate && now <= endDate

Edges:
  0 -> 1

Function: hasSoldOut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PRESALE_TOKEN_HARD_CAP - tokensSold < getMinimumPurchaseVZTLimit()

Edges:
  0 -> 1

Function: hasEnded
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: now > endDate || hasSoldOut()

Edges:
  0 -> 1

Function: isMinimumGoalReached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: totalCollected >= MIN_FUNDING_GOAL

Edges:
  0 -> 1

Function: getSoftCapReached
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: publicSoftCapReached

Edges:
  0 -> 1

Function: setMinimumPurchaseEtherLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newMinimumPurchaseLimit > 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: minimumPurchaseLimit = newMinimumPurchaseLimit

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: getMinimumPurchaseVZTLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getTier() == 1

  ID: 2
  Type: NodeType.RETURN
  Expression: minimumPurchaseLimit.mul(PRESALE_RATE)

  ID: 3
  Type: NodeType.IF
  Expression: getTier() == 2

  ID: 4
  Type: NodeType.RETURN
  Expression: minimumPurchaseLimit.mul(SOFTCAP_RATE)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: minimumPurchaseLimit.mul(1000)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7

Function: getTier
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tier = 1

  ID: 2
  Type: NodeType.IF
  Expression: now >= startDate && now < endDate && getSoftCapReached()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: tier = 2

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: tier

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: getPresaleStatus
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: now < startDate

  ID: 2
  Type: NodeType.RETURN
  Expression: ((0,startDate,endDate))

  ID: 3
  Type: NodeType.IF
  Expression: now <= endDate && ! hasEnded()

  ID: 4
  Type: NodeType.RETURN
  Expression: ((1,startDate,endDate))

  ID: 5
  Type: NodeType.RETURN
  Expression: ((2,startDate,endDate))

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5

Function: finalize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! isFinalized)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(hasEnded())

  ID: 3
  Type: NodeType.IF
  Expression: isMinimumGoalReached()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: VZT_WALLET.transfer(this.balance)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: FundsTransferred()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: isFinalized = true

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Finalized()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 6
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 1

Function: proxyPayment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: doPayment(buyer)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: whenNotPaused()

  ID: 3
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 2
  2 -> 1

Function: setDates
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(newEndDate >= newStartDate)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: startDate = newStartDate

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: endDate = newEndDate

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: doPayment
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(tx.gasprice <= MAX_GAS_PRICE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(buyer != address(0))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! isContract(buyer))

  ID: 4
  Type: NodeType.IF
  Expression: msg.sender != owner

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(isPresale())

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! hasSoldOut())

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value >= minimumPurchaseLimit)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool)(msg.value > 0)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: purchasePresale(buyer,msg.value)

  ID: 11
  Type: NodeType.RETURN
  Expression: true

  ID: 12
  Type: NodeType.RETURN
  Expression: success

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _addr == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: false

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.RETURN
  Expression: (size > 0)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: purchasePresale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(value >= minimumPurchaseLimit)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(buyer != address(0))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: tokens = 0

  ID: 4
  Type: NodeType.IF
  Expression: ! publicSoftCapReached

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tokens = value * PRESALE_RATE

  ID: 6
  Type: NodeType.IF
  Expression: tokensSold + tokens > PRESALE_TOKEN_SOFT_CAP

  ID: 7
  Type: NodeType.VARIABLE
  Expression: availablePresaleTokens = PRESALE_TOKEN_SOFT_CAP - tokensSold

  ID: 8
  Type: NodeType.VARIABLE
  Expression: softCapTokens = (value - (availablePresaleTokens / PRESALE_RATE)) * SOFTCAP_RATE

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tokens = availablePresaleTokens + softCapTokens

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: processSale(buyer,value,tokens,SOFTCAP_RATE)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: publicSoftCapReached = true

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: SoftCapReached()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: processSale(buyer,value,tokens,PRESALE_RATE)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: tokens = value * SOFTCAP_RATE

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: processSale(buyer,value,tokens,SOFTCAP_RATE)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 15
  5 -> 6
  6 -> 7
  6 -> 13
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 14
  13 -> 14
  14 -> 17
  15 -> 16
  16 -> 17

Function: processSale
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(buyer != address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(vzt > 0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(vztRate > 0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool)(value > 0)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: vztOver = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: excessEthInWei = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: paidValue = value

  ID: 8
  Type: NodeType.VARIABLE
  Expression: purchasedVzt = vzt

  ID: 9
  Type: NodeType.IF
  Expression: tokensSold + purchasedVzt > PRESALE_TOKEN_HARD_CAP

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: vztOver = tokensSold + purchasedVzt - PRESALE_TOKEN_HARD_CAP

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: excessEthInWei = vztOver / vztRate

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: purchasedVzt = purchasedVzt - vztOver

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: paidValue = paidValue - excessEthInWei

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: purchaseLog[buyer].vztValue == 0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: buyers.push(buyer)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: buyerCount ++

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: ! isWhitelisted(buyer)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].kycApproved = false

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: refundLog[buyer] = false

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].vztValue = SafeMath.add(purchaseLog[buyer].vztValue,purchasedVzt)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].ethValue = SafeMath.add(purchaseLog[buyer].ethValue,paidValue)

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].lastPurchaseTime = now

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: totalCollected += paidValue

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: tokensSold += purchasedVzt

  ID: 28
  Type: NodeType.VARIABLE
  Expression: beneficiary = buyer

  ID: 29
  Type: NodeType.IF
  Expression: beneficiary == msg.sender

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: beneficiary = msg.sender

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: TokenPurchase(buyer,beneficiary,paidValue,purchasedVzt)

  ID: 33
  Type: NodeType.IF
  Expression: excessEthInWei > 0 && ! purchaseLog[buyer].paidFiat

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: buyer.transfer(excessEthInWei)

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: Refunded(buyer,excessEthInWei)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 14
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 18
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  33 -> 36
  34 -> 35
  35 -> 36

Function: distributeTokensFor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(isFinalized)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(hasEnded())

  ID: 3
  Type: NodeType.IF
  Expression: isMinimumGoalReached()

  ID: 4
  Type: NodeType.RETURN
  Expression: sendTokens(buyer)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: false

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  7 -> 1

Function: claimRefund
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: doRefund(msg.sender)

Edges:
  0 -> 1

Function: sendRefund
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: doRefund(buyer)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: doRefund
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool)(tx.gasprice <= MAX_GAS_PRICE)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool)(buyer != address(0))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! purchaseLog[buyer].paidFiat)

  ID: 4
  Type: NodeType.IF
  Expression: msg.sender != owner

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool)(isFinalized && ! isMinimumGoalReached())

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool)(purchaseLog[buyer].ethValue > 0)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool)(purchaseLog[buyer].vztValue > 0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! refundLog[buyer])

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool)(! purchaseLog[buyer].tokensDistributed)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: depositedValue = purchaseLog[buyer].ethValue

  ID: 12
  Type: NodeType.VARIABLE
  Expression: vztValue = purchaseLog[buyer].vztValue

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].ethValue = 0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: purchaseLog[buyer].vztValue = 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: refundLog[buyer] = true

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: delete purchaseLog[buyer]

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: tokensSold = tokensSold.sub(vztValue)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: totalCollected = totalCollected.sub(depositedValue)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: buyer.transfer(depositedValue)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: Refunded(buyer,depositedValue)

  ID: 21
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21

Function: getBuyersList
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: buyers

Edges:
  0 -> 1

Function: reclaimEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(owner.send(this.balance))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: masterOwner = 0xe4925C73851490401b858B657F26E62e9aD20F66

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: paused = false

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: minimumPurchaseLimit = 0.1 * 10 ** 18

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: startDate = 1516001400

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: endDate = 1517815800

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalCollected = 0

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: tokensSold = 0

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalDistributed = 0

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: numWhitelisted = 0

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: buyerCount = 0

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: isFinalized = false

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: publicSoftCapReached = false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = VectorZilla Public Presale

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: version = 1.0

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: VZT_WALLET = 0xa50EB7D45aA025525254aB2452679cE888B16b86

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MIN_FUNDING_GOAL = 200 * 10 ** 18

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PRESALE_TOKEN_SOFT_CAP = 1875000 * 10 ** 18

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PRESALE_RATE = 1250

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SOFTCAP_RATE = 1150

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PRESALE_TOKEN_HARD_CAP = 5900000 * 10 ** 18

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_GAS_PRICE = 50000000000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8


