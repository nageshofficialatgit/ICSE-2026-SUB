Contract: IERC721A
==================================================


Contract: ERC721A__IERC721Receiver
==================================================


Contract: ERC721A
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = _startTokenId()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _burnCounter - _startTokenId()

Edges:
  0 -> 1

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _startTokenId()

Edges:
  0 -> 1

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert BalanceQueryForZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert URIQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: curr = tokenId

  ID: 2
  Type: NodeType.IF
  Expression: _startTokenId() <= curr

  ID: 3
  Type: NodeType.IF
  Expression: curr < _currentIndex

  ID: 4
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[curr]

  ID: 5
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: packed == 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- curr]

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: packed

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert OwnerQueryForNonexistentToken()()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  3 -> 12
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13
  13 -> 14

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalCallerNotOwnerNorApproved()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _startTokenId() <= tokenId && tokenId < _currentIndex && _packedOwnerships[tokenId] & _BITMASK_BURNED == 0

Edges:
  0 -> 1

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert TransferFromIncorrectOwner()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 8
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert TransferToZeroAddress()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 25
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 26
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 27
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 28
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,tokenId)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 20
  18 -> 19
  19 -> 21
  20 -> 19
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 32
  26 -> 27
  27 -> 28
  27 -> 31
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: toMasked = to & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,startTokenId)

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = startTokenId + 1

  ID: 17
  Type: NodeType.IFLOOP
  Expression: ! tokenId__mint_asm_0 == end

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId__mint_asm_0)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = tokenId__mint_asm_0 + 1

  ID: 20
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 20
  15 -> 16
  16 -> 17
  17 -> 14
  17 -> 18
  18 -> 19
  19 -> 17
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert MintERC2309QuantityExceedsLimit()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert OwnershipNotInitializedForExtraData()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_MINTED = 64

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NUMBER_BURNED = 128

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_AUX = 192

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_START_TIMESTAMP = 160

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_BURNED = 1 << 224

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_NEXT_INITIALIZED = 225

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_NEXT_INITIALIZED = 1 << 225

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITPOS_EXTRA_DATA = 232

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _BITMASK_ADDRESS = (1 << 160) - 1

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13


Contract: IERC721AQueryable
==================================================


Contract: IERC721L
==================================================


Contract: ERC721AQueryable
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _name = name_

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _symbol = symbol_

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = _startTokenId()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _burnCounter - _startTokenId()

Edges:
  0 -> 1

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _startTokenId()

Edges:
  0 -> 1

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert BalanceQueryForZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert URIQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _baseURI()

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId)))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: curr = tokenId

  ID: 2
  Type: NodeType.IF
  Expression: _startTokenId() <= curr

  ID: 3
  Type: NodeType.IF
  Expression: curr < _currentIndex

  ID: 4
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[curr]

  ID: 5
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: packed == 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- curr]

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: packed

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert OwnerQueryForNonexistentToken()()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  3 -> 12
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13
  13 -> 14

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalCallerNotOwnerNorApproved()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _startTokenId() <= tokenId && tokenId < _currentIndex && _packedOwnerships[tokenId] & _BITMASK_BURNED == 0

Edges:
  0 -> 1

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert TransferFromIncorrectOwner()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 8
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert TransferToZeroAddress()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 25
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 26
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 27
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 28
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,tokenId)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 20
  18 -> 19
  19 -> 21
  20 -> 19
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 32
  26 -> 27
  27 -> 28
  27 -> 31
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: toMasked = to & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,startTokenId)

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = startTokenId + 1

  ID: 17
  Type: NodeType.IFLOOP
  Expression: ! tokenId__mint_asm_0 == end

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId__mint_asm_0)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = tokenId__mint_asm_0 + 1

  ID: 20
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 20
  15 -> 16
  16 -> 17
  17 -> 14
  17 -> 18
  18 -> 19
  19 -> 17
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert MintERC2309QuantityExceedsLimit()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert OwnershipNotInitializedForExtraData()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: explicitOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: tokenId < _startTokenId() || tokenId >= _nextTokenId()

  ID: 3
  Type: NodeType.RETURN
  Expression: ownership

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 7
  Type: NodeType.RETURN
  Expression: ownership

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.RETURN
  Expression: _ownershipOf(tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9

Function: explicitOwnershipsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenIdsLength = tokenIds.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: ownerships = new IERC721A.TokenOwnership[](tokenIdsLength)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i != tokenIdsLength

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ownerships[i] = explicitOwnershipOf(tokenIds[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 9
  Type: NodeType.RETURN
  Expression: ownerships

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= stop

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidQueryRange()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stopLimit = _nextTokenId()

  ID: 6
  Type: NodeType.IF
  Expression: start < _startTokenId()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: start = _startTokenId()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: stop > stopLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stop = stopLimit

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: tokenIdsMaxLength = balanceOf(owner)

  ID: 13
  Type: NodeType.IF
  Expression: start < stop

  ID: 14
  Type: NodeType.VARIABLE
  Expression: rangeLength = stop - start

  ID: 15
  Type: NodeType.IF
  Expression: rangeLength < tokenIdsMaxLength

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = rangeLength

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = 0

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: tokenIds = new uint256[](tokenIdsMaxLength)

  ID: 21
  Type: NodeType.IF
  Expression: tokenIdsMaxLength == 0

  ID: 22
  Type: NodeType.RETURN
  Expression: tokenIds

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(start)

  ID: 25
  Type: NodeType.VARIABLE
  Expression: 

  ID: 26
  Type: NodeType.IF
  Expression: ! ownership.burned

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 30
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: i = start

  ID: 32
  Type: NodeType.IFLOOP
  Expression: i != stop && tokenIdsIdx != tokenIdsMaxLength

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(i)

  ID: 34
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 35
  Type: NodeType.CONTINUE
  Expression: 

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: ownership.addr != address(0)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.IF
  Expression: currOwnershipAddr == owner

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: tokenIds[tokenIdsIdx ++] = i

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 44
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds,tokenIdsIdx)

  ID: 46
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 47
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 31
  29 -> 32
  30 -> 44
  31 -> 29
  32 -> 33
  32 -> 30
  33 -> 34
  34 -> 35
  34 -> 36
  35 -> 43
  36 -> 37
  37 -> 38
  37 -> 39
  38 -> 39
  39 -> 40
  40 -> 41
  40 -> 42
  41 -> 42
  42 -> 43
  43 -> 32
  44 -> 45
  45 -> 46
  46 -> 47

Function: tokensOfOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: tokenIdsLength = balanceOf(owner)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tokenIds = new uint256[](tokenIdsLength)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = _startTokenId()

  ID: 9
  Type: NodeType.IFLOOP
  Expression: tokenIdsIdx != tokenIdsLength

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(i)

  ID: 11
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 12
  Type: NodeType.CONTINUE
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: ownership.addr != address(0)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.IF
  Expression: currOwnershipAddr == owner

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIds[tokenIdsIdx ++] = i

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 21
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 21
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 20
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 9


Contract: MerkleProof
==================================================

Function: verify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProof(proof,leaf) == root

Edges:
  0 -> 1

Function: verifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProofCalldata(proof,leaf) == root

Edges:
  0 -> 1

Function: processProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = _hashPair(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: processProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = _hashPair(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: multiProofVerify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProof(proof,proofFlags,leaves) == root

Edges:
  0 -> 1

Function: multiProofVerifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProofCalldata(proof,proofFlags,leaves) == root

Edges:
  0 -> 1

Function: processMultiProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: totalHashes = proofFlags.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(leavesLen + proof.length - 1 == totalHashes,MerkleProof: invalid multiproof)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](totalHashes)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < totalHashes

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = _hashPair(a,b)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.IF
  Expression: totalHashes > 0

  ID: 17
  Type: NodeType.RETURN
  Expression: hashes[totalHashes - 1]

  ID: 18
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 19
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 20
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 23
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 16
  10 -> 8
  11 -> 23
  11 -> 9
  14 -> 15
  15 -> 11
  16 -> 17
  16 -> 18
  18 -> 19
  18 -> 20
  23 -> 24
  23 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 31
  27 -> 29
  29 -> 30
  30 -> 14
  31 -> 32
  31 -> 33
  32 -> 34
  33 -> 34
  34 -> 30

Function: processMultiProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: totalHashes = proofFlags.length

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(leavesLen + proof.length - 1 == totalHashes,MerkleProof: invalid multiproof)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](totalHashes)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < totalHashes

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = _hashPair(a,b)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 16
  Type: NodeType.IF
  Expression: totalHashes > 0

  ID: 17
  Type: NodeType.RETURN
  Expression: hashes[totalHashes - 1]

  ID: 18
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 19
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 20
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 23
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 16
  10 -> 8
  11 -> 23
  11 -> 9
  14 -> 15
  15 -> 11
  16 -> 17
  16 -> 18
  18 -> 19
  18 -> 20
  23 -> 24
  23 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 31
  27 -> 29
  29 -> 30
  30 -> 14
  31 -> 32
  31 -> 33
  32 -> 34
  33 -> 34
  34 -> 30

Function: _hashPair
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: _efficientHash(a,b)

  ID: 4
  Type: NodeType.RETURN
  Expression: _efficientHash(b,a)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: _efficientHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,a)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,b)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = keccak256(uint256,uint256)(0x00,0x40)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ENTERED = 2

Edges:
  0 -> 1


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(_msgSender())

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: PEPUL
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _mintStages.push(MintStageInfo({cost:2500000000000000,walletLimit:2000,merkleRoot:0x0,maxStageSupply:0,startTimeUnixSeconds:1742803205,endTimeUnixSeconds:1748678405}))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ERC721A(Pepul World,PEPUL)

Edges:
  0 -> 2
  2 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

Edges:
  0 -> 1

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: explicitOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: tokenId < _startTokenId() || tokenId >= _nextTokenId()

  ID: 3
  Type: NodeType.RETURN
  Expression: ownership

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 7
  Type: NodeType.RETURN
  Expression: ownership

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.RETURN
  Expression: _ownershipOf(tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  8 -> 9

Function: explicitOwnershipsOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenIdsLength = tokenIds.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: ownerships = new IERC721A.TokenOwnership[](tokenIdsLength)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i != tokenIdsLength

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ownerships[i] = explicitOwnershipOf(tokenIds[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 9
  Type: NodeType.RETURN
  Expression: ownerships

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: tokensOfOwnerIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= stop

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidQueryRange()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stopLimit = _nextTokenId()

  ID: 6
  Type: NodeType.IF
  Expression: start < _startTokenId()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: start = _startTokenId()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: stop > stopLimit

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stop = stopLimit

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: tokenIdsMaxLength = balanceOf(owner)

  ID: 13
  Type: NodeType.IF
  Expression: start < stop

  ID: 14
  Type: NodeType.VARIABLE
  Expression: rangeLength = stop - start

  ID: 15
  Type: NodeType.IF
  Expression: rangeLength < tokenIdsMaxLength

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = rangeLength

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIdsMaxLength = 0

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: tokenIds = new uint256[](tokenIdsMaxLength)

  ID: 21
  Type: NodeType.IF
  Expression: tokenIdsMaxLength == 0

  ID: 22
  Type: NodeType.RETURN
  Expression: tokenIds

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.VARIABLE
  Expression: ownership = explicitOwnershipOf(start)

  ID: 25
  Type: NodeType.VARIABLE
  Expression: 

  ID: 26
  Type: NodeType.IF
  Expression: ! ownership.burned

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 30
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: i = start

  ID: 32
  Type: NodeType.IFLOOP
  Expression: i != stop && tokenIdsIdx != tokenIdsMaxLength

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(i)

  ID: 34
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 35
  Type: NodeType.CONTINUE
  Expression: 

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.IF
  Expression: ownership.addr != address(0)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.IF
  Expression: currOwnershipAddr == owner

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: tokenIds[tokenIdsIdx ++] = i

  ID: 42
  Type: NodeType.ENDIF
  Expression: 

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 44
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(tokenIds,tokenIdsIdx)

  ID: 46
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 47
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 18
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  26 -> 28
  27 -> 28
  28 -> 31
  29 -> 32
  30 -> 44
  31 -> 29
  32 -> 33
  32 -> 30
  33 -> 34
  34 -> 35
  34 -> 36
  35 -> 43
  36 -> 37
  37 -> 38
  37 -> 39
  38 -> 39
  39 -> 40
  40 -> 41
  40 -> 42
  41 -> 42
  42 -> 43
  43 -> 32
  44 -> 45
  45 -> 46
  46 -> 47

Function: tokensOfOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: tokenIdsLength = balanceOf(owner)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tokenIds = new uint256[](tokenIdsLength)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = _startTokenId()

  ID: 9
  Type: NodeType.IFLOOP
  Expression: tokenIdsIdx != tokenIdsLength

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: ownership = _ownershipAt(i)

  ID: 11
  Type: NodeType.IF
  Expression: ownership.burned

  ID: 12
  Type: NodeType.CONTINUE
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: ownership.addr != address(0)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: currOwnershipAddr = ownership.addr

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.IF
  Expression: currOwnershipAddr == owner

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: tokenIds[tokenIdsIdx ++] = i

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 21
  Type: NodeType.RETURN
  Expression: tokenIds

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 21
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 20
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  18 -> 19
  19 -> 20
  20 -> 9

Function: _startTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _nextTokenId
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex

Edges:
  0 -> 1

Function: totalSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _burnCounter - _startTokenId()

Edges:
  0 -> 1

Function: _totalMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _currentIndex - _startTokenId()

Edges:
  0 -> 1

Function: _totalBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _burnCounter

Edges:
  0 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert BalanceQueryForZeroAddress()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _numberMinted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _numberBurned
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY

Edges:
  0 -> 1

Function: _getAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(_packedAddressData[owner] >> _BITPOS_AUX)

Edges:
  0 -> 1

Function: _setAux
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedAddressData[owner]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: auxCasted = aux

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[owner] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: supportsInterface
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f

Edges:
  0 -> 1

Function: name
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _name

Edges:
  0 -> 1

Function: symbol
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _symbol

Edges:
  0 -> 1

Function: tokenURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert URIQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: baseURI = _currentBaseURI

  ID: 6
  Type: NodeType.IF
  Expression: bytes(baseURI).length != 0

  ID: 7
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(baseURI,_toString(tokenId),_tokenURISuffix))

  ID: 8
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 6
  6 -> 7
  6 -> 8

Function: _baseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 

Edges:
  0 -> 1

Function: ownerOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(_packedOwnershipOf(tokenId)))

Edges:
  0 -> 1

Function: _ownershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnershipOf(tokenId))

Edges:
  0 -> 1

Function: _ownershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _unpackedOwnership(_packedOwnerships[index])

Edges:
  0 -> 1

Function: _initializeOwnershipAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _packedOwnerships[index] == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = _packedOwnershipOf(index)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: _packedOwnershipOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: curr = tokenId

  ID: 2
  Type: NodeType.IF
  Expression: _startTokenId() <= curr

  ID: 3
  Type: NodeType.IF
  Expression: curr < _currentIndex

  ID: 4
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[curr]

  ID: 5
  Type: NodeType.IF
  Expression: packed & _BITMASK_BURNED == 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: packed == 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: packed = _packedOwnerships[-- curr]

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: packed

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert OwnerQueryForNonexistentToken()()

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  3 -> 12
  4 -> 5
  5 -> 6
  5 -> 11
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 7
  9 -> 10
  11 -> 12
  12 -> 13
  13 -> 14

Function: _unpackedOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: ownership.addr = address(uint160(packed))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: ownership.burned = packed & _BITMASK_BURNED != 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA)

  ID: 5
  Type: NodeType.RETURN
  Expression: ownership

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _packOwnershipData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: result = owner | timestamp()() << _BITPOS_START_TIMESTAMP | flags

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _nextInitializedFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: result = quantity == 1 << _BITPOS_NEXT_INITIALIZED

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: owner = ownerOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: _msgSenderERC721A() != owner

  ID: 3
  Type: NodeType.IF
  Expression: ! isApprovedForAll(owner,_msgSenderERC721A())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalCallerNotOwnerNorApproved()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _tokenApprovals[tokenId].value = to

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: Approval(owner,to,tokenId)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: getApproved
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _exists(tokenId)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ApprovalQueryForNonexistentToken()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _tokenApprovals[tokenId].value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: setApprovalForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _operatorApprovals[_msgSenderERC721A()][operator] = approved

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ApprovalForAll(_msgSenderERC721A(),operator,approved)

Edges:
  0 -> 1
  1 -> 2

Function: isApprovedForAll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _operatorApprovals[owner][operator]

Edges:
  0 -> 1

Function: _exists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _startTokenId() <= tokenId && tokenId < _currentIndex && _packedOwnerships[tokenId] & _BITMASK_BURNED == 0

Edges:
  0 -> 1

Function: _isSenderApprovedOrOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: owner = owner & _BITMASK_ADDRESS

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: msgSender = msgSender & _BITMASK_ADDRESS

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = msgSender == owner | msgSender == approvedAddress

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _getApprovedSlotAndAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tokenApproval = _tokenApprovals[tokenId]

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: approvedAddressSlot = tokenApproval

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: approvedAddress = sload(uint256)(approvedAddressSlot)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: (approvedAddressSlot,approvedAddress)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: address(uint160(prevOwnershipPacked)) != from

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert TransferFromIncorrectOwner()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 8
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert TransferToZeroAddress()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,to,tokenId,1)

  ID: 17
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 21
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: -- _packedAddressData[from]

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: ++ _packedAddressData[to]

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(to,_BITMASK_NEXT_INITIALIZED | _nextExtraData(from,to,prevOwnershipPacked))

  ID: 25
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 26
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 27
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 28
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 30
  Type: NodeType.ENDIF
  Expression: 

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,to,tokenId)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,to,tokenId,1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 20
  18 -> 19
  19 -> 21
  20 -> 19
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 32
  26 -> 27
  27 -> 28
  27 -> 31
  28 -> 29
  28 -> 30
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: transferFrom(from,to,tokenId)

  ID: 2
  Type: NodeType.IF
  Expression: to.code.length != 0

  ID: 3
  Type: NodeType.IF
  Expression: ! _checkContractOnERC721Received(from,to,tokenId,_data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _beforeTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _afterTokenTransfers
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _checkContractOnERC721Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.TRY
  Expression: retval = ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(),from,tokenId,_data)

  ID: 2
  Type: NodeType.CATCH
  Expression: 

  ID: 3
  Type: NodeType.RETURN
  Expression: retval == ERC721A__IERC721Receiver(to).onERC721Received.selector

  ID: 4
  Type: NodeType.CATCH
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: reason.length == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert TransferToNonERC721ReceiverImplementer()()

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10

Function: _mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: end = startTokenId + quantity

  ID: 10
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: toMasked = to & _BITMASK_ADDRESS

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,startTokenId)

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = startTokenId + 1

  ID: 17
  Type: NodeType.IFLOOP
  Expression: ! tokenId__mint_asm_0 == end

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: log4(uint256,uint256,uint256,uint256,uint256,uint256)(0,0,_TRANSFER_EVENT_SIGNATURE,0,toMasked,tokenId__mint_asm_0)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: tokenId__mint_asm_0 = tokenId__mint_asm_0 + 1

  ID: 20
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: toMasked == 0

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = end

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 15
  14 -> 20
  15 -> 16
  16 -> 17
  17 -> 14
  17 -> 18
  18 -> 19
  19 -> 17
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25

Function: _mintERC2309
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: startTokenId = _currentIndex

  ID: 2
  Type: NodeType.IF
  Expression: to == address(0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert MintToZeroAddress()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: quantity == 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert MintZeroQuantity()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.IF
  Expression: quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert MintERC2309QuantityExceedsLimit()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(address(0),to,startTokenId,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[startTokenId] = _packOwnershipData(to,_nextInitializedFlag(quantity) | _nextExtraData(address(0),to,0))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ConsecutiveTransfer(startTokenId,startTokenId + quantity - 1,address(0),to)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _currentIndex = startTokenId + quantity

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(address(0),to,startTokenId,quantity)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16

Function: _safeMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,quantity,)

Edges:
  0 -> 1

Function: _burn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: prevOwnershipPacked = _packedOwnershipOf(tokenId)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: from = address(uint160(prevOwnershipPacked))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (approvedAddressSlot,approvedAddress) = _getApprovedSlotAndAddress(tokenId)

  ID: 6
  Type: NodeType.IF
  Expression: approvalCheck

  ID: 7
  Type: NodeType.IF
  Expression: ! _isSenderApprovedOrOwner(approvedAddress,from,_msgSenderERC721A())

  ID: 8
  Type: NodeType.IF
  Expression: ! isApprovedForAll(from,_msgSenderERC721A())

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert TransferCallerNotOwnerNorApproved()()

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _beforeTokenTransfers(from,address(0),tokenId,1)

  ID: 14
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: approvedAddress

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: sstore(uint256,uint256)(approvedAddressSlot,0)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[tokenId] = _packOwnershipData(from,(_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from,address(0),prevOwnershipPacked))

  ID: 21
  Type: NodeType.IF
  Expression: prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0

  ID: 22
  Type: NodeType.VARIABLE
  Expression: nextTokenId = tokenId + 1

  ID: 23
  Type: NodeType.IF
  Expression: _packedOwnerships[nextTokenId] == 0

  ID: 24
  Type: NodeType.IF
  Expression: nextTokenId != _currentIndex

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[nextTokenId] = prevOwnershipPacked

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: Transfer(from,address(0),tokenId)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: _afterTokenTransfers(from,address(0),tokenId,1)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: _burnCounter ++

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 12
  7 -> 8
  7 -> 11
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 17
  15 -> 16
  16 -> 18
  17 -> 16
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 28
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31

Function: _setExtraDataAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: packed = _packedOwnerships[index]

  ID: 2
  Type: NodeType.IF
  Expression: packed == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert OwnershipNotInitializedForExtraData()()

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: extraDataCasted = extraData

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _packedOwnerships[index] = packed

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: _extraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: _nextExtraData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA)

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(_extraData(from,to,extraData)) << _BITPOS_EXTRA_DATA

Edges:
  0 -> 1
  1 -> 2

Function: _msgSenderERC721A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _toString
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: m__toString_asm_0 = mload(uint256)(0x40) + 0xa0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,m__toString_asm_0)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: str = m__toString_asm_0 - 0x20

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,0)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: end__toString_asm_0 = str

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = value

  ID: 13
  Type: NodeType.IFLOOP
  Expression: 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: str = str - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore8(uint256,uint256)(str,48 + temp__toString_asm_0 % 10)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: temp__toString_asm_0 = temp__toString_asm_0 / 10

  ID: 17
  Type: NodeType.IF
  Expression: ! temp__toString_asm_0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.BREAK
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length__toString_asm_0 = end__toString_asm_0 - str

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: str = str - 0x20

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(str,length__toString_asm_0)

  ID: 24
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: str

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 11
  10 -> 20
  11 -> 12
  12 -> 13
  13 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  17 -> 18
  18 -> 13
  19 -> 18
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: setStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: originalSize = _mintStages.length

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < originalSize

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _mintStages.pop()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i_scope_0 < newStages.length

  ID: 12
  Type: NodeType.IF
  Expression: i_scope_0 >= 1

  ID: 13
  Type: NodeType.IF
  Expression: newStages[i_scope_0].startTimeUnixSeconds < newStages[i_scope_0 - 1].endTimeUnixSeconds

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientStageTimeGap()()

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _assertValidStartAndEndTimestamp(newStages[i_scope_0].startTimeUnixSeconds,newStages[i_scope_0].endTimeUnixSeconds)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _mintStages.push(MintStageInfo({cost:newStages[i_scope_0].cost,walletLimit:newStages[i_scope_0].walletLimit,merkleRoot:newStages[i_scope_0].merkleRoot,maxStageSupply:newStages[i_scope_0].maxStageSupply,startTimeUnixSeconds:newStages[i_scope_0].startTimeUnixSeconds,endTimeUnixSeconds:newStages[i_scope_0].endTimeUnixSeconds}))

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: UpdateStage(i_scope_0,newStages[i_scope_0].cost,newStages[i_scope_0].walletLimit,newStages[i_scope_0].merkleRoot,newStages[i_scope_0].maxStageSupply,newStages[i_scope_0].startTimeUnixSeconds,newStages[i_scope_0].endTimeUnixSeconds)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 21
  1 -> 4
  2 -> 5
  3 -> 10
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 11
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  12 -> 16
  13 -> 14
  13 -> 15
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 11
  21 -> 1

Function: getNumberStages
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _mintStages.length

Edges:
  0 -> 1

Function: getMaxMintableSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _maxMintableSupply

Edges:
  0 -> 1

Function: setMaxMintableSupply
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: maxMintableSupply > _maxMintableSupply

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotIncreaseMaxMintableSupply()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _maxMintableSupply = maxMintableSupply

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetMaxMintableSupply(maxMintableSupply)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: getGlobalWalletLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _globalWalletLimit

Edges:
  0 -> 1

Function: setGlobalWalletLimit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: globalWalletLimit > _maxMintableSupply

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert GlobalWalletLimitOverflow()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _globalWalletLimit = globalWalletLimit

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetGlobalWalletLimit(globalWalletLimit)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: totalMintedByAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _numberMinted(a)

Edges:
  0 -> 1

Function: getStageInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: index >= _mintStages.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(InvalidStage)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: walletMinted = _stageMintedCountsPerWallet[index][msg.sender]

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stageMinted = _stageMintedCounts[index]

  ID: 6
  Type: NodeType.RETURN
  Expression: (_mintStages[index],walletMinted,stageMinted)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: updateStage
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: index >= _mintStages.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStage()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: index >= 1

  ID: 5
  Type: NodeType.IF
  Expression: startTimeUnixSeconds < _mintStages[index - 1].endTimeUnixSeconds

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert InsufficientStageTimeGap()()

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: _assertValidStartAndEndTimestamp(startTimeUnixSeconds,endTimeUnixSeconds)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].cost = cost

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].walletLimit = walletLimit

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].merkleRoot = merkleRoot

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].maxStageSupply = maxStageSupply

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].startTimeUnixSeconds = startTimeUnixSeconds

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: _mintStages[index].endTimeUnixSeconds = endTimeUnixSeconds

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: UpdateStage(index,cost,walletLimit,merkleRoot,maxStageSupply,startTimeUnixSeconds,endTimeUnixSeconds)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 17
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 8
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  17 -> 1

Function: mint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _mintInternal(qty,msg.sender,proof)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 2
  2 -> 1

Function: _mintInternal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: stageTimestamp = uint64(block.timestamp)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: activeStage = getActiveStageFromTimestamp(stageTimestamp)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: stage = _mintStages[activeStage]

  ID: 5
  Type: NodeType.IF
  Expression: stage.cost < threshold

  ID: 6
  Type: NodeType.IF
  Expression: msg.value < (stage.cost + min_fee) * qty

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.IF
  Expression: msg.value < stage.cost * qty

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: stage.maxStageSupply > 0

  ID: 14
  Type: NodeType.IF
  Expression: _stageMintedCounts[activeStage] + qty > stage.maxStageSupply

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: revert StageSupplyExceeded()()

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: _globalWalletLimit > 0

  ID: 19
  Type: NodeType.IF
  Expression: _numberMinted(to) + qty > _globalWalletLimit

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert WalletGlobalLimitExceeded()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.IF
  Expression: stage.walletLimit > 0

  ID: 24
  Type: NodeType.IF
  Expression: _stageMintedCountsPerWallet[activeStage][to] + qty > stage.walletLimit

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: revert WalletStageLimitExceeded()()

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: stage.merkleRoot != 0

  ID: 29
  Type: NodeType.IF
  Expression: MerkleProof.processProof(proof,keccak256(bytes)(abi.encodePacked(to))) != stage.merkleRoot

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: revert InvalidProof()()

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.ENDIF
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: _stageMintedCountsPerWallet[activeStage][to] += qty

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: _stageMintedCounts[activeStage] += qty

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,qty)

  ID: 36
  Type: NodeType.IF
  Expression: stage.cost < threshold

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(min_fee * qty)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: address(owner()).transfer(msg.value - (min_fee * qty))

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(msg.value / 66)

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: address(owner()).transfer(msg.value - (msg.value / 66))

  ID: 41
  Type: NodeType.ENDIF
  Expression: 

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: hasSupply(qty)

Edges:
  0 -> 42
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 12
  9 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  13 -> 17
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 22
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  28 -> 32
  29 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  36 -> 39
  37 -> 38
  38 -> 41
  39 -> 40
  40 -> 41
  42 -> 1

Function: ownerMint
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value < min_fee * qty

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert NotEnoughValue()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _safeMint(to,qty)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: address(lmnft).transfer(msg.value)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: hasSupply(qty)

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 7
  7 -> 1

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: value = address(this).balance

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = msg.sender.call{value: value}()

  ID: 4
  Type: NodeType.IF
  Expression: ! success

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert WithdrawFailed()()

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: Withdraw(value)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  8 -> 1

Function: setBaseURI
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _baseURIPermanent

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert CannotUpdatePermanentBaseURI()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _currentBaseURI = baseURI

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: SetBaseURI(baseURI)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 6
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: setBaseURIPermanent
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _baseURIPermanent = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: PermanentBaseURI(_currentBaseURI)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: getTokenURISuffix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _tokenURISuffix

Edges:
  0 -> 1

Function: setTokenURISuffix
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _tokenURISuffix = suffix

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: getActiveStageFromTimestamp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < _mintStages.length

  ID: 5
  Type: NodeType.IF
  Expression: timestamp >= _mintStages[i].startTimeUnixSeconds && timestamp < _mintStages[i].endTimeUnixSeconds

  ID: 6
  Type: NodeType.RETURN
  Expression: i

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStage()()

Edges:
  0 -> 3
  1 -> 4
  2 -> 9
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 4

Function: _assertValidStartAndEndTimestamp
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: start >= end

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert InvalidStartAndEndTimestamp()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _maxMintableSupply = 10000

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _globalWalletLimit = 2000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: lmnft = 0x9E6865DAEeeDD093ea4A4f6c9bFbBB0cE6Bc8b17

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: min_fee = 33000000000000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: threshold = 2000000000000000

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _currentBaseURI = ipfs://QmYvMzAytzejPviD6Auiu69rRzZLugvT2K8LY5dxdEQrVi/

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _tokenURISuffix = .json

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


