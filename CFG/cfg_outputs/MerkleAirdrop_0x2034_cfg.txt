Contract: Hashes
==================================================

Function: commutativeKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: _efficientKeccak256(a,b)

  ID: 4
  Type: NodeType.RETURN
  Expression: _efficientKeccak256(b,a)

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: _efficientKeccak256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x00,a)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x20,b)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = keccak256(uint256,uint256)(0x00,0x40)

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: value

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: MerkleProof
==================================================

Function: verify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProof(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: verifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processProofCalldata(proof,leaf,hasher) == root

Edges:
  0 -> 1

Function: processProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: computedHash = leaf

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < proof.length

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: computedHash = hasher(computedHash,proof[i])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.RETURN
  Expression: computedHash

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5

Function: multiProofVerify
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProof(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35

Function: multiProofVerifyCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: processMultiProofCalldata(proof,proofFlags,leaves,hasher) == root

Edges:
  0 -> 1

Function: processMultiProofCalldata
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: leavesLen = leaves.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: proofFlagsLen = proofFlags.length

  ID: 3
  Type: NodeType.IF
  Expression: leavesLen + proof.length != proofFlagsLen + 1

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: hashes = new bytes32[](proofFlagsLen)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: leafPos = 0

  ID: 8
  Type: NodeType.VARIABLE
  Expression: hashPos = 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: proofPos = 0

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < proofFlagsLen

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: hashes[i] = hasher(a,b)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.IF
  Expression: proofFlagsLen > 0

  ID: 19
  Type: NodeType.IF
  Expression: proofPos != proof.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: revert MerkleProofInvalidMultiproof()()

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: hashes[proofFlagsLen - 1]

  ID: 23
  Type: NodeType.IF
  Expression: leavesLen > 0

  ID: 24
  Type: NodeType.RETURN
  Expression: leaves[0]

  ID: 25
  Type: NodeType.RETURN
  Expression: proof[0]

  ID: 28
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: a = leaves[leafPos ++]

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: a = hashes[hashPos ++]

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.IF
  Expression: proofFlags[i]

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: b = proof[proofPos ++]

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: leafPos < leavesLen

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: b = leaves[leafPos ++]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: b = hashes[hashPos ++]

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.RETURN
  Expression: merkleRoot

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 18
  12 -> 10
  13 -> 28
  13 -> 11
  16 -> 17
  17 -> 13
  18 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  23 -> 24
  23 -> 25
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 32
  32 -> 36
  32 -> 34
  34 -> 35
  35 -> 16
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 35


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: IERC20
==================================================


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: _ENTERED = 2

Edges:
  0 -> 1


Contract: IVestingWallet
==================================================


Contract: MerkleAirdrop
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: vestingContract = IVestingWallet(_vestingWalletAddress)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: token = _token

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Ownable(msg.sender)

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _status = _ENTERED

Edges:
  0 -> 1
  1 -> 2

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = _NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == _ENTERED

Edges:
  0 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: setMerkleRoot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: currentAirdropNumber += 1

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: merkleRoots[currentAirdropNumber] = _merkleRoot

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: MerkleRootSet(currentAirdropNumber,_merkleRoot)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: claim
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! hasClaimed[msg.sender][currentAirdropNumber],Airdrop already claimed for this user)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: leaf = keccak256(bytes)(abi.encodePacked(msg.sender,quantity))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(MerkleProof.verify(merkleProof,merkleRoots[currentAirdropNumber],leaf),Invalid Merkle proof)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: hasClaimed[msg.sender][currentAirdropNumber] = true

  ID: 5
  Type: NodeType.VARIABLE
  Expression: vestingAmount = (quantity * 80) / 100

  ID: 6
  Type: NodeType.VARIABLE
  Expression: transferAmount = quantity - vestingAmount

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.transfer(address(vestingContract),vestingAmount),Token transfer failed)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: user = msg.sender

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: vestingContract.createVesting(user,10368000,0,vestingAmount,)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.transfer(msg.sender,transferAmount),Token transfer failed)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: AirdropClaimed(msg.sender,currentAirdropNumber,quantity)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 1

Function: withdrawTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.balanceOf(address(this)) >= amount,Insufficient tokens in contract)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token.transfer(msg.sender,amount),Token transfer failed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: TokensWithdrawn(msg.sender,amount)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: changeVestingOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),New owner cannot be the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: previousOwner = vestingContract.owner()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: vestingContract.transferOwnership(newOwner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: VestingOwnershipTransferred(previousOwner,newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1


