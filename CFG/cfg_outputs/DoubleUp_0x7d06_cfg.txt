Contract: IERC20
==================================================


Contract: IUniswapV3SwapCallback
==================================================


Contract: ISwapRouter
==================================================


Contract: EnumerableSet
==================================================

Function: _add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! _contains(set,value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: set._values.push(value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: set._indexes[value] = set._values.length

  ID: 4
  Type: NodeType.RETURN
  Expression: true

  ID: 5
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4

Function: _remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: valueIndex = set._indexes[value]

  ID: 2
  Type: NodeType.IF
  Expression: valueIndex != 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: toDeleteIndex = valueIndex - 1

  ID: 4
  Type: NodeType.VARIABLE
  Expression: lastIndex = set._values.length - 1

  ID: 5
  Type: NodeType.IF
  Expression: lastIndex != toDeleteIndex

  ID: 6
  Type: NodeType.VARIABLE
  Expression: lastValue = set._values[lastIndex]

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: set._values[toDeleteIndex] = lastValue

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: set._indexes[lastValue] = valueIndex

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: set._values.pop()

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: delete set._indexes[value]

  ID: 12
  Type: NodeType.RETURN
  Expression: true

  ID: 13
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 13
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 9
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12

Function: _contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._indexes[value] != 0

Edges:
  0 -> 1

Function: _length
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values.length

Edges:
  0 -> 1

Function: _at
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values[index]

Edges:
  0 -> 1

Function: _values
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: set._values

Edges:
  0 -> 1

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _add(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: remove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _remove(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: contains
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _contains(set._inner,bytes32(value))

Edges:
  0 -> 1

Function: length
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _length(set._inner)

Edges:
  0 -> 1

Function: at
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(_at(set._inner,index))

Edges:
  0 -> 1

Function: values
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: store = _values(set._inner)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: result = store

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


Contract: IERC20Permit
==================================================


Contract: Address
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: account.code.length > 0

Edges:
  0 -> 1

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: verifyCallResultFromTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.IF
  Expression: returndata.length == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: returndata

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 6
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  6 -> 7

Function: verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _revert(returndata,errorMessage)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: _revert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 7
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value))

Edges:
  0 -> 1

Function: safeApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)((value == 0) || (token.allowance(address(this),spender) == 0),SafeERC20: approve from non-zero to non-zero allowance)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value))

Edges:
  0 -> 1
  1 -> 2

Function: safeIncreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance + value))

Edges:
  0 -> 1
  1 -> 2

Function: safeDecreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(oldAllowance >= value,SafeERC20: decreased allowance below zero)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance - value))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: forceApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: approvalCall = abi.encodeWithSelector(token.approve.selector,spender,value)

  ID: 2
  Type: NodeType.IF
  Expression: ! _callOptionalReturnBool(token,approvalCall)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,0))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,approvalCall)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: safePermit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: nonceBefore = token.nonces(owner)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: token.permit(owner,spender,value,deadline,v,r,s)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: nonceAfter = token.nonces(owner)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(nonceAfter == nonceBefore + 1,SafeERC20: permit did not succeed)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _callOptionalReturn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: returndata = address(token).functionCall(data,SafeERC20: low-level call failed)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(returndata.length == 0 || abi.decode(returndata,(bool)),SafeERC20: ERC20 operation did not succeed)

Edges:
  0 -> 1
  1 -> 2

Function: _callOptionalReturnBool
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = address(token).call(data)

  ID: 4
  Type: NodeType.RETURN
  Expression: success && (returndata.length == 0 || abi.decode(returndata,(bool))) && Address.isContract(address(token))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4


Contract: DoubleUp
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: supportedStablecoins[LUSD] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: supportedStablecoins[USDT] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: supportedStablecoins[USDC] = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: supportedStablecoins[DAI] = true

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: marketingAddress = _marketingAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: deposit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(supportedStablecoins[stablecoin],Unsupported stablecoin)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,Amount must be greater than 0)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IERC20(stablecoin).safeTransferFrom(msg.sender,address(this),amount)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: stablecoin == USDT || stablecoin == USDC

  ID: 6
  Type: NodeType.VARIABLE
  Expression: allowance = IERC20(stablecoin).allowance(address(this),address(router))

  ID: 7
  Type: NodeType.IF
  Expression: allowance < amount

  ID: 8
  Type: NodeType.VARIABLE
  Expression: newAllowance = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: IERC20(stablecoin).safeIncreaseAllowance(address(router),newAllowance - allowance)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: params = ISwapRouter.ExactInputParams({path:abi.encodePacked(stablecoin,uint24(100),WETH),recipient:address(this),deadline:block.timestamp,amountIn:amount,amountOutMinimum:0})

  ID: 12
  Type: NodeType.VARIABLE
  Expression: wethOut = ISwapRouter(router).exactInput(params)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: allowance = IERC20(WETH).allowance(address(this),address(router))

  ID: 14
  Type: NodeType.IF
  Expression: allowance < amount

  ID: 15
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_0 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: IERC20(WETH).safeIncreaseAllowance(address(router),newAllowance_scope_0 - allowance)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: params = ISwapRouter.ExactInputParams({path:abi.encodePacked(WETH,uint24(100),WBGL),recipient:address(this),deadline:block.timestamp,amountIn:wethOut,amountOutMinimum:0})

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: amountOut = ISwapRouter(router).exactInput(params)

  ID: 20
  Type: NodeType.IF
  Expression: stablecoin == LUSD || stablecoin == DAI

  ID: 21
  Type: NodeType.VARIABLE
  Expression: allowance_scope_1 = IERC20(stablecoin).allowance(address(this),address(router))

  ID: 22
  Type: NodeType.IF
  Expression: allowance_scope_1 < amount

  ID: 23
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_2 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: IERC20(stablecoin).safeIncreaseAllowance(address(router),newAllowance_scope_2 - allowance_scope_1)

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: poolFee = 100

  ID: 27
  Type: NodeType.IF
  Expression: stablecoin == LUSD

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: poolFee = 500

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.VARIABLE
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(stablecoin,poolFee,USDC),recipient:address(this),deadline:block.timestamp,amountIn:amount,amountOutMinimum:0})

  ID: 31
  Type: NodeType.VARIABLE
  Expression: usdcOut = ISwapRouter(router).exactInput(params_scope_3)

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: allowance_scope_1 = IERC20(USDC).allowance(address(this),address(router))

  ID: 33
  Type: NodeType.IF
  Expression: allowance_scope_1 < amount

  ID: 34
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_4 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 35
  Type: NodeType.EXPRESSION
  Expression: IERC20(USDC).safeIncreaseAllowance(address(router),newAllowance_scope_4 - allowance_scope_1)

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(USDC,uint24(100),WETH),recipient:address(this),deadline:block.timestamp,amountIn:usdcOut,amountOutMinimum:0})

  ID: 38
  Type: NodeType.VARIABLE
  Expression: wethOut_scope_5 = ISwapRouter(router).exactInput(params_scope_3)

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: allowance_scope_1 = IERC20(WETH).allowance(address(this),address(router))

  ID: 40
  Type: NodeType.IF
  Expression: allowance_scope_1 < amount

  ID: 41
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_6 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: IERC20(WETH).safeIncreaseAllowance(address(router),newAllowance_scope_6 - allowance_scope_1)

  ID: 43
  Type: NodeType.ENDIF
  Expression: 

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(WETH,uint24(100),WBGL),recipient:address(this),deadline:block.timestamp,amountIn:wethOut_scope_5,amountOutMinimum:0})

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: amountOut = ISwapRouter(router).exactInput(params_scope_3)

  ID: 46
  Type: NodeType.ENDIF
  Expression: 

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.VARIABLE
  Expression: marketingWBGL = (amountOut * 15) / 100

  ID: 49
  Type: NodeType.VARIABLE
  Expression: frozenWBGL = (amountOut * 15) / 100

  ID: 50
  Type: NodeType.VARIABLE
  Expression: positionWBGL = amountOut - marketingWBGL - frozenWBGL

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: marketingBalanceWBGL += marketingWBGL

  ID: 52
  Type: NodeType.EXPRESSION
  Expression: positions[msg.sender].push(Position({stablecoin:stablecoin,originalAmount:amount,wbglAmount:positionWBGL,buyPrice:amount * 1e18 / amountOut,sellPrice:(amount * 1e18 / amountOut * 2857143) / 1000000,closed:false}))

  ID: 53
  Type: NodeType.VARIABLE
  Expression: positionIndex = uint96(positions[msg.sender].length - 1)

  ID: 54
  Type: NodeType.VARIABLE
  Expression: positionId = bytes32(bytes20(msg.sender)) | bytes32(uint256(positionIndex))

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: activePositions.add(positionId)

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: Deposited(msg.sender,stablecoin,amount,positions[msg.sender].length - 1)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 20
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 47
  20 -> 21
  20 -> 46
  21 -> 22
  22 -> 23
  22 -> 25
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  27 -> 29
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  33 -> 36
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  40 -> 43
  41 -> 42
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 50
  50 -> 51
  51 -> 52
  52 -> 53
  53 -> 54
  54 -> 55
  55 -> 56

Function: closePosition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(positionIndex < positions[user].length,Invalid position index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: position = positions[user][positionIndex]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(position.originalAmount > 0,Position does not exist)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! position.closed,Position already closed)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IERC20(position.stablecoin).safeTransferFrom(msg.sender,address(this),position.originalAmount * 2)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: IERC20(WBGL).safeTransfer(msg.sender,position.wbglAmount)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: position.closed = true

  ID: 8
  Type: NodeType.VARIABLE
  Expression: positionId = bytes32(bytes20(user)) | bytes32(uint256(uint96(positionIndex)))

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: activePositions.remove(positionId)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: PositionClosed(user,msg.sender,positionIndex)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: withdraw
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(positionIndex < positions[msg.sender].length,Invalid position index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: position = positions[msg.sender][positionIndex]

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(position.originalAmount > 0,No position to withdraw)

  ID: 4
  Type: NodeType.IF
  Expression: ! position.closed

  ID: 5
  Type: NodeType.IF
  Expression: position.stablecoin == USDC || position.stablecoin == USDT

  ID: 6
  Type: NodeType.VARIABLE
  Expression: allowance = IERC20(WBGL).allowance(address(this),address(router))

  ID: 7
  Type: NodeType.IF
  Expression: allowance < position.wbglAmount

  ID: 8
  Type: NodeType.VARIABLE
  Expression: newAllowance = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: IERC20(WBGL).safeIncreaseAllowance(address(router),newAllowance - allowance)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: params = ISwapRouter.ExactInputParams({path:abi.encodePacked(WBGL,uint24(100),WETH),recipient:address(this),deadline:block.timestamp,amountIn:position.wbglAmount,amountOutMinimum:0})

  ID: 12
  Type: NodeType.VARIABLE
  Expression: wethOut = ISwapRouter(router).exactInput(params)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: allowance = IERC20(WETH).allowance(address(this),address(router))

  ID: 14
  Type: NodeType.IF
  Expression: allowance < wethOut

  ID: 15
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_0 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: IERC20(WETH).safeIncreaseAllowance(address(router),newAllowance_scope_0 - allowance)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: params = ISwapRouter.ExactInputParams({path:abi.encodePacked(WETH,uint24(100),position.stablecoin),recipient:address(this),deadline:block.timestamp,amountIn:wethOut,amountOutMinimum:position.originalAmount * 2})

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: ISwapRouter(router).exactInput(params)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: IERC20(position.stablecoin).safeTransfer(msg.sender,position.originalAmount * 2)

  ID: 21
  Type: NodeType.IF
  Expression: position.stablecoin == LUSD || position.stablecoin == DAI

  ID: 22
  Type: NodeType.VARIABLE
  Expression: allowance_scope_1 = IERC20(WBGL).allowance(address(this),address(router))

  ID: 23
  Type: NodeType.IF
  Expression: allowance_scope_1 < position.wbglAmount

  ID: 24
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_2 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: IERC20(WBGL).safeIncreaseAllowance(address(router),newAllowance_scope_2 - allowance_scope_1)

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.VARIABLE
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(WBGL,uint24(100),WETH),recipient:address(this),deadline:block.timestamp,amountIn:position.wbglAmount,amountOutMinimum:0})

  ID: 28
  Type: NodeType.VARIABLE
  Expression: wethOut_scope_4 = ISwapRouter(router).exactInput(params_scope_3)

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: allowance_scope_1 = IERC20(WETH).allowance(address(this),address(router))

  ID: 30
  Type: NodeType.IF
  Expression: allowance_scope_1 < wethOut_scope_4

  ID: 31
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_5 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: IERC20(WETH).safeIncreaseAllowance(address(router),newAllowance_scope_5 - allowance_scope_1)

  ID: 33
  Type: NodeType.ENDIF
  Expression: 

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(WETH,uint24(100),USDC),recipient:address(this),deadline:block.timestamp,amountIn:wethOut_scope_4,amountOutMinimum:0})

  ID: 35
  Type: NodeType.VARIABLE
  Expression: usdcOut = ISwapRouter(router).exactInput(params_scope_3)

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: allowance_scope_1 = IERC20(USDC).allowance(address(this),address(router))

  ID: 37
  Type: NodeType.IF
  Expression: allowance_scope_1 < usdcOut

  ID: 38
  Type: NodeType.VARIABLE
  Expression: newAllowance_scope_6 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: IERC20(USDC).safeIncreaseAllowance(address(router),newAllowance_scope_6 - allowance_scope_1)

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.VARIABLE
  Expression: poolFee = 100

  ID: 42
  Type: NodeType.IF
  Expression: position.stablecoin == LUSD

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: poolFee = 500

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.EXPRESSION
  Expression: params_scope_3 = ISwapRouter.ExactInputParams({path:abi.encodePacked(USDC,poolFee,position.stablecoin),recipient:address(this),deadline:block.timestamp,amountIn:usdcOut,amountOutMinimum:position.originalAmount * 2})

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: ISwapRouter(router).exactInput(params_scope_3)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: IERC20(position.stablecoin).safeTransfer(msg.sender,position.originalAmount * 2)

  ID: 48
  Type: NodeType.ENDIF
  Expression: 

  ID: 49
  Type: NodeType.ENDIF
  Expression: 

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: IERC20(position.stablecoin).safeTransfer(msg.sender,position.originalAmount * 2)

  ID: 51
  Type: NodeType.ENDIF
  Expression: 

  ID: 52
  Type: NodeType.EXPRESSION
  Expression: Withdrawn(msg.sender,position.originalAmount * 2)

  ID: 53
  Type: NodeType.VARIABLE
  Expression: positionId = bytes32(bytes20(msg.sender)) | bytes32(uint256(uint96(positionIndex)))

  ID: 54
  Type: NodeType.EXPRESSION
  Expression: activePositions.remove(positionId)

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: delete positions[msg.sender][positionIndex]

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 50
  5 -> 6
  5 -> 21
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 49
  21 -> 22
  21 -> 48
  22 -> 23
  23 -> 24
  23 -> 26
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  30 -> 33
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  37 -> 40
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 43
  42 -> 44
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  49 -> 51
  50 -> 51
  51 -> 52
  52 -> 53
  53 -> 54
  54 -> 55

Function: withdrawMarketingFunds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == marketingAddress,Unauthorized)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: amount = marketingBalanceWBGL

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,No funds available)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: marketingBalanceWBGL = 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IERC20(WBGL).safeTransfer(marketingAddress,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: getOpenPositionCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: activePositions.length()

Edges:
  0 -> 1

Function: getOpenPositionAddresses
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(endIndex < activePositions.length(),Index out of bounds)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: result = new bytes32[](endIndex - startIndex + 1)

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = startIndex

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i <= endIndex

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: result[i - startIndex] = activePositions.at(i)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 9
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 6

Function: isPositionOpen
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: positionId = bytes32(bytes20(user)) | bytes32(uint256(uint96(index)))

  ID: 2
  Type: NodeType.RETURN
  Expression: activePositions.contains(positionId)

Edges:
  0 -> 1
  1 -> 2

Function: getPositionDetails
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(index < positions[user].length,Invalid position index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: position = positions[user][index]

  ID: 3
  Type: NodeType.RETURN
  Expression: (position.stablecoin,position.originalAmount,position.wbglAmount,position.buyPrice,position.sellPrice,position.closed)

  ID: 4
  Type: NodeType.RETURN
  Expression: (stablecoin,originalAmount,wbglAmount,buyPrice,sellPrice,closed)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getSupportedStablecoins
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: coins = new address[](4)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: isSupported = new bool[](4)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (coins[0],coins[1],coins[2],coins[3]) = (LUSD,USDT,USDC,DAI)

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < 4

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: isSupported[i] = supportedStablecoins[coins[i]]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.RETURN
  Expression: (coins,isSupported)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 6
  4 -> 7
  5 -> 10
  6 -> 4
  7 -> 8
  7 -> 5
  8 -> 9
  9 -> 7

Function: getContractStatistics
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: openPositions = activePositions.length()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: marketingWBGLBalance = marketingBalanceWBGL

  ID: 3
  Type: NodeType.RETURN
  Expression: (openPositions,marketingWBGLBalance)

  ID: 4
  Type: NodeType.RETURN
  Expression: (openPositions,marketingWBGLBalance)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getUserPositions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: positions[user]

Edges:
  0 -> 1

Function: getUserPositionsLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: positions[user].length

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WBGL = 0x2bA64EFB7A4Ec8983E22A49c81fa216AC33f383A

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6


