Contract: AbstractENS
==================================================


Contract: AbstractGroupWalletFactory
==================================================


Contract: AbstractTokenProxy
==================================================


Contract: AbstractGWMBaseRegistrar
==================================================


Contract: AbstractResolver
==================================================


Contract: Abstract_NameWrap
==================================================


Contract: I_NameWrapper
==================================================


Contract: AbstractETHRegistrarController
==================================================


Contract: AbsETHRegV3
==================================================


Contract: AbstractGroupWalletProxy
==================================================


Contract: Resolver
==================================================


Contract: AbstractReverseRegistrar
==================================================


Contract: AbstractAuctionRegistrar
==================================================


Contract: AbsInt
==================================================


Contract: AbsGlobalT
==================================================


Contract: AbsGWM
==================================================


Contract: ABSReg
==================================================


Contract: ABSExtDeed
==================================================


Contract: GroupWalletMaster
==================================================

Function: getMasterCopy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: masterCopy

Edges:
  0 -> 1

Function: getGWF
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: GWF

Edges:
  0 -> 1

Function: getENS
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractENS(AbstractGroupWalletFactory(GWF).ens())

Edges:
  0 -> 1

Function: getRsv
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractGroupWalletFactory(GWF).resolverContract()

Edges:
  0 -> 1

Function: getCtrl
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractGroupWalletFactory(GWF).controllerContract()

Edges:
  0 -> 1

Function: getRevs
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractGroupWalletFactory(GWF).reverseContract()

Edges:
  0 -> 1

Function: getNWrap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: I_NameWrapper(getCtrl().nameWrapper())

Edges:
  0 -> 1

Function: getIntention
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: intent != address(0x0)

  ID: 2
  Type: NodeType.RETURN
  Expression: AbsInt(intent)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: AbsInt(AbsGWM(getMasterCopy()).getIntention())

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getTarget
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(uint160(uint256(uint256(tArr[tNb]) & k_addressMask)))

Edges:
  0 -> 1

Function: getTValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(uint256((uint256(uint256(tArr[tNb]) & k_valueMask) >> 160) & k_value2Mask))

Edges:
  0 -> 1

Function: getAsset
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint8(uint256(uint256(uint256(uint256(tArr[tNb]) & k_assetMask) >> 208) & k_asset2Mask))

Edges:
  0 -> 1

Function: getAssetT
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint8(uint256((uint256(uint256(t) & k_assetMask) >> 208) & k_asset2Mask))

Edges:
  0 -> 1

Function: getFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(uint256(uint256(uint256(uint256(tArr[tNb]) & k_flagsMask) >> 216) & k_flags2Mask))

Edges:
  0 -> 1

Function: getFlagsT
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask)

Edges:
  0 -> 1

Function: getType
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint8(uint256(uint256(uint256(uint256(tArr[tNb]) & k_typeMask) >> 252) & k_type2Mask))

Edges:
  0 -> 1

Function: getStructure
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: structures[target]

Edges:
  0 -> 1

Function: saveFlags
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tArr[_tId] = uint256(uint256(uint256(flags) << 216) & k_flagsMask) + uint256(tArr[_tId] & k_flags3Mask)

Edges:
  0 -> 1

Function: saveAsset
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(isAddressOwner(msg.sender) && dhash != 0x0 && getENS().recordExists(dhash) && getENSOwnerExpected(dhash) == address(this),n)

  ID: 2
  Type: NodeType.IF
  Expression: asset != 3

  ID: 3
  Type: NodeType.VARIABLE
  Expression: pHash = uint256(getHash())

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(pHash > 0 && getENSOwnerExpected(bytes32(pHash)) == address(this) && bytes32(pHash) == dhash,q)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: getRsv().setText(dhash,key,data)

  ID: 7
  Type: NodeType.IF
  Expression: asset == 1

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ColorTableSaved(dhash)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: asset == 2

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: EtherScriptSaved(dhash,key)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  11 -> 12

Function: saveExecuted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tArr[_tId] = uint256(uint256(uint256((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)) | k_executeFlag)

Edges:
  0 -> 1

Function: saveNotExecuted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tArr[_tId] = uint256(((uint256(f) << 216) & k_flagsMask) + uint256(t & k_flags3Mask))

Edges:
  0 -> 1

Function: getBase
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractGroupWalletFactory(GWF).base().baseNode()

Edges:
  0 -> 1

Function: getPtoken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: AbstractTokenProxy(AbstractGroupWalletFactory(GWF).getProxyToken(_hash))

Edges:
  0 -> 1

Function: getHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: bytes32(tArr[uint256(uint160(GWF))])

Edges:
  0 -> 1

Function: dHashFromLabelBytes32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(abi.encodePacked(getBase(),keccak256(bytes)(bytes(bytesToStr(_name,uint256(_name) & 0xff)))))

  ID: 2
  Type: NodeType.RETURN
  Expression: hsh

Edges:
  0 -> 1

Function: adjustMajority
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (uint64(_f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + (uint64(activeOwners()) / 2) + 1

Edges:
  0 -> 1

Function: my_require
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b,str)

Edges:
  0 -> 1

Function: bytesToStr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bArr = new bytes(len)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < len && i < 32

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: bArr[i] = _b[i]

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: string(bArr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 4
  7 -> 8

Function: bytes32ToStr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bArr = new bytes(32)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: off = 0

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < 32 && off == 0

  ID: 6
  Type: NodeType.IF
  Expression: _b[i] != 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: bArr[i] = _b[i]

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: off = i

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: rArr = new bytes(off)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: i < 32 && off > 0

  ID: 16
  Type: NodeType.IF
  Expression: bArr[i] != 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: rArr[i] = bArr[i]

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: off --

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 21
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 22
  Type: NodeType.RETURN
  Expression: string(rArr)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  5 -> 6
  5 -> 11
  6 -> 7
  6 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 5
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 16
  15 -> 16
  15 -> 21
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 15
  21 -> 22

Function: toLowerCaseBytes32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: uint256(uint256(uint256(_in) & k_typeMask) >> 252) < 6

  ID: 2
  Type: NodeType.RETURN
  Expression: bytes32(uint256(uint256(_in) | 0x2000000000000000000000000000000000000000000000000000000000000000))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: _in

  ID: 5
  Type: NodeType.RETURN
  Expression: _out

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: mb32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: a = mload(uint256)(_data + 32)

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: a

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: labelStrFromBytes32
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: bytesToStr(_label,uint256(_label) & 0xff)

Edges:
  0 -> 1

Function: checkPreconditions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(tNb > 0 && isAddressOwner(msg.sender) && tArr[tNb] == 0 && uint256(uint256(tRecord & k_typeMask) >> 252) == cmd,V)

Edges:
  0 -> 1

Function: isLegacyTokenCmd
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint8(uint256(uint256(uint256(uint256(tRecord) & k_typeMask) >> 252) & k_type2Mask)) == k_legacyToken

Edges:
  0 -> 1

Function: checkSplitPreconditions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(owners.length > 3,G)

  ID: 2
  Type: NodeType.RETURN
  Expression: getOpenSplitTransactionNb(tNb - 1,exec)

Edges:
  0 -> 1
  1 -> 2

Function: reverseDNameFromAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getRevs().defaultResolver().name(getRevs().node(a))

Edges:
  0 -> 1

Function: confirmTransaction_Q6d
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _tId > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: my_require(msg.value > 0,Q)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: t = tArr[_tId]

  ID: 5
  Type: NodeType.VARIABLE
  Expression: f = getFlagsT(t)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: o = getOwnerMask(msg.sender)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: my_require(uint64(f & o) == 0 && getAssetT(t) < 128,X)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: f = uint64(f | o)

  ID: 9
  Type: NodeType.IF
  Expression: (getFlags(msg.value - 1) & uint64(MAX_OWNER_COUNT)) <= nbOfConfirmations(f)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: executeMultiSigCommand(_tId,t,f)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: saveNotExecuted(_tId,f,t)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12

Function: revokeConfirmation_NlP
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: t = tArr[_tId]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: f = uint64(uint256(uint256(uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask))

  ID: 3
  Type: NodeType.VARIABLE
  Expression: o = getOwnerMask(msg.sender)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(o > 0 && uint64(f & o) > 0 && (uint256(t) & k_executeFlag) == 0,r)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tArr[_tId] = uint256((uint256(uint64(f | o) ^ uint64(o)) << 216) & k_flagsMask) + uint256(t & k_flags3Mask)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: storeLegacyProxyToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: newHash = keccak256(bytes)(abi.encodePacked(getBase(),keccak256(bytes)(bytes(bytes32ToStr(toLowerCaseBytes32(spinName))))))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: gwp = getENSOwnerExpected(newHash)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: legacyToken = proxyToken()

  ID: 4
  Type: NodeType.VARIABLE
  Expression: tRecord = uint256(uint256(uint256(k_legacyToken & k_type2Mask) << 252) & k_typeMask) + uint256(uint256(uint256(flags) << 216) & k_flagsMask) + uint256(uint256(uint256(nbOfConfirmations(flags)) << 208) & k_assetMask) + uint256(uint160(legacyToken)) | k_executeFlag

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletProxy(gwp).submitFirstTransaction_gm{value: 0}(tRecord,uint256(newHash))

  ID: 6
  Type: NodeType.RETURN
  Expression: gwp

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: sendSpinoffAssets
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: cost = uint256(msg.value)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: o = 1

  ID: 4
  Type: NodeType.VARIABLE
  Expression: f_s = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: t = 0

  ID: 6
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 7
  Type: NodeType.VARIABLE
  Expression: hash = getHash()

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 10
  Type: NodeType.IF
  Expression: (uint64(f >> 5) & o) == o

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: t = uint256(_mem[7 + (f_s * 5)]) & k_addressMask

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: f_s ++

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: getPtoken(hash).drainShares(hash,owners[i],address(uint160(t)))

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: drainLegacySharesGWP(hash,i,address(uint160(t)))

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ownerChange(owners[i],address(0x0))

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: o = o * 2

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: remainingRequired = uint64((activeOwners() / 2) + 1)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: f_s = uint64(uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + remainingRequired

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: saveFlags(_tId,f_s)

  ID: 23
  Type: NodeType.VARIABLE
  Expression: nbm = uint64((_mem.length - 5) / 5)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: cost += uint256(uint256((totalGas - gasleft()()) - uint256(23504 * nbm)) * tx.gasprice)

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: cost = cost / nbm

  ID: 26
  Type: NodeType.VARIABLE
  Expression: ownerId = 0

  ID: 27
  Type: NodeType.VARIABLE
  Expression: gwp = storeLegacyProxyToken(_mem[3],f)

  ID: 28
  Type: NodeType.VARIABLE
  Expression: flag = uint64(uint64(2 ** nbm) - 1)

  ID: 29
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 30
  Type: NodeType.VARIABLE
  Expression: 

  ID: 31
  Type: NodeType.VARIABLE
  Expression: t_scope_2 = 0

  ID: 32
  Type: NodeType.VARIABLE
  Expression: 

  ID: 33
  Type: NodeType.VARIABLE
  Expression: 

  ID: 34
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 35
  Type: NodeType.IFLOOP
  Expression: t_scope_2 > 0

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: t_scope_2 = tArr[i_scope_0]

  ID: 37
  Type: NodeType.IF
  Expression: (t_scope_2 & k_executeFlag == 0) && ((t_scope_2 & k_typeMask) >> 252 == k_deposit)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: o_scope_1 = uint8((uint256(uint256(t_scope_2) & k_assetMask) >> 208) & k_asset2Mask)

  ID: 39
  Type: NodeType.EXPRESSION
  Expression: depositReceiver = address(uint160(uint256(_mem[7 + (o_scope_1 * 5)]) & k_addressMask))

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: depositValue = uint256(uint256(t_scope_2) & k_addressMask)

  ID: 41
  Type: NodeType.IF
  Expression: (cost > 0) && (depositValue > cost) && (address(this).balance >= (depositValue - cost))

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: my_require(address(depositReceiver).send(depositValue - cost),L)

  ID: 43
  Type: NodeType.EXPRESSION
  Expression: Deposit(depositReceiver,depositValue - cost)

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: tArr[i_scope_0] = uint256(uint256(uint256(uint256(remainingRequired) << 216) & k_flagsMask) + uint256(t_scope_2 & k_flags3Mask)) | k_executeFlag

  ID: 45
  Type: NodeType.ENDIF
  Expression: 

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: flag = flag ^ uint64(2 ** uint64(o_scope_1))

  ID: 47
  Type: NodeType.ENDIF
  Expression: 

  ID: 48
  Type: NodeType.IF
  Expression: ((t_scope_2 & k_typeMask) >> 252) == k_legacyToken

  ID: 49
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletProxy(gwp).submitLegacyTransaction{value: 0}(i_scope_0 + 1,t_scope_2)

  ID: 50
  Type: NodeType.ENDIF
  Expression: 

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 52
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: ownerId = uint64(ownerIdFromFlag(uint64(flag)))

  ID: 54
  Type: NodeType.VARIABLE
  Expression: target = uint256(_mem[7 + (ownerId * 5)]) & k_addressMask

  ID: 55
  Type: NodeType.IF
  Expression: msg.value < cost || address(this).balance == 0

  ID: 56
  Type: NodeType.RETURN
  Expression: true

  ID: 57
  Type: NodeType.ENDIF
  Expression: 

  ID: 58
  Type: NodeType.VARIABLE
  Expression: payback = uint256(msg.value) - cost

  ID: 59
  Type: NodeType.IF
  Expression: address(this).balance < payback

  ID: 60
  Type: NodeType.EXPRESSION
  Expression: payback = address(this).balance

  ID: 61
  Type: NodeType.ENDIF
  Expression: 

  ID: 62
  Type: NodeType.EXPRESSION
  Expression: my_require(address(address(uint160(target))).send(payback),P)

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: Deposit(address(uint160(target)),payback)

  ID: 64
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  9 -> 10
  9 -> 19
  10 -> 11
  10 -> 16
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 9
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  33 -> 34
  34 -> 36
  35 -> 36
  35 -> 52
  36 -> 37
  37 -> 38
  37 -> 47
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  41 -> 45
  42 -> 43
  43 -> 44
  44 -> 45
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 49
  48 -> 50
  49 -> 50
  50 -> 51
  51 -> 35
  52 -> 53
  53 -> 54
  54 -> 55
  55 -> 56
  55 -> 57
  57 -> 58
  58 -> 59
  59 -> 60
  59 -> 61
  60 -> 61
  61 -> 62
  62 -> 63
  63 -> 64

Function: confirmSpinOffGroup_L51b
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalGas = gasleft()()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _tId = uint256(_in[0])

  ID: 3
  Type: NodeType.IF
  Expression: _tId > 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(msg.value > 0,Y)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: t = tArr[_tId]

  ID: 7
  Type: NodeType.VARIABLE
  Expression: f = getFlagsT(t)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: my_require(uint64(f & getOwnerMask(msg.sender)) == 0 && getAssetT(t) < 128 && (((t & k_typeMask) >> 252) == k_spinoffGroup) && isAddressOwner(msg.sender),D)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: f_s = uint64((uint256(uint256(tArr[checkSplitPreconditions(_tId,128)]) & k_flagsMask) >> 216) & k_flags2Mask)

  ID: 10
  Type: NodeType.IF
  Expression: (f_s & getOwnerMask(msg.sender)) == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: f = uint64(f | getOwnerMask(msg.sender))

  ID: 14
  Type: NodeType.IF
  Expression: uint64(uint64(f >> 5) & uint64(f_s >> 5)) == uint64(f_s >> 5)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: getRsv().setABI(getHash(),128,abi.encodePacked(_abi))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletFactory(GWF).replicate_group_l9Y{value: msg.value}(_in,data32,_mem)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: saveExecuted(_tId,f,t)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: my_require(sendSpinoffAssets(_tId,f,_mem,totalGas),U)

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: saveNotExecuted(_tId,f,t)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 19
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 20
  19 -> 20

Function: drainLegacySharesGWP
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: tt > 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tt = tArr[i]

  ID: 6
  Type: NodeType.IF
  Expression: (tt & k_typeMask) >> 252 == k_legacyToken

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: AbstractTokenProxy(address(uint160(uint256(uint256(tt) & k_addressMask)))).drainLegacyShares(dhash,owners[nb],target)

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  4 -> 5
  4 -> 10
  5 -> 6
  6 -> 7
  6 -> 8
  7 -> 8
  8 -> 9
  9 -> 4

Function: submitFirstTransaction_gm
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: isLegacyToken = isLegacyTokenCmd(firstTRecord)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: my_require(tArr[0] == 0 && (isAddressOwner(msg.sender) || isLegacyToken),E)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: mask = k_flags3Mask

  ID: 4
  Type: NodeType.IF
  Expression: isLegacyToken

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mask = k_flags4Mask

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: tArr[0] = uint256((uint256(uint64(uint64(owners.length >> 1) + 1) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(firstTRecord) & mask)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tArr[uint256(uint160(GWF))] = dhash

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: GroupWalletDeployed(msg.sender,owners.length,uint256(block.timestamp))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: submitLegacyTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(tNb > 0 && tArr[tNb] == 0 && isLegacyTokenCmd(tRecord),H)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tArr[tNb] = uint256(uint256(uint256(uint256(uint64(uint64(owners.length >> 1) + 1)) << 216) & k_flagsMask) + uint256(uint256(tRecord) & k_flags4Mask)) | k_executeFlag

Edges:
  0 -> 1
  1 -> 2

Function: _submitTrans
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: tArr[msg.value] = uint256(uint256(uint256(uint64(getTRequired(msg.value - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(_tRecord & k_flags3Mask)

Edges:
  0 -> 1

Function: __valueAndOwnerOK
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(msg.value > 0 && isAddressOwner(msg.sender) && tArr[msg.value] == 0,u)

Edges:
  0 -> 1

Function: submitTransaction_m79
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: __valueAndOwnerOK()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _submitTrans(aTRecord)

Edges:
  0 -> 1
  1 -> 2

Function: submitInvestTransaction_b3j
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: asset = getAssetT(aTRecord)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: __valueAndOwnerOK()

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: my_require((asset == 120 || asset == 118),M)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _submitTrans(aTRecord)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: executeMultiSigCommand(msg.value,tArr[msg.value],getFlags(msg.value))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: submitSplitTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: checkPreconditions(msg.value,aTRecord,k_splitGroup)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: my_require(checkSplitPreconditions(msg.value,0) == 0,l)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _submitTrans(aTRecord)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: tArr[uint256(_commitment) & k_addressMask] = uint256(_commitment)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tArr[(uint256(_commitment) & k_addressMask) + 1] = uint256(_dname)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletFactory(GWF).reserve_replicate(dHashFromLabelBytes32(_dname),_commitment)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: isENSV3
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (address(AbstractGroupWalletFactory(GWF).ensNameWrapper()) != address(0x0))

Edges:
  0 -> 1

Function: onERC1155Received
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: this.onERC1155Received.selector

  ID: 2
  Type: NodeType.RETURN
  Expression: r

Edges:
  0 -> 1

Function: setENSSubnode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: getENS().setSubnodeRecord(getHash(),_label,address(this),address(getRsv()),uint64(block.timestamp * 1000) & k_timeMask)

Edges:
  0 -> 1

Function: setENSV3Subnode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: getNWrap().setSubnodeRecord(getHash(),_label,address(this),address(getRsv()),uint64(block.timestamp * 1000) & k_timeMask,0,0)

Edges:
  0 -> 1

Function: getENSOwnerExpected
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: isENSV3()

  ID: 2
  Type: NodeType.RETURN
  Expression: AbstractGroupWalletFactory(GWF).getOwner(_hash)

  ID: 3
  Type: NodeType.RETURN
  Expression: getENS().owner(_hash)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3

Function: submitExecuteSplitTransaction
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tNb = msg.value & 0x000000000000000000000000000000000000000000000000000000ffffffffff

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: checkPreconditions(tNb,aTRecord,k_spinoffGroup)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: splitTNb = checkSplitPreconditions(tNb,0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(uint256(tArr[uint160(aTRecord) & k_addressMask] & k_addressMask) == (uint256(aTRecord) & k_addressMask) && splitTNb > 0,Z)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tArr[splitTNb] = uint256(uint256(tArr[splitTNb]) | k_executeFlag)

  ID: 6
  Type: NodeType.VARIABLE
  Expression: splitName = bytes32(tArr[uint256(uint160(uint256(aTRecord) & k_addressMask) + 1)])

  ID: 7
  Type: NodeType.VARIABLE
  Expression: dHash = dHashFromLabelBytes32(splitName)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: _dname = labelStrFromBytes32(splitName)

  ID: 9
  Type: NodeType.IF
  Expression: ! isENSV3()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: getCtrl().registerWithConfig{value: getCtrl().rentPrice(_dname,31536000)}(_dname,address(this),31536000,bytes32(_secret),address(getRsv()),GWF)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: getRsv().setName(dHash,string(abi.encodePacked(_dname,AbstractGroupWalletFactory(GWF).tld())))

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: getENS().setOwner(dHash,GWF)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (_rent,_dd) = AbsETHRegV3(address(getCtrl())).rentPrice(_dname,31536000)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _dd = 0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletFactory(GWF)._register(dHash,_rent,_dname,31536000,bytes32(_secret))

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: tArr[tNb] = uint256((uint256(uint64(getTRequired(tNb - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 13
  10 -> 11
  11 -> 12
  12 -> 18
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: submitTransaction_addUser_kCY
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require((msg.value > 0 || (msg.value == 0 && dhash > 0x0)) && isAddressOwner(msg.sender) && (((aTRecord & k_typeMask) >> 252 == k_addOwner)),B)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: targetId = uint256(aTRecord & k_addressMask)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: tArr[targetId + 1] = label

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: tArr[targetId + 2] = len

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: tArr[targetId + 3] = bytesLen

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: structures[targetId] = data

  ID: 7
  Type: NodeType.IF
  Expression: dhash > 0x0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: tArr[0] = uint256((uint256(uint64(uint64(owners.length >> 1) + 1) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & k_flags3Mask)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: tArr[uint256(uint160(GWF))] = dhash

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: GroupWalletDeployed(msg.sender,owners.length,uint256(block.timestamp))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _submitTrans(aTRecord)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: my_require(getENSOwnerExpected(getHash()) == address(this),O)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 12
  11 -> 12
  12 -> 13

Function: submitTransaction_proposal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require((aTRecord & k_typeMask) >> 252 == k_proposal,N)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: structures[uint256(aTRecord & k_addressMask)] = data

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: submitTransaction_m79(aTRecord)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: executeTransaction_G1A
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: t = tArr[_tId]

  ID: 5
  Type: NodeType.VARIABLE
  Expression: f = uint64((uint256(uint256(t) & k_flagsMask) >> 216) & k_flags2Mask)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: my_require(uint64(f & getOwnerMask(msg.sender)) > 0 && getAssetT(t) < 128,I)

  ID: 7
  Type: NodeType.IF
  Expression: (getFlags((msg.value - 1)) & uint64(MAX_OWNER_COUNT)) <= nbOfConfirmations(f)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: executeMultiSigCommand(_tId,t,f)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 9

Function: getMemberWelcome
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(isAddressOwner(target),J)

  ID: 2
  Type: NodeType.RETURN
  Expression: abi.encode(tArr[uint256(uint160(target) + 2)],tArr[uint256(uint160(target) + 3)])

Edges:
  0 -> 1
  1 -> 2

Function: welcomeOneNewOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: l_dHash = getHash()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: l_label = bytes32(tArr[uint256(uint160(target) + 1)])

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: ! isENSV3()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: l_dlabelHash = keccak256(bytes)(abi.encodePacked(l_dHash,l_label))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: setENSSubnode(l_label)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: l_labelStr = labelStrFromBytes32(l_label)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: l_dlabelHash = getLabelDHash(keccak256(bytes)(bytes(l_labelStr)))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: setENSV3Subnode(l_labelStr)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: getRsv().setAddr(l_dlabelHash,target)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: getRsv().setABI(l_dHash,32,abi.encodePacked(structures[uint256(uint160(target))]))

  ID: 14
  Type: NodeType.IF
  Expression: ! isENSV3()

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: getENS().setOwner(l_dlabelHash,target)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: getNWrap().setSubnodeOwner(l_dHash,l_labelStr,target,0,0)

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: address(this).balance > welcomeBudget

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: my_require(address(address(uint160(target))).send(welcomeBudget),F)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: Deposit(target,welcomeBudget)

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: getPtoken(l_dHash).transfer_G8l(target,10000)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 8
  6 -> 7
  7 -> 11
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  18 -> 21
  19 -> 20
  20 -> 21
  21 -> 22

Function: executeMultiSigCommand
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: cmd = uint8((uint256(uint256(t) & k_typeMask) >> 252) & k_type2Mask)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: target = address(uint160(uint256(t) & k_addressMask))

  ID: 4
  Type: NodeType.IF
  Expression: cmd == 2

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: my_require(! isAddressOwner(target) && (owners.length < MAX_OWNER_COUNT) && uint64(f & uint64(MAX_OWNER_COUNT)) >= 2,2)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: owners.push(target)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: welcomeOneNewOwner(target)

  ID: 8
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,adjustMajority(f),t)

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: cmd == 3

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: removeOneOwner(target)

  ID: 12
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,adjustMajority(f),t)

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: asset = getAssetT(t)

  ID: 15
  Type: NodeType.IF
  Expression: cmd == 5

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: my_require((asset >= 2) && (asset <= MAX_OWNER_COUNT),5)

  ID: 17
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,(uint64(f | uint64(MAX_OWNER_COUNT)) ^ uint64(MAX_OWNER_COUNT)) + uint64(asset),t)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: (cmd == 1) || (cmd == 6) || (cmd == 12) || (cmd == 13) || (cmd == 15)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: aValue = uint256(uint256(t & k_valueMask) >> 160) & k_value2Mask

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.IF
  Expression: cmd == 1

  ID: 23
  Type: NodeType.IF
  Expression: asset == 119

  ID: 24
  Type: NodeType.VARIABLE
  Expression: targGW = ABSReg(ABSExtDeed(target).registrar()).getGWPfromAuction(ABSExtDeed(target).lhash())

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: getIntention().storeInvestment(AbstractTokenProxy(AbsGWM(targGW).proxyToken()).balanceOf(address(ABSExtDeed(target).registrar())),targGW,target.balance,getHash())

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: tArr[_tId + 1] = k_typeLegacyMsk + uint256(uint256(uint256(getTRequired(_tId) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint160(AbsGWM(targGW).proxyToken()) & k_addressMask) | k_executeFlag

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.VARIABLE
  Expression: 

  ID: 29
  Type: NodeType.VARIABLE
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: (succ,returnData) = target.call{value: aValue << 20}()

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(succ,string(abi.encode(returnData,returnData.length)))

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: Deposit(target,uint256(aValue << 20))

  ID: 33
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,f,t)

  ID: 34
  Type: NodeType.ENDIF
  Expression: 

  ID: 35
  Type: NodeType.IF
  Expression: cmd == 12

  ID: 36
  Type: NodeType.VARIABLE
  Expression: l_rent = getCtrl().rentPrice(abcde,31536000)

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: my_require(aValue != 0 && address(this).balance >= l_rent,j)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: getIntention().saveLetterOfIntent{value: l_rent}(target,uint256(aValue))

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.VARIABLE
  Expression: l_token = AbstractTokenProxy(proxyToken())

  ID: 41
  Type: NodeType.IF
  Expression: cmd == 6

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: my_require(aValue > 0,6)

  ID: 43
  Type: NodeType.IF
  Expression: asset == 125

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: l_token.sell_LA2(aValue)

  ID: 45
  Type: NodeType.ENDIF
  Expression: 

  ID: 46
  Type: NodeType.IF
  Expression: (asset == 126) || (asset == 124)

  ID: 47
  Type: NodeType.EXPRESSION
  Expression: l_token.transfer_G8l(target,aValue)

  ID: 48
  Type: NodeType.ENDIF
  Expression: 

  ID: 49
  Type: NodeType.IF
  Expression: asset < 64

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: AbstractTokenProxy(getTarget(uint256(asset))).transfer_G8l(target,aValue)

  ID: 51
  Type: NodeType.EXPRESSION
  Expression: AbsGlobalT(target).convertGroupSharesToEther(getTarget(uint256(asset)),aValue)

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,f,t)

  ID: 54
  Type: NodeType.ENDIF
  Expression: 

  ID: 55
  Type: NodeType.VARIABLE
  Expression: dHash = getHash()

  ID: 56
  Type: NodeType.IF
  Expression: (cmd == 13) && (aValue != 0x44bb0000000)

  ID: 57
  Type: NodeType.EXPRESSION
  Expression: getRsv().setABI(dHash,32,abi.encodePacked(structures[uint256(uint160(target))]))

  ID: 58
  Type: NodeType.ENDIF
  Expression: 

  ID: 59
  Type: NodeType.IF
  Expression: cmd == 14

  ID: 60
  Type: NodeType.IF
  Expression: asset == 127

  ID: 61
  Type: NodeType.EXPRESSION
  Expression: AbstractGroupWalletFactory(GWF).upgradeGWF(dHash,target)

  ID: 62
  Type: NodeType.ENDIF
  Expression: 

  ID: 63
  Type: NodeType.IF
  Expression: asset == 123

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: l_token.upgradeTokenMaster(dHash,target)

  ID: 65
  Type: NodeType.ENDIF
  Expression: 

  ID: 66
  Type: NodeType.IF
  Expression: asset == 122

  ID: 67
  Type: NodeType.EXPRESSION
  Expression: l_token.upgradeGWM(dHash,target)

  ID: 68
  Type: NodeType.ENDIF
  Expression: 

  ID: 69
  Type: NodeType.ENDIF
  Expression: 

  ID: 70
  Type: NodeType.IF
  Expression: cmd == 15

  ID: 71
  Type: NodeType.VARIABLE
  Expression: period = (uint256(uint64(asset) & 127) >> 2) * 60

  ID: 72
  Type: NodeType.EXPRESSION
  Expression: AbstractAuctionRegistrar(target).startAuction_ge0(keccak256(bytes)(bytes(bytes32ToStr(bytes32(uint256(aValue) << 208)))),period)

  ID: 73
  Type: NodeType.EXPRESSION
  Expression: aValue = uint256(uint64(asset) & 3)

  ID: 74
  Type: NodeType.EXPRESSION
  Expression: l_token.transfer_G8l(target,uint64((1 + (aValue * aValue)) * 100 * 10000))

  ID: 75
  Type: NodeType.IF
  Expression: ! isENSV3()

  ID: 76
  Type: NodeType.EXPRESSION
  Expression: setENSSubnode(getLabelHash(t))

  ID: 77
  Type: NodeType.EXPRESSION
  Expression: setENSV3Subnode(bytes32ToStr(bytes32(uint256(t & k_valueMask) << 48)))

  ID: 78
  Type: NodeType.ENDIF
  Expression: 

  ID: 79
  Type: NodeType.EXPRESSION
  Expression: setResolvedAddress(t,address(this))

  ID: 80
  Type: NodeType.ENDIF
  Expression: 

  ID: 81
  Type: NodeType.IF
  Expression: (cmd == 7) || (cmd == 8)

  ID: 82
  Type: NodeType.RETURN
  Expression: saveNotExecuted(_tId,f,t)

  ID: 83
  Type: NodeType.ENDIF
  Expression: 

  ID: 84
  Type: NodeType.RETURN
  Expression: saveExecuted(_tId,f,t)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 9
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 11
  10 -> 13
  11 -> 12
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 18
  16 -> 17
  18 -> 19
  19 -> 20
  19 -> 21
  20 -> 21
  21 -> 22
  22 -> 23
  22 -> 34
  23 -> 24
  23 -> 27
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 32
  32 -> 33
  34 -> 35
  35 -> 36
  35 -> 39
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 41
  41 -> 42
  41 -> 54
  42 -> 43
  43 -> 44
  43 -> 45
  44 -> 45
  45 -> 46
  46 -> 47
  46 -> 48
  47 -> 48
  48 -> 49
  49 -> 50
  49 -> 52
  50 -> 51
  51 -> 52
  52 -> 53
  54 -> 55
  55 -> 56
  56 -> 57
  56 -> 58
  57 -> 58
  58 -> 59
  59 -> 60
  59 -> 69
  60 -> 61
  60 -> 62
  61 -> 62
  62 -> 63
  63 -> 64
  63 -> 65
  64 -> 65
  65 -> 66
  66 -> 67
  66 -> 68
  67 -> 68
  68 -> 69
  69 -> 70
  70 -> 71
  70 -> 80
  71 -> 72
  72 -> 73
  73 -> 74
  74 -> 75
  75 -> 76
  75 -> 77
  76 -> 78
  77 -> 78
  78 -> 79
  79 -> 80
  80 -> 81
  81 -> 82
  81 -> 83
  83 -> 84

Function: TransferTokenFromContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tProxy = AbstractTokenProxy(_token)

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),tProxy,0,data + 0x20,mload(uint256)(data),0,0) == 0

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0,0)

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  3 -> 4
  4 -> 6
  5 -> 4

Function: removeOneOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: bal = address(this).balance

  ID: 2
  Type: NodeType.IF
  Expression: bal > lowBudget

  ID: 3
  Type: NodeType.VARIABLE
  Expression: val = (bal - lowBudget) / activeOwners()

  ID: 4
  Type: NodeType.IF
  Expression: (val > 0) && (val < bal)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: my_require(address(address(uint160(target))).send(val),R)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: Deposit(target,val)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ownerChange(target,address(0x0))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 8
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: activeOwners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: count = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < owners.length

  ID: 5
  Type: NodeType.IF
  Expression: uint160(owners[i]) != 0x0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: count

  ID: 11
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  4 -> 5
  4 -> 9
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 4
  9 -> 10

Function: getLabelHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(bytes(bytes32ToStr(bytes32(uint256(t & k_valueMask) << 48))))

Edges:
  0 -> 1

Function: getLabelDHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: keccak256(bytes)(abi.encodePacked(getHash(),_lhash))

Edges:
  0 -> 1

Function: setResolvedAddress
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: getRsv().setAddr(getLabelDHash(getLabelHash(t)),target)

Edges:
  0 -> 1

Function: reserveAuctionENSname
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: t = tArr[_tId]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: my_require(proxyToken() == msg.sender && t > 0 && (t & k_executeFlag) > 0,W)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: setResolvedAddress(t,deedContract)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require((address(this).balance > (_payment * 5) / 1000) && AbstractGroupWalletFactory(GWF).receivePayment{value: ((_payment * 5) / 1000)}(),p)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: nameAuctionBidBucketLabel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: my_require(proxyToken() == msg.sender,T)

  ID: 4
  Type: NodeType.IF
  Expression: ! isENSV3()

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: setENSSubnode(labelhashOrStr)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: l_dlabelHash = getLabelDHash(labelhashOrStr)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: label = labelStrFromBytes32(labelhashOrStr)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: setENSV3Subnode(label)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: l_dlabelHash = getLabelDHash(keccak256(bytes)(bytes(label)))

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: getRsv().setAddr(l_dlabelHash,deedContract)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 10
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: getTNumberPublic
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: count = 0

  ID: 2
  Type: NodeType.IF
  Expression: tArr[0] == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: count

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: tArr[i] > 0

  ID: 8
  Type: NodeType.IF
  Expression: tArr[i] > 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 7
  12 -> 13

Function: isConfirmed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: _tNb > 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: r = uint64(getTRequired(_tNb - 1))

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: (_tNb == 0) || (r == 0)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: r = uint64(owners.length >> 1) + 1

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (r <= nbOfConfirmations(getFlags(_tNb)))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8

Function: getRequiredPublic
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _tNb == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: uint256(uint64(owners.length >> 1) + 1)

  ID: 3
  Type: NodeType.RETURN
  Expression: getTRequired(_tNb - 1)

  ID: 5
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 1
  1 -> 2
  1 -> 3

Function: getIsOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: isAddressOwner(_owner)

Edges:
  0 -> 1

Function: getTransactionsCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getTNumberPublic()

Edges:
  0 -> 1

Function: getTransactions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getTNumberPublic() > 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (getTarget(_tNb),getTValue(_tNb),getAsset(_tNb),isTExecuted(_tNb),getFlags(_tNb),getType(_tNb),isConfirmed(_tNb))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: (destination,value,asset,executed,flags,typ,conf)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getTransactionRecord
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: getTNumberPublic() > 0

  ID: 2
  Type: NodeType.RETURN
  Expression: tArr[_tNb]

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: getAllTransactions
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: tArr[0] == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: new uint256[](0)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: tArr[i] > 0

  ID: 8
  Type: NodeType.IF
  Expression: tArr[i] > 0

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: resultArr = new uint256[](count)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 18
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: t = tArr[i]

  ID: 20
  Type: NodeType.IF
  Expression: isLegacyTokenCmd(t)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: token = address(uint160(uint256(t & k_addressMask)))

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: resultArr[i] = uint256(t & k_value3Mask) + uint256(uint256(uint256(AbstractTokenProxy(token).balanceOf(tx.origin)) << 160) & k_valueMask)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: resultArr[i] = t

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 26
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 27
  Type: NodeType.RETURN
  Expression: resultArr

  ID: 28
  Type: NodeType.RETURN
  Expression: transArr

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 7
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 19
  18 -> 19
  18 -> 26
  19 -> 20
  20 -> 21
  20 -> 23
  21 -> 22
  22 -> 24
  23 -> 24
  24 -> 25
  25 -> 18
  26 -> 27

Function: getConfirmationCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint256(nbOfConfirmations(getFlags(_tNb)))

Edges:
  0 -> 1

Function: getTransactionCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: t = getTNumberPublic()

  ID: 3
  Type: NodeType.IF
  Expression: t == 0

  ID: 4
  Type: NodeType.RETURN
  Expression: 0

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < t

  ID: 8
  Type: NodeType.IF
  Expression: pending && ! isTExecuted(i) || executed && isTExecuted(i)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: count += 1

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: count

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 7
  12 -> 13

Function: addressConfirmations
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: ownerConfirmed(_tNb,_owner)

Edges:
  0 -> 1

Function: getOwners
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: owners

Edges:
  0 -> 1

Function: getConfirmations
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: m = owners.length

  ID: 2
  Type: NodeType.VARIABLE
  Expression: confirmationsTemp = new address[](m)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.IFLOOP
  Expression: i < m

  ID: 7
  Type: NodeType.IF
  Expression: ownerConfirmed(_tId,owners[i])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: confirmationsTemp[count ++] = owners[i]

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: _confirmations = new address[](count)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 14
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 15
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _confirmations[i] = confirmationsTemp[i]

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 18
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 19
  Type: NodeType.RETURN
  Expression: _confirmations

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 7
  6 -> 7
  6 -> 11
  7 -> 8
  7 -> 9
  8 -> 9
  9 -> 10
  10 -> 6
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 16
  15 -> 16
  15 -> 18
  16 -> 17
  17 -> 15
  18 -> 19

Function: nbOfConfirmations
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: m = 32

  ID: 2
  Type: NodeType.VARIABLE
  Expression: o = owners.length

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: o > 0

  ID: 5
  Type: NodeType.IF
  Expression: (confirmFlags & m) > 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: nb ++

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: m = m * 2

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: o --

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: nb

  ID: 12
  Type: NodeType.RETURN
  Expression: nb

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  4 -> 5
  4 -> 10
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 4
  10 -> 11

Function: isAddressOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: m = owners.length

  ID: 2
  Type: NodeType.IF
  Expression: m == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: false

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: i < m && i < MAX_OWNER_COUNT

  ID: 8
  Type: NodeType.IF
  Expression: owners[i] == _owner

  ID: 9
  Type: NodeType.RETURN
  Expression: true

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: false

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  10 -> 11
  11 -> 7
  12 -> 13

Function: ownerChange
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: i < owners.length && i < MAX_OWNER_COUNT

  ID: 4
  Type: NodeType.IF
  Expression: owners[i] == _owner

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: owners[i] = _newOwner

  ID: 6
  Type: NodeType.RETURN
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: my_require(false,h)

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  3 -> 4
  3 -> 9
  4 -> 5
  4 -> 7
  5 -> 6
  7 -> 8
  8 -> 3
  9 -> 10

Function: getOwnerMask
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: mask = 32

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: len = owners.length

  ID: 4
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < len && i < MAX_OWNER_COUNT

  ID: 6
  Type: NodeType.IF
  Expression: owners[i] == _owner

  ID: 7
  Type: NodeType.RETURN
  Expression: mask

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: mask = mask * 2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: 0

  ID: 13
  Type: NodeType.RETURN
  Expression: mask

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 6
  5 -> 6
  5 -> 11
  6 -> 7
  6 -> 8
  8 -> 9
  9 -> 10
  10 -> 5
  11 -> 12

Function: ownerIdFromFlag
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: id = 1

  ID: 2
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < MAX_OWNER_COUNT

  ID: 5
  Type: NodeType.IF
  Expression: _ownerFlag == id

  ID: 6
  Type: NodeType.RETURN
  Expression: i

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: id = id * 2

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: 0

  ID: 12
  Type: NodeType.RETURN
  Expression: id

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 5
  4 -> 5
  4 -> 10
  5 -> 6
  5 -> 7
  7 -> 8
  8 -> 9
  9 -> 4
  10 -> 11

Function: isTExecuted
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: (getAsset(_tNb) > 127)

Edges:
  0 -> 1

Function: getOpenSplitTransactionNb
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: idx = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: (tArr[0] == 0) || (_tNb <= 0)

  ID: 5
  Type: NodeType.RETURN
  Expression: 0

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = _tNb

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i > 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: t = tArr[i]

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: f = getFlagsT(t)

  ID: 12
  Type: NodeType.IF
  Expression: (t != 0) && (uint8(uint256((uint256(uint256(t) & k_typeMask) >> 252) & k_type2Mask)) == k_splitGroup) && ((getAssetT(t) & 128) == executed) && (nbOfConfirmations(f) > 0)

  ID: 13
  Type: NodeType.RETURN
  Expression: i

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 16
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 17
  Type: NodeType.RETURN
  Expression: 0

  ID: 18
  Type: NodeType.RETURN
  Expression: idx

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  9 -> 10
  9 -> 16
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  14 -> 15
  15 -> 9
  16 -> 17

Function: ownerConfirmed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: f = getFlags(_tNb)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: o = getOwnerMask(_owner)

  ID: 3
  Type: NodeType.RETURN
  Expression: (uint64(f & o) > 0)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getTRequired
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: uint64(getFlags(_tId) & uint64(MAX_OWNER_COUNT))

Edges:
  0 -> 1

Function: newProxyGroupWallet_j5O
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: i < _owners.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(_owners[i] != address(0x0) && owners.length == i,a)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: owners.push(_owners[i])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: GWF = msg.sender

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 3
  7 -> 8

Function: forwardEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(msg.value > 0 && receiver.send(msg.value),f)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Deposit(receiver,msg.value)

Edges:
  0 -> 1
  1 -> 2

Function: depositEther
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(msg.value > 0 && tNb > 0 && tArr[tNb] == 0 && uint256(uint256(aTRecord & k_typeMask) >> 252) == 10,i)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: tArr[tNb] = uint256(uint256(uint256(uint64(getTRequired(tNb - 1)) | getOwnerMask(msg.sender)) << 216) & k_flagsMask) + uint256(uint256(aTRecord) & (k_address2Mask - k_flagsMask)) + uint256(msg.value & k_addressMask)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Deposit(address(address(this)),uint256(msg.value))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: setIntentionsContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: my_require(address(msg.sender) == masterCopy,k)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: intent = intCtr

Edges:
  0 -> 1
  1 -> 2

Function: proxyToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(getPtoken(getHash()))

Edges:
  0 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value > 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Deposit(address(this),msg.value)

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: my_require(false,b)

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  4 -> 5

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: Deposit(msg.sender,msg.value)

Edges:
  0 -> 1

Function: version
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 20010090

  ID: 2
  Type: NodeType.RETURN
  Expression: v

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: i < _owners.length

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: my_require(_owners[i] != address(0x0),C)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: owners.push(_owners[i])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: masterCopy = address(msg.sender)

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  3 -> 4
  3 -> 7
  4 -> 5
  5 -> 6
  6 -> 3
  7 -> 8

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_OWNER_COUNT = 31

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: welcomeBudget = 2500000000000000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: lowBudget = 200000000000000000

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_proposal = 13

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_legacyToken = 11

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_letterOfIntent = 12

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_deposit = 10

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_splitGroup = 7

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_spinoffGroup = 8

  ID: 9
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_addOwner = 2

  ID: 10
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_timeMask = 0xffffffffffff0000

  ID: 11
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_addressMask = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff

  ID: 12
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_address2Mask = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000

  ID: 13
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_valueMask = 0x000000000000ffffffffffff0000000000000000000000000000000000000000

  ID: 14
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_value3Mask = 0xffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff

  ID: 15
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_value2Mask = 0x0000000000000000000000000000000000000000000000000000ffffffffffff

  ID: 16
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_flagsMask = 0x0fffffffff000000000000000000000000000000000000000000000000000000

  ID: 17
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_flags2Mask = 0x0000000000000000000000000000000000000000000000000000000fffffffff

  ID: 18
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_flags3Mask = 0xf000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 19
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_flags4Mask = 0xffffffffe0ffffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 20
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_assetMask = 0x0000000000ff0000000000000000000000000000000000000000000000000000

  ID: 21
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_asset2Mask = 0x00000000000000000000000000000000000000000000000000000000000000ff

  ID: 22
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_asset3Mask = 0xffffffffff00ffffffffffffffffffffffffffffffffffffffffffffffffffff

  ID: 23
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_executeFlag = 0x0000000000800000000000000000000000000000000000000000000000000000

  ID: 24
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_typeMask = 0xf000000000000000000000000000000000000000000000000000000000000000

  ID: 25
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_type2Mask = 0x000000000000000000000000000000000000000000000000000000000000000f

  ID: 26
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: k_typeLegacyMsk = 0xb000000000000000000000000000000000000000000000000000000000000000

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26


