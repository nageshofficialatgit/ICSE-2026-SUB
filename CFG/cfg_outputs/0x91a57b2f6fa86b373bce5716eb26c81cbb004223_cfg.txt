Contract: OwnedByWinsome
==================================================

Function: initOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_owner] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_worker] = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowWorker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_new_worker] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: removeWorker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_old_worker] = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = _new_owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1


Contract: SafeMath
==================================================

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(a == 0 || c / a == b)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(b > 0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: assert(a == b * c + a % b)

  ID: 4
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: assert(b <= a)

  ID: 2
  Type: NodeType.RETURN
  Expression: a - b

Edges:
  0 -> 1
  1 -> 2

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: assert(c >= a)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: max64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a >= b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min64
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: max256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a >= b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: min256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: a < b

  ID: 3
  Type: NodeType.RETURN
  Expression: a

  ID: 4
  Type: NodeType.RETURN
  Expression: b

Edges:
  0 -> 2
  2 -> 3
  2 -> 4

Function: assert
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! assertion

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3


Contract: BasicToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalSupply = 0

Edges:


Contract: StandardToken
==================================================

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

Edges:
  0 -> 1
  1 -> 2

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalSupply = 0

Edges:


Contract: WinToken
==================================================

Function: initOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_owner] = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_worker] = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: allowWorker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_new_worker] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: removeWorker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedWorker[_old_worker] = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: changeOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: owner = _new_owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _allowance = allowed[_from][msg.sender]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: balances[_from] = balances[_from].sub(_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: allowed[_from][msg.sender] = _allowance.sub(_value)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: Transfer(_from,_to,_value)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: approve
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowed[msg.sender][_spender] = _value

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: Approval(msg.sender,_spender,_value)

Edges:
  0 -> 1
  1 -> 2

Function: allowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: allowed[_owner][_spender]

  ID: 2
  Type: NodeType.RETURN
  Expression: remaining

Edges:
  0 -> 1

Function: transfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[msg.sender] = balances[msg.sender].sub(_value)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: balances[_to] = balances[_to].add(_value)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(msg.sender,_to,_value)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyPayloadSize(2 * 32)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: balanceOf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: balances[_owner]

  ID: 2
  Type: NodeType.RETURN
  Expression: balance

Edges:
  0 -> 1

Function: WinToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedMinter[_owner] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: initOwnership(_owner,_owner)

Edges:
  0 -> 1
  1 -> 2

Function: allowMinter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedMinter[_new_minter] = true

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: removeMinter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: allowedMinter[_old_minter] = false

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: mintTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[_for] = balances[_for].add(_value_wei)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.add(_value_wei)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(address(0),_for,_value_wei)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedMinter()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: destroyTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: balances[_for] = balances[_for].sub(_value_wei)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: totalSupply = totalSupply.sub(_value_wei)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: Transfer(_for,address(0),_value_wei)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyAllowedMinter()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: totalSupply = 0

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: name = Winsome.io Token

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: symbol = WIN

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: decimals = 18

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: Rouleth
==================================================

Function: Rouleth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: WINTOKENADDRESS = _winToken

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: winTokenInstance = WinToken(_winToken)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: developer = _developer

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: blockDelay = 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: blockExpiration = 245

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: minGamble = 10000000000000000

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: maxGamble = 1000000000000000000

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: emissionRate = 5

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8

Function: addBankroll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: onlyDeveloper()

Edges:
  0 -> 1

Function: removeBankroll
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: ! developer.send(_amount_wei)

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyDeveloper()

Edges:
  0 -> 4
  1 -> 2
  1 -> 3
  4 -> 1

Function: changeDeveloper_only_Dev
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: developer = new_dev

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyDeveloper()

Edges:
  0 -> 2
  2 -> 1

Function: changeSettings_only_Dev
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: emissionRate = newEmissionRate

  ID: 2
  Type: NodeType.IF
  Expression: newMaxGamble < newMinGamble

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: maxGamble = newMaxGamble

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: minGamble = newMinGamble

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: blockDelay = newBlockDelay

  ID: 8
  Type: NodeType.IF
  Expression: newBlockExpiration < blockDelay + 250

  ID: 9
  Type: NodeType.THROW
  Expression: 

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: blockExpiration = newBlockExpiration

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyDeveloper()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  10 -> 11
  12 -> 1

Function: fallback
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: betOnColor(false)

Edges:
  0 -> 1

Function: checkBetValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: msg.value < minGamble

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: msg.value > maxGamble

  ID: 5
  Type: NodeType.RETURN
  Expression: maxGamble

  ID: 6
  Type: NodeType.RETURN
  Expression: msg.value

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6

Function: placeBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: playerStatus[msg.sender] != Status.waitingForBet

  ID: 2
  Type: NodeType.IF
  Expression: ! SpinTheWheel(msg.sender)

  ID: 3
  Type: NodeType.THROW
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: playerStatus[msg.sender] = Status.waitingForSpin

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: gambleIndex[msg.sender] = gambles.length

  ID: 8
  Type: NodeType.VARIABLE
  Expression: betValue = checkBetValue()

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: pendingTokens[msg.sender] += betValue * emissionRate

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: gambles.push(Gamble(msg.sender,false,false,betType,input,betValue,block.number,0,37))

  ID: 11
  Type: NodeType.IF
  Expression: betValue < msg.value

  ID: 12
  Type: NodeType.IF
  Expression: msg.sender.send(msg.value - betValue) == false

  ID: 13
  Type: NodeType.THROW
  Expression: 

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 15
  12 -> 13
  12 -> 14
  14 -> 15

Function: getPendingTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: pendingTokens[account]

Edges:
  0 -> 1

Function: redeemTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: totalTokens = pendingTokens[msg.sender]

  ID: 2
  Type: NodeType.IF
  Expression: totalTokens == 0

  ID: 3
  Type: NodeType.RETURN
  Expression: 

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: pendingTokens[msg.sender] = 0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: winTokenInstance.mintTokens(msg.sender,totalTokens)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  5 -> 6

Function: betOnNumber
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: numberChosen > 36

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.number,numberChosen)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: betOnColor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: ! Black

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: input = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: input = 1

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.color,input)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: betOnLowHigh
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: ! High

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: input = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: input = 1

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.lowhigh,input)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: betOnOddEven
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: ! Odd

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: input = 0

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: input = 1

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.parity,input)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: betOnDozen
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: dozen_selected_0_1_2 > 2

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.dozen,dozen_selected_0_1_2)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: betOnColumn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: column_selected_0_1_2 > 2

  ID: 2
  Type: NodeType.THROW
  Expression: 

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: placeBet(BetTypes.column,column_selected_0_1_2)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4

Function: spinTheWheel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: SpinTheWheel(spin_for_player)

Edges:
  0 -> 1

Function: SpinTheWheel
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: playerSpinned == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: playerSpinned = msg.sender

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: playerStatus[playerSpinned] != Status.waitingForSpin

  ID: 5
  Type: NodeType.RETURN
  Expression: false

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: gambles[gambleIndex[playerSpinned]].spinned == true

  ID: 8
  Type: NodeType.THROW
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: playerblock = gambles[gambleIndex[playerSpinned]].blockNumber

  ID: 11
  Type: NodeType.IF
  Expression: block.number <= playerblock + blockDelay

  ID: 12
  Type: NodeType.THROW
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: block.number > playerblock + blockExpiration

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: solveBet(playerSpinned,255,false,1,0,0)

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.VARIABLE
  Expression: blockHash = block.blockhash(playerblock + blockDelay)

  ID: 17
  Type: NodeType.IF
  Expression: blockHash == 0

  ID: 18
  Type: NodeType.THROW
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.VARIABLE
  Expression: shaPlayer = sha3()(playerSpinned,blockHash,this)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: wheelResult = uint8(uint256(shaPlayer) % 37)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: checkBetResult(wheelResult,playerSpinned,blockHash,shaPlayer)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: true

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  13 -> 14
  13 -> 15
  14 -> 23
  15 -> 16
  16 -> 17
  17 -> 18
  17 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25

Function: checkBetResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: betType = gambles[gambleIndex[player]].betType

  ID: 2
  Type: NodeType.IF
  Expression: betType == BetTypes.number

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: checkBetNumber(result,player,blockHash,shaPlayer)

  ID: 4
  Type: NodeType.IF
  Expression: betType == BetTypes.parity

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: checkBetParity(result,player,blockHash,shaPlayer)

  ID: 6
  Type: NodeType.IF
  Expression: betType == BetTypes.color

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: checkBetColor(result,player,blockHash,shaPlayer)

  ID: 8
  Type: NodeType.IF
  Expression: betType == BetTypes.lowhigh

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: checkBetLowhigh(result,player,blockHash,shaPlayer)

  ID: 10
  Type: NodeType.IF
  Expression: betType == BetTypes.dozen

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: checkBetDozen(result,player,blockHash,shaPlayer)

  ID: 12
  Type: NodeType.IF
  Expression: betType == BetTypes.column

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: checkBetColumn(result,player,blockHash,shaPlayer)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 19
  4 -> 5
  4 -> 6
  5 -> 18
  6 -> 7
  6 -> 8
  7 -> 17
  8 -> 9
  8 -> 10
  9 -> 16
  10 -> 11
  10 -> 12
  11 -> 15
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19

Function: solveBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: playerStatus[player] = Status.waitingForBet

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: gambles[gambleIndex[player]].wheelResult = result

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: gambles[gambleIndex[player]].spinned = true

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: gambles[gambleIndex[player]].blockSpinned = block.number

  ID: 5
  Type: NodeType.VARIABLE
  Expression: bet_v = gambles[gambleIndex[player]].wager

  ID: 6
  Type: NodeType.IF
  Expression: win

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: gambles[gambleIndex[player]].win = true

  ID: 8
  Type: NodeType.VARIABLE
  Expression: win_v = (multiplier - 1) * bet_v

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: Win(player,result,win_v,blockHash,shaPlayer,gambleIndex[player],bet_v)

  ID: 10
  Type: NodeType.IF
  Expression: player.send(win_v + bet_v) == false

  ID: 11
  Type: NodeType.THROW
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: Loss(player,result,bet_v - 1,blockHash,shaPlayer,gambleIndex[player],bet_v)

  ID: 14
  Type: NodeType.IF
  Expression: player.send(1) == false

  ID: 15
  Type: NodeType.THROW
  Expression: 

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  6 -> 13
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  10 -> 12
  12 -> 17
  13 -> 14
  14 -> 15
  14 -> 16
  16 -> 17

Function: checkBetNumber
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: result == gambles[gambleIndex[player]].input

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,36,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: checkBetParity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: result % 2 == gambles[gambleIndex[player]].input && result != 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,2,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: checkBetLowhigh
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: result != 0 && ((result < 19 && gambles[gambleIndex[player]].input == 0) || (result > 18 && gambles[gambleIndex[player]].input == 1))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,2,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: checkBetColor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: k < 18

  ID: 6
  Type: NodeType.IF
  Expression: red_list[k] == result

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: red = true

  ID: 8
  Type: NodeType.BREAK
  Expression: 

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: k ++

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.IF
  Expression: result != 0 && ((gambles[gambleIndex[player]].input == 0 && red) || (gambles[gambleIndex[player]].input == 1 && ! red))

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,2,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 11
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  6 -> 9
  7 -> 8
  8 -> 3
  9 -> 10
  10 -> 5
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 14
  14 -> 15

Function: checkBetDozen
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: result != 0 && ((result < 13 && gambles[gambleIndex[player]].input == 0) || (result > 12 && result < 25 && gambles[gambleIndex[player]].input == 1) || (result > 24 && gambles[gambleIndex[player]].input == 2))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,3,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: checkBetColumn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.IF
  Expression: result != 0 && ((gambles[gambleIndex[player]].input == 0 && result % 3 == 1) || (gambles[gambleIndex[player]].input == 1 && result % 3 == 2) || (gambles[gambleIndex[player]].input == 2 && result % 3 == 0))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: win = true

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: solveBet(player,result,win,3,blockHash,shaPlayer)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: checkMyBet
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: player_status = playerStatus[player]

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: bettype = gambles[gambleIndex[player]].betType

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: input = gambles[gambleIndex[player]].input

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = gambles[gambleIndex[player]].wager

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: result = gambles[gambleIndex[player]].wheelResult

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: wheelspinned = gambles[gambleIndex[player]].spinned

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: win = gambles[gambleIndex[player]].win

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: blockNb = gambles[gambleIndex[player]].blockNumber

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: blockSpin = gambles[gambleIndex[player]].blockSpinned

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: gambleID = gambleIndex[player]

  ID: 11
  Type: NodeType.RETURN
  Expression: 

  ID: 12
  Type: NodeType.RETURN
  Expression: (player_status,bettype,input,value,result,wheelspinned,win,blockNb,blockSpin,gambleID)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11

Function: getTotalGambles
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: gambles.length

Edges:
  0 -> 1

Function: getGamblesList
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: player = gambles[index].player

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: bettype = gambles[index].betType

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: input = gambles[index].input

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: value = gambles[index].wager

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: result = gambles[index].wheelResult

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: wheelspinned = gambles[index].spinned

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: win = gambles[index].win

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: blockNb = gambles[index].blockNumber

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: blockSpin = gambles[index].blockSpinned

  ID: 10
  Type: NodeType.RETURN
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: (player,bettype,input,value,result,wheelspinned,win,blockNb,blockSpin)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: red_list = (1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36)

Edges:


