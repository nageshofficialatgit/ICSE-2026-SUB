Contract: IERC165
==================================================


Contract: SafeERC20
==================================================

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.transfer,(to,value)))

Edges:
  0 -> 1

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.transferFrom,(from,to,value)))

Edges:
  0 -> 1

Function: safeIncreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: forceApprove(token,spender,oldAllowance + value)

Edges:
  0 -> 1
  1 -> 2

Function: safeDecreaseAllowance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: currentAllowance = token.allowance(address(this),spender)

  ID: 2
  Type: NodeType.IF
  Expression: currentAllowance < requestedDecrease

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedDecreaseAllowance(address,uint256,uint256)(spender,currentAllowance,requestedDecrease)

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: forceApprove(token,spender,currentAllowance - requestedDecrease)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5

Function: forceApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: approvalCall = abi.encodeCall(token.approve,(spender,value))

  ID: 2
  Type: NodeType.IF
  Expression: ! _callOptionalReturnBool(token,approvalCall)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,abi.encodeCall(token.approve,(spender,0)))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _callOptionalReturn(token,approvalCall)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 5

Function: transferAndCallRelaxed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.code.length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: safeTransfer(token,to,value)

  ID: 3
  Type: NodeType.IF
  Expression: ! token.transferAndCall(to,value,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedOperation(address)(address(token))

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: transferFromAndCallRelaxed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.code.length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: safeTransferFrom(token,from,to,value)

  ID: 3
  Type: NodeType.IF
  Expression: ! token.transferFromAndCall(from,to,value,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedOperation(address)(address(token))

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: approveAndCallRelaxed
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: to.code.length == 0

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: forceApprove(token,to,value)

  ID: 3
  Type: NodeType.IF
  Expression: ! token.approveAndCall(to,value,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedOperation(address)(address(token))

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 6
  3 -> 4
  3 -> 5
  4 -> 5
  5 -> 6

Function: _callOptionalReturn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: success__callOptionalReturn_asm_0 = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data + 0x20,mload(uint256)(data),0,0x20)

  ID: 6
  Type: NodeType.IF
  Expression: ! success__callOptionalReturn_asm_0

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ptr__callOptionalReturn_asm_0 = mload(uint256)(0x40)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: returndatacopy(uint256,uint256,uint256)(ptr__callOptionalReturn_asm_0,0,returndatasize()())

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(ptr__callOptionalReturn_asm_0,returndatasize()())

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: returnSize = returndatasize()()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: returnValue = mload(uint256)(0)

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: revert SafeERC20FailedOperation(address)(address(token))

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: returnSize == 0

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: address(token).code.length == 0

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: returnValue != 1

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  6 -> 7
  7 -> 12
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 7
  12 -> 13
  13 -> 14
  14 -> 18
  16 -> 17
  18 -> 19
  18 -> 20
  19 -> 21
  20 -> 21
  21 -> 16
  21 -> 17

Function: _callOptionalReturnBool
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: success = call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,data + 0x20,mload(uint256)(data),0,0x20)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: returnSize = returndatasize()()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: returnValue = mload(uint256)(0)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.IF
  Expression: returnSize == 0

  ID: 11
  Type: NodeType.RETURN
  Expression: success && address(token).code.length > 0

  ID: 12
  Type: NodeType.RETURN
  Expression: success && returnValue == 1

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  10 -> 11
  10 -> 12


Contract: Context
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1


Contract: IERC20
==================================================


Contract: IERC1363
==================================================


Contract: Ownable
==================================================

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: initialOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(initialOwner)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: ReentrancyGuard
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: NOT_ENTERED = 1

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ENTERED = 2

Edges:
  0 -> 1


Contract: DogeFatherStaking
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_stakingToken != address(0),Zero staking token address)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_rewardToken != address(0),Zero reward token address)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_penaltyRecipient != address(0),Zero address is not allowed)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_penaltyRecipient2 != address(0),Zero address is not allowed)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: stakingToken = IERC20(_stakingToken)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: rewardToken = IERC20(_rewardToken)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_monthlyDistributionAmount > 0,Invalid amount)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: penaltyRecipient = _penaltyRecipient

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: penaltyRecipient2 = _penaltyRecipient2

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: history.push(History(block.timestamp,0,0))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: monthlyDistributionAmount = _monthlyDistributionAmount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: stakingStartTime = 0

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: renounceOwnership()

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: Ownable(msg.sender)

Edges:
  0 -> 14
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  14 -> 1

Function: owner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _owner

Edges:
  0 -> 1

Function: _checkOwner
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: owner() != _msgSender()

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableUnauthorizedAccount(address)(_msgSender())

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3

Function: renounceOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(address(0))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 2
  2 -> 1

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: newOwner == address(0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert OwnableInvalidOwner(address)(address(0))

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _transferOwnership(newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  5 -> 1

Function: _transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldOwner = _owner

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _owner = newOwner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: _msgSender
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.sender

Edges:
  0 -> 1

Function: _msgData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: msg.data

Edges:
  0 -> 1

Function: _contextSuffixLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1

Function: _nonReentrantBefore
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _status == ENTERED

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert ReentrancyGuardReentrantCall()()

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _status = ENTERED

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4

Function: _nonReentrantAfter
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: _status = NOT_ENTERED

Edges:
  0 -> 1

Function: _reentrancyGuardEntered
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: _status == ENTERED

Edges:
  0 -> 1

Function: _updateAccumulator
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: block.timestamp <= stakingStartTime + STAKING_DEADLINE && totalWeightedStake > 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: timeDelta = block.timestamp - lastRewardUpdate

  ID: 3
  Type: NodeType.VARIABLE
  Expression: rewardDelta = (monthlyDistributionAmount * timeDelta * PRECISION) / (totalWeightedStake * DISTRIBUTION_INTERVAL)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: accRewardPerWeight += rewardDelta

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: lastRewardUpdate = block.timestamp

Edges:
  0 -> 1
  1 -> 2
  1 -> 5
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: _updateHistory
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: history.length > 0 && history[history.length - 1].time == block.timestamp

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: history[history.length - 1].totalWeightedStake = totalWeightedStake

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: history[history.length - 1].accRewardPerWeight = accRewardPerWeight

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: history.push(History(block.timestamp,totalWeightedStake,accRewardPerWeight))

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 4
  2 -> 3
  3 -> 5
  4 -> 5

Function: getAccRewardPerWeightAt
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: history.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: left = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: right = history.length - 1

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: left < right

  ID: 8
  Type: NodeType.VARIABLE
  Expression: mid = left + (right - left + 1) / 2

  ID: 9
  Type: NodeType.IF
  Expression: history[mid].time <= targetTime

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: left = mid

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: right = mid - 1

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: h = history[left]

  ID: 15
  Type: NodeType.IF
  Expression: h.time > targetTime

  ID: 16
  Type: NodeType.RETURN
  Expression: 0

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: h.totalWeightedStake == 0

  ID: 19
  Type: NodeType.RETURN
  Expression: h.accRewardPerWeight

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.VARIABLE
  Expression: timeDelta = targetTime - h.time

  ID: 22
  Type: NodeType.VARIABLE
  Expression: rewardDelta = (monthlyDistributionAmount * timeDelta * PRECISION) / (h.totalWeightedStake * DISTRIBUTION_INTERVAL)

  ID: 23
  Type: NodeType.RETURN
  Expression: h.accRewardPerWeight + rewardDelta

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 13
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 7
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  17 -> 18
  18 -> 19
  18 -> 20
  20 -> 21
  21 -> 22
  22 -> 23

Function: stake
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(stakingStartTime > 0 && block.timestamp >= stakingStartTime,Staking has not started yet)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp <= stakingStartTime + STAKING_DEADLINE,Staking period has ended)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,Cannot stake zero tokens)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: minStake = 1000 * (10 ** 18)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount >= minStake,Amount must be greater than or equal to 1000)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(stakes[msg.sender].length < 15,Maximum stakes reached)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(lockUpPeriod == SEVEN_DAYS || lockUpPeriod == FIVETEEN_DAYS || lockUpPeriod == THIRTY_DAYS,Invalid lock-up period)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: apr = getAPRForLockupPeriod(lockUpPeriod)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: weighted = (amount * apr) / 10000

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: stakes[msg.sender].push(Stake({amount:amount,startTime:block.timestamp,lockUpPeriod:lockUpPeriod,apr:apr,weightedStake:weighted,rewardDebt:accRewardPerWeight}))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: totalStakedAmount += amount

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: totalWeightedStake += weighted

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: _updateHistory()

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: stakingToken.safeTransferFrom(msg.sender,address(this),amount)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: Staked(msg.sender,amount,lockUpPeriod,apr)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: updateRewards()

Edges:
  0 -> 16
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  16 -> 17
  17 -> 1

Function: unstake
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(index < stakes[msg.sender].length,Invalid stake index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: userStake = stakes[msg.sender][index]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: stakeEndTime = userStake.startTime + userStake.lockUpPeriod

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp >= stakeEndTime,Lock-up period not completed)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: stakingPeriodEnd = stakingStartTime + STAKING_DEADLINE

  ID: 7
  Type: NodeType.VARIABLE
  Expression: accAtEnd = getAccRewardPerWeightAt(rewardEndTime)

  ID: 8
  Type: NodeType.VARIABLE
  Expression: reward = (userStake.weightedStake * (accAtEnd - userStake.rewardDebt)) / PRECISION

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reward <= rewardToken.balanceOf(address(this)),Insufficient rewards pool)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: totalStakedAmount -= userStake.amount

  ID: 11
  Type: NodeType.IF
  Expression: totalWeightedStake > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: totalWeightedStake -= userStake.weightedStake

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.IF
  Expression: index != stakes[msg.sender].length - 1

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: stakes[msg.sender][index] = stakes[msg.sender][stakes[msg.sender].length - 1]

  ID: 16
  Type: NodeType.ENDIF
  Expression: 

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: stakes[msg.sender].pop()

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: _updateHistory()

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _updateRewardDistributeTracker(reward)

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: stakingToken.safeTransfer(msg.sender,userStake.amount)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: rewardToken.safeTransfer(msg.sender,reward)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: Unstaked(msg.sender,userStake.amount,reward)

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: updateRewards()

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 25
  Type: NodeType.IF
  Expression: stakeEndTime < stakingPeriodEnd

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakeEndTime

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakingPeriodEnd

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 23
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 25
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 16
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  23 -> 24
  24 -> 1
  25 -> 26
  25 -> 27
  26 -> 28
  27 -> 28
  28 -> 7

Function: claimReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(index < stakes[msg.sender].length,Invalid stake index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: userStake = stakes[msg.sender][index]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: stakeEndTime = userStake.startTime + userStake.lockUpPeriod

  ID: 4
  Type: NodeType.VARIABLE
  Expression: stakingPeriodEnd = stakingStartTime + STAKING_DEADLINE

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: block.timestamp >= rewardEndTime

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: effectiveAcc = getAccRewardPerWeightAt(rewardEndTime)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: effectiveAcc = accRewardPerWeight

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: reward = (userStake.weightedStake * (effectiveAcc - userStake.rewardDebt)) / PRECISION

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reward > 0,No rewards to claim)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reward <= rewardToken.balanceOf(address(this)),Insufficient rewards pool)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: _updateRewardDistributeTracker(reward)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: userStake.rewardDebt = effectiveAcc

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: rewardToken.safeTransfer(msg.sender,reward)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: RewardClaimed(msg.sender,reward)

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: updateRewards()

  ID: 20
  Type: NodeType.IF
  Expression: stakeEndTime < stakingPeriodEnd

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakeEndTime

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakingPeriodEnd

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 18
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 20
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  18 -> 19
  19 -> 1
  20 -> 21
  20 -> 22
  21 -> 23
  22 -> 23
  23 -> 6

Function: calculateReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: stakeEndTime = userStake.startTime + userStake.lockUpPeriod

  ID: 2
  Type: NodeType.VARIABLE
  Expression: stakingPeriodEnd = stakingStartTime + STAKING_DEADLINE

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IF
  Expression: block.timestamp >= rewardEndTime

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: effectiveAcc = getAccRewardPerWeightAt(rewardEndTime)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: effectiveAcc = accRewardPerWeight

  ID: 8
  Type: NodeType.IF
  Expression: block.timestamp > lastRewardUpdate && totalWeightedStake > 0 && block.timestamp <= stakingPeriodEnd

  ID: 9
  Type: NodeType.VARIABLE
  Expression: timeDelta = block.timestamp - lastRewardUpdate

  ID: 10
  Type: NodeType.VARIABLE
  Expression: pending = (monthlyDistributionAmount * timeDelta * PRECISION) / (totalWeightedStake * DISTRIBUTION_INTERVAL)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: effectiveAcc += pending

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.RETURN
  Expression: (userStake.weightedStake * (effectiveAcc - userStake.rewardDebt)) / PRECISION

  ID: 15
  Type: NodeType.IF
  Expression: stakeEndTime < stakingPeriodEnd

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakeEndTime

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: rewardEndTime = stakingPeriodEnd

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 15
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 13
  7 -> 8
  8 -> 9
  8 -> 12
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 4

Function: emergencyUnstake
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(stakeIndex < stakes[msg.sender].length,Invalid stake index)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: userStake = stakes[msg.sender][stakeIndex]

  ID: 3
  Type: NodeType.VARIABLE
  Expression: penaltyPercent = 2000

  ID: 4
  Type: NodeType.VARIABLE
  Expression: totalPenalty = (userStake.amount * penaltyPercent) / 10000

  ID: 5
  Type: NodeType.VARIABLE
  Expression: penaltyRecipientPortion = (totalPenalty * 75) / 100

  ID: 6
  Type: NodeType.VARIABLE
  Expression: remainingPenalty = totalPenalty - penaltyRecipientPortion

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: stakingToken.safeTransfer(msg.sender,userStake.amount - totalPenalty)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: stakingToken.safeTransfer(penaltyRecipient,penaltyRecipientPortion)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: stakingToken.safeTransfer(penaltyRecipient2,remainingPenalty)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: totalStakedAmount -= userStake.amount

  ID: 11
  Type: NodeType.IF
  Expression: totalWeightedStake > 0

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: totalWeightedStake -= userStake.weightedStake

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: lastIndex = stakes[msg.sender].length - 1

  ID: 15
  Type: NodeType.IF
  Expression: stakeIndex != lastIndex

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: stakes[msg.sender][stakeIndex] = stakes[msg.sender][lastIndex]

  ID: 17
  Type: NodeType.ENDIF
  Expression: 

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: stakes[msg.sender].pop()

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _updateHistory()

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: EmergencyUnstaked(msg.sender,userStake.amount - totalPenalty,totalPenalty)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: updateRewards()

Edges:
  0 -> 21
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  21 -> 22
  22 -> 1

Function: startStaking
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == penaltyRecipient,Unknow caller)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(stakingStartTime == 0,Staking already started)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: stakingStartTime = block.timestamp

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: lastRewardUpdate = block.timestamp

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: _updateRewardDistributeTracker
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: totalDistributedRewards += rewardAmount

Edges:
  0 -> 1

Function: getStakeCount
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: stakes[user].length

Edges:
  0 -> 1

Function: getAPRForLockupPeriod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: lockupPeriod == SEVEN_DAYS

  ID: 2
  Type: NodeType.RETURN
  Expression: sevenDaysAPR

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: lockupPeriod == FIVETEEN_DAYS

  ID: 5
  Type: NodeType.RETURN
  Expression: fiveteenDaysAPR

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.IF
  Expression: lockupPeriod == THIRTY_DAYS

  ID: 8
  Type: NodeType.RETURN
  Expression: thirtyDaysAPR

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.RETURN
  Expression: 0

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  9 -> 10

Function: recoverERC20
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == penaltyRecipient,Unknow caller)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token != address(stakingToken) && token != address(rewardToken),Cannot recover staking/reward tokens)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IERC20(token).safeTransfer(msg.sender,amount)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getRewardPoolBalance
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: rewardToken.balanceOf(address(this))

Edges:
  0 -> 1

Function: sweepRemainingRewardTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == penaltyRecipient,Unknow caller)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: sweepUnlockTime = stakingStartTime + STAKING_DEADLINE + SWEEP_GRACE_PERIOD

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(block.timestamp > sweepUnlockTime,Sweep grace period not yet ended)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: remainingBalance = rewardToken.balanceOf(address(this))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(remainingBalance > 0,No reward tokens to sweep)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: rewardToken.safeTransfer(msg.sender,remainingBalance)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: RewardTokenSweep(msg.sender,remainingBalance)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: DISTRIBUTION_INTERVAL = THIRTY_DAYS

Edges:

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SEVEN_DAYS = 604800

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: FIVETEEN_DAYS = 1296000

  ID: 2
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: THIRTY_DAYS = 2592000

  ID: 3
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: sevenDaysAPR = 2000

  ID: 4
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: fiveteenDaysAPR = 4000

  ID: 5
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: thirtyDaysAPR = 6000

  ID: 6
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: SWEEP_GRACE_PERIOD = 3456000

  ID: 7
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: PRECISION = 1e18

  ID: 8
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: STAKING_DEADLINE = THIRTY_DAYS

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8


