Contract: IERC20
==================================================


Contract: IPoolV3
==================================================


Contract: IAggregatorV3
==================================================


Contract: Treasury
==================================================

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! _initialized,Treasury: already initialized)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: _initialized = true

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = _owner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: usdc = _usdc

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: aEthUSDC = _aEthUSDC

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: poolV3 = _poolV3

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: frankencoin = _frankencoin

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: hyperSolverToken = _hyperSolverToken

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: epoch = block.timestamp

  ID: 10
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 11
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 13
  Type: NodeType.IFLOOP
  Expression: i < _whitelist.length

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: whitelisted[_whitelist[i]] = true

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: WhitelistUpdated(_whitelist[i],true)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: TreasuryInitialized(_owner,_usdc,_aEthUSDC,_poolV3,_frankencoin,_hyperSolverToken)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 12
  10 -> 13
  11 -> 17
  12 -> 10
  13 -> 14
  13 -> 11
  14 -> 15
  15 -> 16
  16 -> 13

Function: transferOwnership
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(newOwner != address(0),Treasury: new owner is the zero address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: oldOwner = owner

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: owner = newOwner

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: OwnershipTransferred(oldOwner,newOwner)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: updateWhitelist
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < accounts.length

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: whitelisted[accounts[i]] = isWL

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: WhitelistUpdated(accounts[i],isWL)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 8
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  6 -> 7
  7 -> 4
  8 -> 3

Function: setCHFUSDOracle
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_oracle != address(0),Treasury: invalid oracle address)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: oldOracle = chfUsdOracle

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (roundId,answer,None,updatedAt,None) = IAggregatorV3(_oracle).latestRoundData()

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(roundId > 0,Treasury: invalid roundId)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(answer > 0,Treasury: oracle price <= 0)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(updatedAt >= block.timestamp - maxDelay,Treasury: oracle data is stale)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: chfUsdOracle = _oracle

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: CHFUSDOracleUpdated(oldOracle,_oracle,roundId,answer,updatedAt)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 12
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 1

Function: setMaxDelay
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(_delay <= 604800,Treasury: maxDelay cannot exceed 7 days)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: oldDelay = maxDelay

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: maxDelay = _delay

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: MaxDelayUpdated(oldDelay,_delay)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: afterDeposit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: AfterDeposit(depositor,usdcAmount,depositCount,timestamp)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TransferDeposit(msg.sender,usdcAmount)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IERC20(usdc).transferFrom(msg.sender,address(this),usdcAmount)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: userTotalDepositedUSDC[depositor] += usdcAmount

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: totalDepositedUSDC += usdcAmount

  ID: 6
  Type: NodeType.VARIABLE
  Expression: balance = IERC20(usdc).balanceOf(address(this))

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: IERC20(usdc).approve(poolV3,balance)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: IPoolV3(poolV3).deposit(usdc,balance,address(this),0)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: aEthBalance = IERC20(aEthUSDC).balanceOf(address(this))

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: PoolV3Deposit(depositCount,block.timestamp,aEthBalance)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: onlyWhitelisted()

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  11 -> 12
  12 -> 1

Function: withdrawFromAave
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: received = IPoolV3(poolV3).withdraw(usdc,amount,address(this))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: PoolV3Withdrawal(amount,received)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 3
  1 -> 2
  3 -> 1

Function: withdrawRewards
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(recipients.length == amounts.length,Treasury: arrays length mismatch)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: rewardWithdrawCount ++

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.IF
  Expression: tokenType == 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: rewardToken = usdc

  ID: 6
  Type: NodeType.IF
  Expression: tokenType == 1

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: rewardToken = aEthUSDC

  ID: 8
  Type: NodeType.IF
  Expression: tokenType == 2

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: rewardToken = frankencoin

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Treasury: invalid token type)

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.ENDIF
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: currentOp = rewardWithdrawCount

  ID: 15
  Type: NodeType.VARIABLE
  Expression: currentTimestamp = block.timestamp

  ID: 16
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 19
  Type: NodeType.IFLOOP
  Expression: i < recipients.length

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(rewardToken).transfer(recipients[i],amounts[i]),Treasury: token transfer failed)

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: RewardWithdrawn(recipients[i],amounts[i],tokenType,currentOp,currentTimestamp)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 23
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 6
  5 -> 13
  6 -> 7
  6 -> 8
  7 -> 12
  8 -> 9
  8 -> 10
  9 -> 11
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 18
  16 -> 19
  18 -> 16
  19 -> 20
  19 -> 17
  20 -> 21
  21 -> 22
  22 -> 19
  23 -> 1

Function: setGlobalRewardRatio
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: oldRatio = globalRewardRatio

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: globalRewardRatio = newRatio

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: GlobalRewardRatioUpdated(oldRatio,newRatio)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: getUserRewardInFrankencoin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: hpsTotalSupply = IERC20(hyperSolverToken).totalSupply()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: userDeposited = userTotalDepositedUSDC[user]

  ID: 3
  Type: NodeType.IF
  Expression: hpsTotalSupply == 0 || userDeposited == 0 || userTokenVested == 0

  ID: 4
  Type: NodeType.RETURN
  Expression: 0

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (roundId,answer,None,updatedAt,None) = IAggregatorV3(chfUsdOracle).latestRoundData()

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(roundId > 0,Treasury: invalid roundId from oracle)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(answer > 0,Treasury: oracle price <= 0)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(updatedAt >= block.timestamp - maxDelay,Treasury: oracle data is stale)

  ID: 13
  Type: NodeType.VARIABLE
  Expression: chfUsdPrice = uint256(answer)

  ID: 14
  Type: NodeType.VARIABLE
  Expression: numerator = userTokenVested * 100000000 * globalRewardRatio

  ID: 15
  Type: NodeType.VARIABLE
  Expression: denominator = hpsTotalSupply * chfUsdPrice * userDeposited

  ID: 16
  Type: NodeType.IF
  Expression: denominator == 0

  ID: 17
  Type: NodeType.RETURN
  Expression: 0

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: rewardInZCHF = numerator / denominator

  ID: 20
  Type: NodeType.RETURN
  Expression: rewardInZCHF

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 18
  18 -> 19
  19 -> 20

Function: claimFrankencoinReward
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: block.timestamp >= epoch + 16416000

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: epoch += 16416000

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! userClaimedEpoch[user][epoch],Treasury: user already claimed this epoch)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: rewardAmount = getUserRewardInFrankencoin(user,userTokenVested)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(rewardAmount > 0,Treasury: reward amount is zero)

  ID: 7
  Type: NodeType.VARIABLE
  Expression: contractBalance = IERC20(frankencoin).balanceOf(address(this))

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(contractBalance >= rewardAmount,Treasury: insufficient Frankencoin balance)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: userClaimedEpoch[user][epoch] = true

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(frankencoin).transfer(user,rewardAmount),Treasury: Frankencoin transfer failed)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: FrankencoinRewardClaimed(user,epoch,rewardAmount)

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: onlyWhitelisted()

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: nonReentrant()

Edges:
  0 -> 12
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  12 -> 13
  13 -> 1

Function: topUpFrankencoin
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amount > 0,Treasury: amount must be greater than 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(frankencoin).transferFrom(msg.sender,address(this),amount),Treasury: Frankencoin transfer failed)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: FrankencoinToppedUp(amount)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: claimStuckETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balance = address(this).balance

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(balance > 0,Treasury: no ETH to claim)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: address(owner).transfer(balance)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: StuckETHClaimed(owner,balance)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: claimStuckERC20
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 4
  Type: NodeType.IFLOOP
  Expression: i < tokens.length

  ID: 5
  Type: NodeType.IF
  Expression: tokens[i] == usdc || tokens[i] == aEthUSDC || tokens[i] == frankencoin

  ID: 6
  Type: NodeType.CONTINUE
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: balance = IERC20(tokens[i]).balanceOf(address(this))

  ID: 9
  Type: NodeType.IF
  Expression: balance > 0

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: IERC20(tokens[i]).transfer(owner,balance)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: StuckERC20Claimed(owner,tokens[i],balance)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: onlyOwner()

Edges:
  0 -> 14
  1 -> 4
  3 -> 1
  4 -> 5
  4 -> 2
  5 -> 6
  5 -> 7
  6 -> 13
  7 -> 8
  8 -> 9
  9 -> 10
  9 -> 12
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 4
  14 -> 3


