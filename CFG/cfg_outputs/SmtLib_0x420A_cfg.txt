Contract: PoseidonUnit1L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: PoseidonUnit2L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: PoseidonUnit3L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: PoseidonUnit4L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: PoseidonUnit5L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: PoseidonUnit6L
==================================================

Function: poseidon
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:


Contract: SpongePoseidon
==================================================

Function: hash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: frame = (uint256(0),0,0,0,0,0)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: dirty = false

  ID: 3
  Type: NodeType.VARIABLE
  Expression: fullHash = 0

  ID: 4
  Type: NodeType.VARIABLE
  Expression: k = 0

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < values.length

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: dirty = true

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: frame[k] = values[i]

  ID: 11
  Type: NodeType.IF
  Expression: k == BATCH_SIZE - 1

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: fullHash = PoseidonUnit6L.poseidon(frame)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: dirty = false

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: frame = (uint256(0),0,0,0,0,0)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: frame[0] = fullHash

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: k = 1

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: k ++

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 20
  Type: NodeType.IF
  Expression: dirty

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: fullHash = PoseidonUnit6L.poseidon(frame)

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.RETURN
  Expression: fullHash

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 20
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 17
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 8
  20 -> 21
  20 -> 22
  21 -> 22
  22 -> 23

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: BATCH_SIZE = 6

Edges:


Contract: PoseidonFacade
==================================================

Function: poseidon1
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit1L.poseidon(el)

Edges:
  0 -> 1

Function: poseidon2
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit2L.poseidon(el)

Edges:
  0 -> 1

Function: poseidon3
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit3L.poseidon(el)

Edges:
  0 -> 1

Function: poseidon4
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit4L.poseidon(el)

Edges:
  0 -> 1

Function: poseidon5
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit5L.poseidon(el)

Edges:
  0 -> 1

Function: poseidon6
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: PoseidonUnit6L.poseidon(el)

Edges:
  0 -> 1

Function: poseidonSponge
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: SpongePoseidon.hash(el)

Edges:
  0 -> 1


Contract: ArrayUtils
==================================================

Function: calculateBounds
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(length > 0,Length should be greater than 0)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(length <= limit,Length limit exceeded)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(start < arrLength,Start index out of bounds)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: end = start + length

  ID: 5
  Type: NodeType.IF
  Expression: end > arrLength

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: end = arrLength

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (start,end)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8


Contract: SmtLib
==================================================

Function: addLeaf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: node = Node({nodeType:NodeType.LEAF,childLeft:0,childRight:0,index:i,value:v})

  ID: 2
  Type: NodeType.VARIABLE
  Expression: prevRoot = getRoot(self)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: newRoot = _addLeaf(self,node,prevRoot,0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _addEntry(self,newRoot,block.timestamp,block.number)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: onlyInitialized(self)

Edges:
  0 -> 5
  1 -> 2
  2 -> 3
  3 -> 4
  5 -> 1

Function: getRootHistoryLength
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.rootEntries.length

Edges:
  0 -> 1

Function: getRootHistory
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (start,end) = ArrayUtils.calculateBounds(self.rootEntries.length,startIndex,length,ROOT_INFO_LIST_RETURN_LIMIT)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: result = new SmtLib.RootEntryInfo[](end - start)

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = start

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < end

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: result[i - start] = _getRootInfoByIndex(self,i)

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 11
  Type: NodeType.RETURN
  Expression: result

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 11
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 8

Function: getNode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.nodes[nodeHash]

Edges:
  0 -> 1

Function: getProof
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: getProofByRoot(self,index,getRoot(self))

Edges:
  0 -> 1

Function: getProofByRoot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: siblings = new uint256[](self.maxDepth)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < self.maxDepth

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: siblings[i] = 0

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 8
  Type: NodeType.VARIABLE
  Expression: proof = Proof({root:historicalRoot,existence:false,siblings:siblings,index:index,value:0,auxExistence:false,auxIndex:0,auxValue:0})

  ID: 9
  Type: NodeType.VARIABLE
  Expression: nextNodeHash = historicalRoot

  ID: 10
  Type: NodeType.VARIABLE
  Expression: 

  ID: 11
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 12
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 13
  Type: NodeType.VARIABLE
  Expression: i_scope_0 = 0

  ID: 14
  Type: NodeType.IFLOOP
  Expression: i_scope_0 <= self.maxDepth

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: node = getNode(self,nextNodeHash)

  ID: 16
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.EMPTY

  ID: 17
  Type: NodeType.BREAK
  Expression: 

  ID: 18
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.LEAF

  ID: 19
  Type: NodeType.IF
  Expression: node.index == proof.index

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: proof.existence = true

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: proof.value = node.value

  ID: 22
  Type: NodeType.BREAK
  Expression: 

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: proof.auxExistence = true

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: proof.auxIndex = node.index

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: proof.auxValue = node.value

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: proof.value = node.value

  ID: 27
  Type: NodeType.BREAK
  Expression: 

  ID: 29
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.MIDDLE

  ID: 30
  Type: NodeType.IF
  Expression: (proof.index >> i_scope_0) & 1 == 1

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: nextNodeHash = node.childRight

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: proof.siblings[i_scope_0] = node.childLeft

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: nextNodeHash = node.childLeft

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: proof.siblings[i_scope_0] = node.childRight

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Invalid node type)

  ID: 37
  Type: NodeType.ENDIF
  Expression: 

  ID: 38
  Type: NodeType.ENDIF
  Expression: 

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: i_scope_0 ++

  ID: 41
  Type: NodeType.RETURN
  Expression: proof

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: onlyExistingRoot(self,historicalRoot)

Edges:
  0 -> 42
  1 -> 4
  2 -> 5
  3 -> 8
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 5
  8 -> 9
  9 -> 10
  10 -> 13
  11 -> 14
  12 -> 41
  13 -> 11
  14 -> 15
  14 -> 12
  15 -> 16
  16 -> 17
  16 -> 18
  17 -> 12
  18 -> 19
  18 -> 29
  19 -> 20
  19 -> 23
  20 -> 21
  21 -> 22
  22 -> 12
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 12
  29 -> 30
  29 -> 36
  30 -> 31
  30 -> 33
  31 -> 32
  32 -> 35
  33 -> 34
  34 -> 35
  35 -> 37
  36 -> 37
  37 -> 38
  38 -> 39
  39 -> 40
  40 -> 14
  42 -> 1

Function: getProofByTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: rootInfo = getRootInfoByTime(self,timestamp)

  ID: 2
  Type: NodeType.RETURN
  Expression: getProofByRoot(self,index,rootInfo.root)

Edges:
  0 -> 1
  1 -> 2

Function: getProofByBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: rootInfo = getRootInfoByBlock(self,blockNumber)

  ID: 2
  Type: NodeType.RETURN
  Expression: getProofByRoot(self,index,rootInfo.root)

Edges:
  0 -> 1
  1 -> 2

Function: getRoot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.rootEntries[self.rootEntries.length - 1].root

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: onlyInitialized(self)

Edges:
  0 -> 2
  2 -> 1

Function: getRootInfoByTime
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(timestamp <= block.timestamp,No future timestamps allowed)

  ID: 2
  Type: NodeType.RETURN
  Expression: _getRootInfoByTimestampOrBlock(self,timestamp,BinarySearchSmtRoots.SearchType.TIMESTAMP)

Edges:
  0 -> 1
  1 -> 2

Function: getRootInfoByBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(blockN <= block.number,No future blocks allowed)

  ID: 2
  Type: NodeType.RETURN
  Expression: _getRootInfoByTimestampOrBlock(self,blockN,BinarySearchSmtRoots.SearchType.BLOCK)

Edges:
  0 -> 1
  1 -> 2

Function: getRootInfo
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: indexes = self.rootIndexes[root]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: lastIndex = indexes[indexes.length - 1]

  ID: 3
  Type: NodeType.RETURN
  Expression: _getRootInfoByIndex(self,lastIndex)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: onlyExistingRoot(self,root)

Edges:
  0 -> 4
  1 -> 2
  2 -> 3
  4 -> 1

Function: getRootInfoListLengthByRoot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.rootIndexes[root].length

Edges:
  0 -> 1

Function: getRootInfoListByRoot
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: indexes = self.rootIndexes[root]

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (start,end) = ArrayUtils.calculateBounds(indexes.length,startIndex,length,ROOT_INFO_LIST_RETURN_LIMIT)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: result = new SmtLib.RootEntryInfo[](end - start)

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: i = start

  ID: 9
  Type: NodeType.IFLOOP
  Expression: i < end

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: result[i - start] = _getRootInfoByIndex(self,indexes[i])

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 12
  Type: NodeType.RETURN
  Expression: result

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: onlyExistingRoot(self,root)

Edges:
  0 -> 13
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 8
  6 -> 9
  7 -> 12
  8 -> 6
  9 -> 10
  9 -> 7
  10 -> 11
  11 -> 9
  13 -> 1

Function: rootExists
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.rootIndexes[root].length > 0

Edges:
  0 -> 1

Function: setMaxDepth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(maxDepth > 0,Max depth must be greater than zero)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(maxDepth > self.maxDepth,Max depth can only be increased)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(maxDepth <= MAX_DEPTH_HARD_CAP,Max depth is greater than hard cap)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: self.maxDepth = maxDepth

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getMaxDepth
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.maxDepth

Edges:
  0 -> 1

Function: initialize
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(! isInitialized(self),Smt is already initialized)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: setMaxDepth(self,maxDepth)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _addEntry(self,0,0,0)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: self.initialized = true

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: isInitialized
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: self.initialized

Edges:
  0 -> 1

Function: _addLeaf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: depth > self.maxDepth

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Max depth reached)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: node = self.nodes[nodeHash]

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: leafHash = 0

  ID: 7
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.EMPTY

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: leafHash = _addNode(self,newLeaf)

  ID: 9
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.LEAF

  ID: 11
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.MIDDLE

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.IF
  Expression: (newLeaf.index >> depth) & 1 == 1

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: nextNodeHash = _addLeaf(self,newLeaf,node.childRight,depth + 1)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node({nodeType:NodeType.MIDDLE,childLeft:node.childLeft,childRight:nextNodeHash,index:0,value:0})

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: nextNodeHash = _addLeaf(self,newLeaf,node.childLeft,depth + 1)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node({nodeType:NodeType.MIDDLE,childLeft:nextNodeHash,childRight:node.childRight,index:0,value:0})

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: leafHash = _addNode(self,newNodeMiddle)

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.ENDIF
  Expression: 

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.RETURN
  Expression: leafHash

  ID: 24
  Type: NodeType.IF
  Expression: node.index == newLeaf.index

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: leafHash = _addNode(self,newLeaf)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: leafHash = _pushLeaf(self,newLeaf,node,depth)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 9
  8 -> 22
  9 -> 24
  9 -> 11
  11 -> 12
  11 -> 20
  12 -> 13
  13 -> 14
  13 -> 16
  14 -> 15
  15 -> 18
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  24 -> 25
  24 -> 26
  25 -> 27
  26 -> 27
  27 -> 21

Function: _pushLeaf
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: depth >= self.maxDepth

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Max depth reached)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: newLeafBitAtDepth = (newLeaf.index >> depth) & 1 == 1

  ID: 6
  Type: NodeType.VARIABLE
  Expression: oldLeafBitAtDepth = (oldLeaf.index >> depth) & 1 == 1

  ID: 7
  Type: NodeType.IF
  Expression: newLeafBitAtDepth == oldLeafBitAtDepth

  ID: 8
  Type: NodeType.VARIABLE
  Expression: nextNodeHash = _pushLeaf(self,newLeaf,oldLeaf,depth + 1)

  ID: 9
  Type: NodeType.IF
  Expression: newLeafBitAtDepth

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node(NodeType.MIDDLE,0,nextNodeHash,0,0)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node(NodeType.MIDDLE,nextNodeHash,0,0,0)

  ID: 12
  Type: NodeType.ENDIF
  Expression: 

  ID: 13
  Type: NodeType.RETURN
  Expression: _addNode(self,newNodeMiddle)

  ID: 14
  Type: NodeType.ENDIF
  Expression: 

  ID: 15
  Type: NodeType.IF
  Expression: newLeafBitAtDepth

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node({nodeType:NodeType.MIDDLE,childLeft:_getNodeHash(oldLeaf),childRight:_getNodeHash(newLeaf),index:0,value:0})

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: newNodeMiddle = Node({nodeType:NodeType.MIDDLE,childLeft:_getNodeHash(newLeaf),childRight:_getNodeHash(oldLeaf),index:0,value:0})

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: _addNode(self,newLeaf)

  ID: 20
  Type: NodeType.RETURN
  Expression: _addNode(self,newNodeMiddle)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 14
  8 -> 9
  9 -> 10
  9 -> 11
  10 -> 12
  11 -> 12
  12 -> 13
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20

Function: _addNode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: nodeHash = _getNodeHash(node)

  ID: 2
  Type: NodeType.IF
  Expression: self.nodes[nodeHash].nodeType != NodeType.EMPTY

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(self.nodes[nodeHash].nodeType == node.nodeType)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(self.nodes[nodeHash].childLeft == node.childLeft)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(self.nodes[nodeHash].childRight == node.childRight)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(self.nodes[nodeHash].index == node.index)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(self.nodes[nodeHash].value == node.value)

  ID: 8
  Type: NodeType.RETURN
  Expression: nodeHash

  ID: 9
  Type: NodeType.ENDIF
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: self.nodes[nodeHash] = node

  ID: 11
  Type: NodeType.RETURN
  Expression: nodeHash

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 9
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  9 -> 10
  10 -> 11

Function: _getNodeHash
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: nodeHash = 0

  ID: 2
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.LEAF

  ID: 3
  Type: NodeType.VARIABLE
  Expression: params = (node.index,node.value,uint256(1))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: nodeHash = PoseidonUnit3L.poseidon(params)

  ID: 5
  Type: NodeType.IF
  Expression: node.nodeType == NodeType.MIDDLE

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: nodeHash = PoseidonUnit2L.poseidon((node.childLeft,node.childRight))

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

  ID: 9
  Type: NodeType.RETURN
  Expression: nodeHash

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  4 -> 8
  5 -> 6
  5 -> 7
  6 -> 7
  7 -> 8
  8 -> 9

Function: _getRootInfoByIndex
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: isLastRoot = index == self.rootEntries.length - 1

  ID: 2
  Type: NodeType.VARIABLE
  Expression: rootEntry = self.rootEntries[index]

  ID: 4
  Type: NodeType.IF
  Expression: isLastRoot

  ID: 5
  Type: NodeType.RETURN
  Expression: RootEntryInfo({root:rootEntry.root,replacedByRoot:0,createdAtTimestamp:rootEntry.createdAtTimestamp,replacedAtTimestamp:0,createdAtBlock:rootEntry.createdAtBlock,replacedAtBlock:0})

  ID: 6
  Type: NodeType.RETURN
  Expression: RootEntryInfo({root:rootEntry.root,replacedByRoot:self.rootEntries[index + 1].root,createdAtTimestamp:rootEntry.createdAtTimestamp,replacedAtTimestamp:self.rootEntries[index + 1].createdAtTimestamp,createdAtBlock:rootEntry.createdAtBlock,replacedAtBlock:self.rootEntries[index + 1].createdAtBlock})

Edges:
  0 -> 1
  1 -> 2
  2 -> 4
  4 -> 5
  4 -> 6

Function: _getRootInfoByTimestampOrBlock
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (index,found) = self.binarySearchUint256(timestampOrBlock,searchType)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: assert(bool)(found)

  ID: 5
  Type: NodeType.RETURN
  Expression: _getRootInfoByIndex(self,index)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _addEntry
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: self.rootEntries.push(RootEntry({root:root,createdAtTimestamp:_timestamp,createdAtBlock:_block}))

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: self.rootIndexes[root].push(self.rootEntries.length - 1)

Edges:
  0 -> 1
  1 -> 2

Function: slitherConstructorConstantVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: ROOT_INFO_LIST_RETURN_LIMIT = 1000

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: MAX_DEPTH_HARD_CAP = 256

Edges:
  0 -> 1


Contract: BinarySearchSmtRoots
==================================================

Function: binarySearchUint256
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self.rootEntries.length == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: (0,false)

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: min = 0

  ID: 5
  Type: NodeType.VARIABLE
  Expression: max = self.rootEntries.length - 1

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: min <= max

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: mid = (max + min) / 2

  ID: 10
  Type: NodeType.VARIABLE
  Expression: midValue = fieldSelector(self.rootEntries[mid],searchType)

  ID: 11
  Type: NodeType.IF
  Expression: midValue == value

  ID: 12
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 13
  Type: NodeType.IFLOOP
  Expression: mid < self.rootEntries.length - 1

  ID: 14
  Type: NodeType.VARIABLE
  Expression: nextValue = fieldSelector(self.rootEntries[mid + 1],searchType)

  ID: 15
  Type: NodeType.IF
  Expression: nextValue == value

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mid ++

  ID: 17
  Type: NodeType.RETURN
  Expression: (mid,true)

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 20
  Type: NodeType.RETURN
  Expression: (mid,true)

  ID: 21
  Type: NodeType.IF
  Expression: value > midValue

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: min = mid + 1

  ID: 23
  Type: NodeType.IF
  Expression: value < midValue && mid > 0

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: max = mid - 1

  ID: 25
  Type: NodeType.RETURN
  Expression: (0,false)

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 30
  Type: NodeType.RETURN
  Expression: (max,true)

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 29
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 21
  12 -> 13
  13 -> 14
  13 -> 19
  14 -> 15
  15 -> 16
  15 -> 17
  16 -> 18
  18 -> 13
  19 -> 20
  21 -> 22
  21 -> 23
  22 -> 27
  23 -> 24
  23 -> 25
  24 -> 26
  26 -> 27
  27 -> 28
  28 -> 8
  29 -> 30

Function: fieldSelector
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: st == SearchType.BLOCK

  ID: 2
  Type: NodeType.RETURN
  Expression: rti.createdAtBlock

  ID: 3
  Type: NodeType.IF
  Expression: st == SearchType.TIMESTAMP

  ID: 4
  Type: NodeType.RETURN
  Expression: rti.createdAtTimestamp

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: revert(string)(Invalid search type)

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7


