Contract: TransferHelper
==================================================

Function: safeApprove
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = token.call(abi.encodeWithSelector(0x095ea7b3,to,value))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success && (data.length == 0 || abi.decode(data,(bool))),TransferHelper: APPROVE_FAILED)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: safeTransfer
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = token.call(abi.encodeWithSelector(0xa9059cbb,to,value))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success && (data.length == 0 || abi.decode(data,(bool))),TransferHelper: TRANSFER_FAILED)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: safeTransferFrom
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,data) = token.call(abi.encodeWithSelector(0x23b872dd,from,to,value))

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success && (data.length == 0 || abi.decode(data,(bool))),TransferHelper: TRANSFER_FROM_FAILED)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: safeTransferETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (success,None) = to.call{value: value}(new bytes(0))

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,TransferHelper: ETH_TRANSFER_FAILED)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


Contract: IHybridRouter
==================================================


Contract: SafeMath
==================================================

Function: add
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: c = a + b

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(c >= a,SafeMath: addition overflow)

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: sub
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b <= a,errorMessage)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: c = a - b

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: mul
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: a == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: c = a * b

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(c / a == b,SafeMath: multiplication overflow)

  ID: 6
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: div
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b > 0,errorMessage)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: c = a / b

  ID: 3
  Type: NodeType.RETURN
  Expression: c

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: mod
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(b != 0,errorMessage)

  ID: 2
  Type: NodeType.RETURN
  Expression: a % b

Edges:
  0 -> 1
  1 -> 2


Contract: Address
==================================================

Function: isContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: size = extcodesize(uint256)(account)

  ID: 4
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.RETURN
  Expression: size > 0

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: sendValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (success,None) = recipient.call{value: amount}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: functionCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: functionCallWithValue(target,data,0,errorMessage)

Edges:
  0 -> 1

Function: functionCallWithValue
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: call to non-contract)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.call{value: value}(data)

  ID: 6
  Type: NodeType.RETURN
  Expression: _verifyCallResult(success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: functionStaticCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: static call to non-contract)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.staticcall(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: _verifyCallResult(success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: functionDelegateCall
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(isContract(target),Address: delegate call to non-contract)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: (success,returndata) = target.delegatecall(data)

  ID: 5
  Type: NodeType.RETURN
  Expression: _verifyCallResult(success,returndata,errorMessage)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5

Function: _verifyCallResult
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: success

  ID: 2
  Type: NodeType.RETURN
  Expression: returndata

  ID: 3
  Type: NodeType.IF
  Expression: returndata.length > 0

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: returndata_size__verifyCallResult_asm_0 = mload(uint256)(returndata)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(32 + returndata,returndata_size__verifyCallResult_asm_0)

  ID: 8
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: revert(string)(errorMessage)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 9
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  9 -> 10
  10 -> 11


Contract: IERC20
==================================================


Contract: IWETH
==================================================


Contract: IHybridRouterRegistry
==================================================


Contract: IPairV1
==================================================


Contract: IPairV2
==================================================


Contract: IPairV3
==================================================


Contract: IPairV4
==================================================


Contract: IPairV5
==================================================


Contract: HybridRouter
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: registry = _registry

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: WETH = _WETH

Edges:
  0 -> 1
  1 -> 2

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(msg.sender == WETH,TRANSFER_FAILED)

Edges:
  0 -> 1

Function: getPathIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: length = pair.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(length > 0,INVALID_PATH)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path = new address[](length + 1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: path[0] = tokenIn

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (token0,token1) = IHybridRouterRegistry(registry).getPairTokens(pair)

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: path[i + 1] = _findToken(token0[i],token1[i],tokenIn)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: tokenIn = path[i + 1]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 15
  Type: NodeType.RETURN
  Expression: path

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 15
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 11

Function: getPathOut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: length = pair.length

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(length > 0,INVALID_PATH)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: path = new address[](length + 1)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: path[path.length - 1] = tokenOut

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: (token0,token1) = IHybridRouterRegistry(registry).getPairTokens(pair)

  ID: 8
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 9
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: i = length - 1

  ID: 11
  Type: NodeType.IFLOOP
  Expression: i < length

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: path[i] = _findToken(token0[i],token1[i],tokenOut)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: tokenOut = path[i]

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 15
  Type: NodeType.RETURN
  Expression: path

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 10
  8 -> 11
  9 -> 15
  10 -> 8
  11 -> 12
  11 -> 9
  12 -> 13
  13 -> 14
  14 -> 11

Function: _findToken
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token0 != address(0) && token1 != address(0),PAIR_NOT_DEFINED)

  ID: 2
  Type: NodeType.IF
  Expression: token0 == token

  ID: 3
  Type: NodeType.RETURN
  Expression: token1

  ID: 4
  Type: NodeType.IF
  Expression: token1 == token

  ID: 5
  Type: NodeType.RETURN
  Expression: token0

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: revert(string)(PAIR_NOT_MATCH)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  4 -> 5
  4 -> 6
  6 -> 7
  7 -> 8

Function: _swap
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: balanceBefore = IERC20(path[path.length - 1]).balanceOf(_to)

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < path.length - 1

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: input = path[i]

  ID: 8
  Type: NodeType.VARIABLE
  Expression: output = path[i + 1]

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: (token0,None) = sortTokens(input,output)

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: direction = input == token0

  ID: 12
  Type: NodeType.VARIABLE
  Expression: amountOut = amounts[i + 1]

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 17
  Type: NodeType.VARIABLE
  Expression: typeCode = protocolTypeCode(pair[i])

  ID: 18
  Type: NodeType.IF
  Expression: typeCode == 1 || typeCode == 5

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: IPairV1(pair[i]).swap(amount0Out,amount1Out,to,new bytes(0))

  ID: 20
  Type: NodeType.IF
  Expression: typeCode == 2

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: IPairV2(pair[i]).swap(amount0Out,amount1Out,to,dataChunks[i])

  ID: 22
  Type: NodeType.IF
  Expression: typeCode == 3

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: IPairV3(pair[i]).swap(amount0Out,amount1Out,to,msg.sender,dataChunks[i])

  ID: 24
  Type: NodeType.IF
  Expression: typeCode == 4

  ID: 25
  Type: NodeType.EXPRESSION
  Expression: IPairV4(pair[i]).swap(amount0Out,amount1Out,to)

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(path[path.length - 1]).balanceOf(_to).sub(balanceBefore) >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 32
  Type: NodeType.IF
  Expression: direction

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: (amount0Out,amount1Out) = (uint256(0),amountOut)

  ID: 34
  Type: NodeType.EXPRESSION
  Expression: (amount0Out,amount1Out) = (amountOut,uint256(0))

  ID: 35
  Type: NodeType.ENDIF
  Expression: 

  ID: 36
  Type: NodeType.IF
  Expression: i < path.length - 2

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: to = pair[i + 1]

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: to = _to

  ID: 39
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  3 -> 31
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 32
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 29
  20 -> 21
  20 -> 22
  21 -> 28
  22 -> 23
  22 -> 24
  23 -> 27
  24 -> 25
  24 -> 26
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 5
  32 -> 33
  32 -> 34
  33 -> 35
  34 -> 35
  35 -> 36
  36 -> 37
  36 -> 38
  37 -> 39
  38 -> 39
  39 -> 17

Function: swapExactTokensForTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathIn(pair,tokenIn)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsOut(amountIn,path,pair,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[amounts.length - 1] >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amounts[0])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,to,pair,dataChunks,amountOutMin)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 8
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 7
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 8
  7 -> 1

Function: swapTokensForExactTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathOut(pair,tokenOut)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsIn(amountOut,path,pair,data)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _amountOut = amountOut

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[0] <= amountInMax,HybridRouter: EXCESSIVE_INPUT_AMOUNT)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amounts[0])

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,to,pair,dataChunks,_amountOut)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 9
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 9
  8 -> 1

Function: swapExactETHForTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathIn(pair,WETH)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsOut(msg.value,path,pair,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[amounts.length - 1] >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: amounts[0]}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IWETH(WETH).transfer(pair[0],amounts[0]),TRANSFER_FAILED)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,to,pair,dataChunks,amountOutMin)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 9
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 9
  8 -> 1

Function: swapTokensForExactETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathOut(pair,WETH)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsIn(amountOut,path,pair,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[0] <= amountInMax,HybridRouter: EXCESSIVE_INPUT_AMOUNT)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amounts[0])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,address(this),pair,dataChunks,amountOut)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).withdraw(amounts[amounts.length - 1])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferETH(to,amounts[amounts.length - 1])

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 10
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  9 -> 1

Function: swapExactTokensForETH
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathOut(pair,WETH)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsOut(amountIn,path,pair,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[amounts.length - 1] >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amounts[0])

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,address(this),pair,dataChunks,amountOutMin)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).withdraw(amounts[amounts.length - 1])

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferETH(to,amounts[amounts.length - 1])

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 10
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 9
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 10
  9 -> 1

Function: swapETHForExactTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: path = getPathIn(pair,WETH)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: (amounts,dataChunks) = getAmountsIn(amountOut,path,pair,data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amounts[0] <= msg.value,HybridRouter: EXCESSIVE_INPUT_AMOUNT)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: amounts[0]}()

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IWETH(WETH).transfer(pair[0],amounts[0]),TRANSFER_FAILED)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: _swap(amounts,path,to,pair,dataChunks,amountOut)

  ID: 8
  Type: NodeType.IF
  Expression: msg.value > amounts[0]

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferETH(msg.sender,msg.value - amounts[0])

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

  ID: 12
  Type: NodeType.RETURN
  Expression: (path,amounts)

Edges:
  0 -> 11
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  8 -> 10
  9 -> 10
  10 -> 12
  11 -> 1

Function: _swapSupportingFeeOnTransferTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 3
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.IFLOOP
  Expression: i < path.length - 1

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: sortTokens(path[i],path[i + 1])

  ID: 7
  Type: NodeType.VARIABLE
  Expression: direction = path[i] < path[i + 1]

  ID: 8
  Type: NodeType.VARIABLE
  Expression: amountInput = IERC20(path[i]).balanceOf(pair[i])

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: typeCode = protocolTypeCode(pair[i])

  ID: 12
  Type: NodeType.IF
  Expression: typeCode == 1 || typeCode == 4 || typeCode == 5

  ID: 13
  Type: NodeType.VARIABLE
  Expression: 

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: (reserve0,reserve1,None) = IPairV1(pair[i]).getReserves()

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: amountInput = amountInput.sub(reserve0)

  ID: 18
  Type: NodeType.IF
  Expression: typeCode == 5

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: amountOutput = IPairV5(pair[i]).getAmountOut(amountInput,path[i])

  ID: 20
  Type: NodeType.VARIABLE
  Expression: 

  ID: 21
  Type: NodeType.VARIABLE
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: (fee,feeBase) = IHybridRouterRegistry(registry).getFee(address(IPairV5(pair[i])))

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: amountOutput = getAmountOut(amountInput,reserve0,reserve1,fee,feeBase)

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.VARIABLE
  Expression: 

  ID: 26
  Type: NodeType.VARIABLE
  Expression: 

  ID: 28
  Type: NodeType.IF
  Expression: typeCode == 4

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: IPairV4(pair[i]).swap(amount0Out,amount1Out,to)

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: IPairV1(pair[i]).swap(amount0Out,amount1Out,to,new bytes(0))

  ID: 31
  Type: NodeType.ENDIF
  Expression: 

  ID: 32
  Type: NodeType.VARIABLE
  Expression: 

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: (offset,next) = cut(data,offset)

  ID: 34
  Type: NodeType.VARIABLE
  Expression: 

  ID: 35
  Type: NodeType.VARIABLE
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: (balance0,balance1) = IPairV2(pair[i]).getLastBalances()

  ID: 38
  Type: NodeType.IF
  Expression: typeCode == 2

  ID: 39
  Type: NodeType.VARIABLE
  Expression: _pair = IPairV2(pair[i])

  ID: 40
  Type: NodeType.EXPRESSION
  Expression: amountOutput = _pair.getAmountOut(path[i],amountInput,next)

  ID: 41
  Type: NodeType.VARIABLE
  Expression: 

  ID: 42
  Type: NodeType.VARIABLE
  Expression: 

  ID: 44
  Type: NodeType.EXPRESSION
  Expression: _pair.swap(amount0Out_scope_0,amount1Out_scope_1,to,next)

  ID: 45
  Type: NodeType.VARIABLE
  Expression: _pair_scope_2 = IPairV3(pair[i])

  ID: 46
  Type: NodeType.EXPRESSION
  Expression: amountOutput = _pair_scope_2.getAmountOut(path[i],amountInput,msg.sender,next)

  ID: 47
  Type: NodeType.VARIABLE
  Expression: 

  ID: 48
  Type: NodeType.VARIABLE
  Expression: 

  ID: 50
  Type: NodeType.EXPRESSION
  Expression: _pair_scope_2.swap(amount0Out_scope_3,amount1Out_scope_4,to,msg.sender,next)

  ID: 51
  Type: NodeType.ENDIF
  Expression: 

  ID: 52
  Type: NodeType.ENDIF
  Expression: 

  ID: 53
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 54
  Type: NodeType.IF
  Expression: i < path.length - 2

  ID: 55
  Type: NodeType.EXPRESSION
  Expression: to = pair[i + 1]

  ID: 56
  Type: NodeType.EXPRESSION
  Expression: to = _to

  ID: 57
  Type: NodeType.ENDIF
  Expression: 

  ID: 58
  Type: NodeType.IF
  Expression: direction

  ID: 59
  Type: NodeType.EXPRESSION
  Expression: (reserve0,reserve1) = (reserve0,reserve1)

  ID: 60
  Type: NodeType.EXPRESSION
  Expression: (reserve0,reserve1) = (reserve1,reserve0)

  ID: 61
  Type: NodeType.ENDIF
  Expression: 

  ID: 62
  Type: NodeType.IF
  Expression: direction

  ID: 63
  Type: NodeType.EXPRESSION
  Expression: (amount0Out,amount1Out) = (uint256(0),amountOutput)

  ID: 64
  Type: NodeType.EXPRESSION
  Expression: (amount0Out,amount1Out) = (amountOutput,uint256(0))

  ID: 65
  Type: NodeType.ENDIF
  Expression: 

  ID: 66
  Type: NodeType.IF
  Expression: direction

  ID: 67
  Type: NodeType.EXPRESSION
  Expression: amountInput = amountInput.sub(balance0)

  ID: 68
  Type: NodeType.EXPRESSION
  Expression: amountInput = amountInput.sub(balance1)

  ID: 69
  Type: NodeType.ENDIF
  Expression: 

  ID: 70
  Type: NodeType.IF
  Expression: direction

  ID: 71
  Type: NodeType.EXPRESSION
  Expression: (amount0Out_scope_0,amount1Out_scope_1) = (uint256(0),amountOutput)

  ID: 72
  Type: NodeType.EXPRESSION
  Expression: (amount0Out_scope_0,amount1Out_scope_1) = (amountOutput,uint256(0))

  ID: 73
  Type: NodeType.ENDIF
  Expression: 

  ID: 74
  Type: NodeType.IF
  Expression: direction

  ID: 75
  Type: NodeType.EXPRESSION
  Expression: (amount0Out_scope_3,amount1Out_scope_4) = (uint256(0),amountOutput)

  ID: 76
  Type: NodeType.EXPRESSION
  Expression: (amount0Out_scope_3,amount1Out_scope_4) = (amountOutput,uint256(0))

  ID: 77
  Type: NodeType.ENDIF
  Expression: 

Edges:
  0 -> 1
  1 -> 4
  2 -> 5
  4 -> 2
  5 -> 6
  5 -> 3
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 54
  12 -> 13
  12 -> 32
  13 -> 14
  14 -> 15
  15 -> 58
  17 -> 18
  18 -> 19
  18 -> 20
  19 -> 24
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 62
  28 -> 29
  28 -> 30
  29 -> 31
  30 -> 31
  31 -> 52
  32 -> 33
  33 -> 34
  34 -> 35
  35 -> 36
  36 -> 66
  38 -> 39
  38 -> 45
  39 -> 40
  40 -> 41
  41 -> 42
  42 -> 70
  44 -> 51
  45 -> 46
  46 -> 47
  47 -> 48
  48 -> 74
  50 -> 51
  51 -> 52
  52 -> 53
  53 -> 5
  54 -> 55
  54 -> 56
  55 -> 57
  56 -> 57
  57 -> 12
  58 -> 59
  58 -> 60
  59 -> 61
  60 -> 61
  61 -> 17
  62 -> 63
  62 -> 64
  63 -> 65
  64 -> 65
  65 -> 28
  66 -> 67
  66 -> 68
  67 -> 69
  68 -> 69
  69 -> 38
  70 -> 71
  70 -> 72
  71 -> 73
  72 -> 73
  73 -> 44
  74 -> 75
  74 -> 76
  75 -> 77
  76 -> 77
  77 -> 50

Function: swapExactTokensForTokensSupportingFeeOnTransferTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathIn(pair,tokenIn)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amountIn)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: balanceBefore = IERC20(path[path.length - 1]).balanceOf(to)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: _swapSupportingFeeOnTransferTokens(path,to,pair,data)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

Edges:
  0 -> 6
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  6 -> 1

Function: swapExactETHForTokensSupportingFeeOnTransferTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathIn(pair,WETH)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: amountIn = msg.value

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).deposit{value: amountIn}()

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IWETH(WETH).transfer(pair[0],amountIn),TRANSFER_FAILED)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: balanceBefore = IERC20(path[path.length - 1]).balanceOf(to)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: _swapSupportingFeeOnTransferTokens(path,to,pair,data)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: swapExactTokensForETHSupportingFeeOnTransferTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathOut(pair,WETH)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferFrom(path[0],msg.sender,pair[0],amountIn)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: _swapSupportingFeeOnTransferTokens(path,address(this),pair,data)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: amountOut = IERC20(WETH).balanceOf(address(this))

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amountOut >= amountOutMin,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: IWETH(WETH).withdraw(amountOut)

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: TransferHelper.safeTransferETH(to,amountOut)

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: ensure(deadline)

Edges:
  0 -> 8
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  8 -> 1

Function: sortTokens
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(tokenA != tokenB,IDENTICAL_ADDRESSES)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(token0 != address(0),ZERO_ADDRESS)

  ID: 4
  Type: NodeType.IF
  Expression: tokenA < tokenB

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (token0,token1) = (tokenA,tokenB)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: (token0,token1) = (tokenB,tokenA)

  ID: 7
  Type: NodeType.ENDIF
  Expression: 

  ID: 8
  Type: NodeType.RETURN
  Expression: (token0,token1)

Edges:
  0 -> 1
  1 -> 4
  3 -> 8
  4 -> 5
  4 -> 6
  5 -> 7
  6 -> 7
  7 -> 3

Function: protocolTypeCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: typeCode = IHybridRouterRegistry(registry).getTypeCode(pair)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(typeCode > 0 && typeCode < 6,PAIR_NOT_REGCONIZED)

  ID: 3
  Type: NodeType.RETURN
  Expression: typeCode

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getReserves
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (token0,None) = sortTokens(tokenA,tokenB)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: (reserve0,reserve1,None) = IPairV1(pair).getReserves()

  ID: 7
  Type: NodeType.IF
  Expression: tokenA == token0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: (reserveA,reserveB) = (reserve0,reserve1)

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: (reserveA,reserveB) = (reserve1,reserve0)

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.RETURN
  Expression: (reserveA,reserveB)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 7
  7 -> 8
  7 -> 9
  8 -> 10
  9 -> 10
  10 -> 11

Function: getAmountOut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amountIn > 0,INSUFFICIENT_INPUT_AMOUNT)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reserveIn > 0 && reserveOut > 0,INSUFFICIENT_LIQUIDITY)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: amountInWithFee = amountIn.mul(fee)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: numerator = amountInWithFee.mul(reserveOut)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: denominator = reserveIn.mul(feeBase).add(amountInWithFee)

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: amountOut = numerator / denominator

  ID: 7
  Type: NodeType.RETURN
  Expression: amountOut

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7

Function: getAmountIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(amountOut > 0,HybridRouter: INSUFFICIENT_OUTPUT_AMOUNT)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(reserveIn > 0 && reserveOut > 0,INSUFFICIENT_LIQUIDITY)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: numerator = reserveIn.mul(amountOut).mul(feeBase)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: denominator = reserveOut.sub(amountOut).mul(fee)

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: amountIn = (numerator / denominator).add(1)

  ID: 6
  Type: NodeType.RETURN
  Expression: amountIn

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: cut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: total_cut_asm_0 = mload(uint256)(data)

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: offset = offset + 0x20

  ID: 5
  Type: NodeType.IF
  Expression: offset < total_cut_asm_0 | offset == total_cut_asm_0

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: size_cut_asm_0 = mload(uint256)(data + offset)

  ID: 9
  Type: NodeType.IF
  Expression: offset + size_cut_asm_0 > total_cut_asm_0

  ID: 10
  Type: NodeType.ENDIF
  Expression: 

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: revert(uint256,uint256)(0,0)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: mark_cut_asm_0 = mload(uint256)(0x40)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(0x40,mark_cut_asm_0 + size_cut_asm_0 + 0x20)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(mark_cut_asm_0,size_cut_asm_0)

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: nextOffset = offset + size_cut_asm_0

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: out = mark_cut_asm_0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: mark_cut_asm_0 = mark_cut_asm_0 + 0x20

  ID: 19
  Type: NodeType.VARIABLE
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: src_cut_asm_0 = data + offset + 0x20

  ID: 21
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 22
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 23
  Type: NodeType.VARIABLE
  Expression: 

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: i_cut_asm_0 = 0

  ID: 25
  Type: NodeType.IFLOOP
  Expression: i_cut_asm_0 < size_cut_asm_0

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(mark_cut_asm_0 + i_cut_asm_0,mload(uint256)(src_cut_asm_0 + i_cut_asm_0))

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: i_cut_asm_0 = i_cut_asm_0 + 0x20

  ID: 28
  Type: NodeType.VARIABLE
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: i_cut_asm_0 = size_cut_asm_0 - 0x20

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(mark_cut_asm_0 + i_cut_asm_0,mload(uint256)(src_cut_asm_0 + i_cut_asm_0))

  ID: 31
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 32
  Type: NodeType.RETURN
  Expression: (nextOffset,out)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 7
  5 -> 6
  6 -> 31
  7 -> 8
  8 -> 9
  9 -> 11
  9 -> 10
  10 -> 12
  11 -> 10
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 23
  22 -> 28
  23 -> 24
  24 -> 25
  25 -> 22
  25 -> 26
  26 -> 27
  27 -> 25
  28 -> 29
  29 -> 30
  30 -> 6
  31 -> 32

Function: getAmountsOut
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: amounts = new uint256[](path.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dataChunks = new bytes[](pair.length)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: amounts[0] = amountIn

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < path.length - 1

  ID: 9
  Type: NodeType.VARIABLE
  Expression: typeCode = protocolTypeCode(pair[i])

  ID: 10
  Type: NodeType.IF
  Expression: typeCode == 1 || typeCode == 4

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (reserveIn,reserveOut) = getReserves(pair[i],path[i],path[i + 1])

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (fee,feeBase) = IHybridRouterRegistry(registry).getFee(pair[i])

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: amounts[i + 1] = getAmountOut(amounts[i],reserveIn,reserveOut,fee,feeBase)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: (offset,next) = cut(data,offset)

  ID: 20
  Type: NodeType.IF
  Expression: typeCode == 2

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: amounts[i + 1] = IPairV2(pair[i]).getAmountOut(path[i],amounts[i],next)

  ID: 22
  Type: NodeType.IF
  Expression: typeCode == 3

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: amounts[i + 1] = IPairV3(pair[i]).getAmountOut(path[i],amounts[i],msg.sender,next)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: amounts[i + 1] = IPairV5(pair[i]).getAmountOut(amounts[i],path[i])

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: dataChunks[i] = next

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 30
  Type: NodeType.RETURN
  Expression: (amounts,dataChunks)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 30
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 18
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 28
  18 -> 19
  19 -> 20
  20 -> 21
  20 -> 22
  21 -> 26
  22 -> 23
  22 -> 24
  23 -> 25
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 8

Function: getAmountsIn
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: amounts = new uint256[](path.length)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: dataChunks = new bytes[](pair.length)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: amounts[amounts.length - 1] = amountOut

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = path.length - 1

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i > 0

  ID: 9
  Type: NodeType.VARIABLE
  Expression: typeCode = protocolTypeCode(pair[i - 1])

  ID: 10
  Type: NodeType.IF
  Expression: typeCode == 1 || typeCode == 4

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: (reserveIn,reserveOut) = getReserves(pair[i - 1],path[i - 1],path[i])

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.VARIABLE
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: (fee,feeBase) = IHybridRouterRegistry(registry).getFee(pair[i - 1])

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: amounts[i - 1] = getAmountIn(amounts[i],reserveIn,reserveOut,fee,feeBase)

  ID: 18
  Type: NodeType.VARIABLE
  Expression: 

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: (offset,next) = cut(data,offset)

  ID: 20
  Type: NodeType.IF
  Expression: typeCode == 2

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: amounts[i - 1] = IPairV2(pair[i - 1]).getAmountIn(path[i],amounts[i],next)

  ID: 22
  Type: NodeType.IF
  Expression: typeCode == 3

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: amounts[i - 1] = IPairV3(pair[i - 1]).getAmountIn(path[i],amounts[i],msg.sender,next)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: amounts[i - 1] = IPairV5(pair[i - 1]).getAmountIn(amounts[i],path[i])

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: dataChunks[i - 1] = next

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: i --

  ID: 30
  Type: NodeType.RETURN
  Expression: (amounts,dataChunks)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 30
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  10 -> 18
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 28
  18 -> 19
  19 -> 20
  20 -> 21
  20 -> 22
  21 -> 26
  22 -> 23
  22 -> 24
  23 -> 25
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 8

Function: getAmountsInStartsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathIn(pair,tokenIn)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (amounts,None) = getAmountsIn(amountOut,path,pair,data)

  ID: 3
  Type: NodeType.RETURN
  Expression: amounts

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getAmountsInEndsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathOut(pair,tokenOut)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (amounts,None) = getAmountsIn(amountOut,path,pair,data)

  ID: 3
  Type: NodeType.RETURN
  Expression: amounts

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getAmountsOutStartsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathIn(pair,tokenIn)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (amounts,None) = getAmountsOut(amountIn,path,pair,data)

  ID: 3
  Type: NodeType.RETURN
  Expression: amounts

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getAmountsOutEndsWith
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: path = getPathOut(pair,tokenOut)

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: (amounts,None) = getAmountsOut(amountIn,path,pair,data)

  ID: 3
  Type: NodeType.RETURN
  Expression: amounts

Edges:
  0 -> 1
  1 -> 2
  2 -> 3


