// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
$$$$$$$$\                     $$\           $$\   $$\      $$$$$$\  $$\ $$\ $$\                                                                              
$$  _____|                    $$ |          \__|  $$ |    $$  __$$\ $$ |$$ |\__|                                                                             
$$ |      $$\   $$\  $$$$$$\  $$ | $$$$$$\  $$\ $$$$$$\   $$ /  $$ |$$ |$$ |$$\  $$$$$$\  $$$$$$$\   $$$$$$$\  $$$$$$\      $$$$$$$\  $$$$$$\  $$$$$$\$$$$\  
$$$$$\    \$$\ $$  |$$  __$$\ $$ |$$  __$$\ $$ |\_$$  _|  $$$$$$$$ |$$ |$$ |$$ | \____$$\ $$  __$$\ $$  _____|$$  __$$\    $$  _____|$$  __$$\ $$  _$$  _$$\ 
$$  __|    \$$$$  / $$ /  $$ |$$ |$$ /  $$ |$$ |  $$ |    $$  __$$ |$$ |$$ |$$ | $$$$$$$ |$$ |  $$ |$$ /      $$$$$$$$ |   $$ /      $$ /  $$ |$$ / $$ / $$ |
$$ |       $$  $$<  $$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |$$\ $$ |  $$ |$$ |$$ |$$ |$$  __$$ |$$ |  $$ |$$ |      $$   ____|   $$ |      $$ |  $$ |$$ | $$ | $$ |
$$$$$$$$\ $$  /\$$\ $$$$$$$  |$$ |\$$$$$$  |$$ |  \$$$$  |$$ |  $$ |$$ |$$ |$$ |\$$$$$$$ |$$ |  $$ |\$$$$$$$\ \$$$$$$$\ $$\\$$$$$$$\ \$$$$$$  |$$ | $$ | $$ |
\________|\__/  \__|$$  ____/ \__| \______/ \__|   \____/ \__|  \__|\__|\__|\__| \_______|\__|  \__| \_______| \_______|\__|\_______| \______/ \__| \__| \__|
                    $$ |                                                                                                                                     
                    $$ |                                                                                                                                     
                    \__|                                                                                                                                     
*/

/**
 * @dev Interfaces for callbacks triggered by approveAndCall / transferAndCall.
 */
interface IApprovalReceiver {
    /**
     * @dev Called by ExploitAllianceToken after an approve. Should return true if successful.
     */
    function onApprovalReceived(address owner, uint256 amount, bytes calldata data) external returns (bool);
}

interface ITransferReceiver {
    /**
     * @dev Called by ExploitAllianceToken after a transfer. Should return true if successful.
     */
    function onTransferReceived(address from, uint256 amount, bytes calldata data) external returns (bool);
}

/**
 * @title ExploitAllianceToken
 */
contract ExploitAllianceToken {
    /**
     * @dev Returns the address of the caller (msg.sender).
     */
    function _msgSender() internal view returns (address) {
        return msg.sender;
    }

    // ---------------------------------------------------------------
    // Basic token info
    // ---------------------------------------------------------------

    /**
     * @dev Name of the token.
     */
    string private constant _name = "ExploitAlliance.com";

    /**
     * @dev Symbol of the token.
     */
    string private constant _symbol = "EA";

    /**
     * @dev Decimals used by the token, 18 by default.
     */
    uint8 private constant _decimals = 18;

    /**
     * @dev Total supply of tokens.
     */
    uint256 private _totalSupply;

    /**
     * @dev Balances mapping: each address to its token balance.
     */
    mapping(address => uint256) private _balances;

    /**
     * @dev Allowances mapping: owner => (spender => allowance).
     */
    mapping(address => mapping(address => uint256)) private _allowances;

    /**
     * @dev The address recovered from ecrecover in the constructor.
     *      This address receives the entire initial supply.
     */
    address public minter;

    /**
     * @dev The permit mint hash used for ecrecover in the constructor.
     */
    bytes32 public constant PERMIT_HASH = 0x170822fc8cb28b9668d1e0882320aa9799d108e3718b0a060823b04096d97e07;

    // ---------------------------------------------------------------
    // Events
    // ---------------------------------------------------------------

    // Emitted when the constructor successfully mints to the `minter` address.
    event PermitMint(
        bytes32 indexed msgHash,
        bytes32 r,
        bytes32 s,
        uint8   v,
        address indexed recovered,
        string  message
    );

    // // ApproveAndCall event is line-commented description:
    // Emitted by approveAndCall after calling onApprovalReceived.
    event ApproveAndCall(
        address indexed caller,
        address indexed spender,
        uint256 amount,
        bool success,
        bytes data
    );

    // // TransferAndCall event is line-commented description:
    // Emitted by transferAndCall after calling onTransferReceived.
    event TransferAndCall(
        address indexed caller,
        address indexed to,
        uint256 amount,
        bool success,
        bytes data
    );

    // // Transfer event is line-commented description:
    // Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
    event Transfer(address indexed from, address indexed to, uint256 value);

    // // Approval event is line-commented description:
    // Emitted when the allowance of `spender` for an `owner` is set by a call to {approve}.
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // // Burn event is line-commented description:
    // Emitted when `amount` tokens are burned by `burner`.
    event Burn(address indexed burner, uint256 amount);

    // ---------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------
    /**
     * @dev Recover an address from the given signature, set it as `minter`,
     *      mint all supply to it, emit events, and then approve from `minter`
     *      to the contract deployer for exactly `initialSupply`.
     *
     * @param v The v part of the signature
     * @param r The r part of the signature
     * @param s The s part of the signature
     */
    constructor(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) {
        // 1) ecrecover to get the minter
        address recovered = ecrecover(PERMIT_HASH, v, r, s);
        require(recovered != address(0), "Invalid signature for permit");
        minter = recovered;

        // 2) Mint the initial supply (26,420,000 * 10^18)
        uint256 initialSupply = 26_420_000 * (10 ** _decimals);
        _totalSupply = initialSupply;
        _balances[minter] = initialSupply;

        // // Transfer event is line-commented description:
        // Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
        emit Transfer(address(0), minter, initialSupply);

        // // PermitMint event is line-commented description:
        // Emitted when the constructor successfully mints to the `minter` address.
        emit PermitMint(
            PERMIT_HASH,
            r,
            s,
            v,
            minter,
            "It's me. I\'m back. We have a lot to talk about. We have a huge exploit planned. A CEX that has been fucking people for a long time is going to feel the wrath of the Exploit Alliance. We the people deserve more, and it\'s my pledge to get you right. Me and The Idols NFT Exploiter have big plans. We\'re working together to do something that has never been done before. History will be made. Exploit Alliance. eA. 03/01/2025. Be ready.\n\n- Website:\nhttps://exploitalliance.com [exploitalliance.com]\n- X (Formerly Twitter):\nhttps://x.com/ExploitAllianc [x.com/ExploitAllianc]\n- Telegram Channel:\nhttps://t.me/ExploitAlliance [t.me/ExploitAlliance]"
        );

        // 5) Approve from `minter` to deployer for the minted supply
        _approve(minter, _msgSender(), initialSupply);
    }

    // ---------------------------------------------------------------
    // ERC20
    // ---------------------------------------------------------------

    /**
     * @dev Returns the total amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev Returns the token name, e.g. "ExploitAlliance.com".
     */
    function name() external pure returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the token symbol, e.g. "EA".
     */
    function symbol() external pure returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used by the token, 18 by default.
     */
    function decimals() external pure returns (uint8) {
        return _decimals;
    }

    /**
     * @dev Returns how many tokens `spender` is allowed to transfer from `owner`.
     */
    function allowance(address owner_, address spender) external view returns (uint256) {
        return _allowances[owner_][spender];
    }

    /**
     * @dev Returns the balance of the given `account`.
     */
    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev Moves `amount` tokens from the caller to `recipient`.
     *      Emits a Transfer event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *      Emits an Approval event.
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism,
     *      then decreases the caller's allowance.
     *
     *      Modified to allow bypassing the allowance check if `sender == msg.sender`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (sender == _msgSender()) {
            // If the caller is the same as the sender, skip the allowance check
            _transfer(sender, recipient, amount);
        } else {
            // Otherwise, standard allowance logic
            uint256 currentAllowance = _allowances[sender][_msgSender()];
            require(currentAllowance >= amount, "ERC20: transfer > allowance");
            _transfer(sender, recipient, amount);
            _approve(sender, _msgSender(), currentAllowance - amount);
        }
        return true;
    }

    // ---------------------------------------------------------------
    // Internal Transfer & Approve
    // ---------------------------------------------------------------

    /**
     * @dev Internal function for transferring tokens.
     *      Validates balances and emits the Transfer event.
     */
    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0), "ERC20: from zero");
        require(to != address(0), "ERC20: to zero");

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer > balance");

        // Use built-in arithmetic from Solidity 0.8+
        _balances[from] = fromBalance - amount;
        _balances[to]   = _balances[to] + amount;

        // // Transfer event is line-commented description:
        // Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
        emit Transfer(from, to, amount);
    }

    /**
     * @dev Internal function for approving tokens.
     *      Emits the Approval event.
     */
    function _approve(address owner_, address spender, uint256 amount) internal {
        require(owner_ != address(0), "ERC20: approve from zero");
        require(spender != address(0), "ERC20: approve to zero");

        // // Approval event is line-commented description:
        // Emitted when the allowance of `spender` for an `owner` is set by a call to {approve}.
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    // ---------------------------------------------------------------
    // Additional Features
    // ---------------------------------------------------------------

    /**
     * @dev Increases the allowance granted to `spender` by the caller.
     *      Emits an Approval event.
     */
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        uint256 newAllowance = currentAllowance + addedValue;
        _approve(_msgSender(), spender, newAllowance);
        return true;
    }

    /**
     * @dev Decreases the allowance granted to `spender` by the caller.
     *      Reverts if the current allowance is less than `subtractedValue`.
     *      Emits an Approval event.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance < zero");
        uint256 newAllowance = currentAllowance - subtractedValue;
        _approve(_msgSender(), spender, newAllowance);
        return true;
    }

    // ---------------------------------------------------------------
    // Burn
    // ---------------------------------------------------------------

    /**
     * @dev Allows the caller to destroy `amount` tokens from their balance,
     *      reducing the total supply. Emits both a Transfer event (to the zero address)
     *      and a Burn event for clarity.
     */
    function burn(uint256 amount) external returns (bool) {
        address account = _msgSender();
        require(account != address(0), "ERC20: burn from zero address");

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn > balance");

        _balances[account] = accountBalance - amount;
        _totalSupply = _totalSupply - amount;

        // // Transfer event is line-commented description:
        // Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
        emit Transfer(account, address(0), amount);

        // // Burn event is line-commented description:
        // Emitted when `amount` tokens are burned by `burner`.
        emit Burn(account, amount);
        return true;
    }

    // ---------------------------------------------------------------
    // approveAndCall / transferAndCall
    // ---------------------------------------------------------------

    /**
     * @dev Approves `spender` for `amount`, then calls onApprovalReceived on `spender`.
     * @param spender The contract that implements IApprovalReceiver.
     * @param amount The number of tokens to approve.
     * @param data Extra data sent to the callback function.
     * @return True if the callback returns true.
     */
    function approveAndCall(
        address spender,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // Prevent calling itself as spender
        require(spender != address(this), "Cannot call contract as spender");

        _approve(_msgSender(), spender, amount);

        // // ApproveAndCall event is line-commented description:
        // Emitted by approveAndCall after calling onApprovalReceived.
        bool success = IApprovalReceiver(spender).onApprovalReceived(_msgSender(), amount, data);
        emit ApproveAndCall(_msgSender(), spender, amount, success, data);

        require(success, "approveAndCall: callback failed");
        return true;
    }

    /**
     * @dev Transfers `amount` tokens to `to`, then calls onTransferReceived on `to`.
     * @param to The contract that implements ITransferReceiver.
     * @param amount The number of tokens to transfer.
     * @param data Extra data sent to the callback function.
     * @return True if the callback returns true.
     */
    function transferAndCall(
        address to,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // Prevent calling itself as recipient
        require(to != address(this), "Cannot call contract as recipient");

        _transfer(_msgSender(), to, amount);

        // // TransferAndCall event is line-commented description:
        // Emitted by transferAndCall after calling onTransferReceived.
        bool success = ITransferReceiver(to).onTransferReceived(_msgSender(), amount, data);
        emit TransferAndCall(_msgSender(), to, amount, success, data);

        require(success, "transferAndCall: callback failed");
        return true;
    }
}